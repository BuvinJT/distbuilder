{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Distribution Builder Python Library \u00b6 Introduction \u00b6 \u201cDistribution Builder\u201d (distbuilder) is an open source Python library. It is a \u201cmeta tool\u201d, which wraps and combines other related libraries and utilities including PyInstaller , IExpress , the Qt Installer Framework , Opy (Obfuscator for Python), pip , and more. As one might guess, the primary role which Distribution Builder can serve for your development needs is packaging and deploying Python based programs. It can, however, be employed for distributing software written in other languages as well. To this end, a dedicated module, has been provided which is specific for Qt C++ Integration . The library also includes the means to transform simple Windows scripts (Batch, PowerShell, VBScript, or JScript) into full blown executable programs. More cross language / cross framework integration modules will become available in the future. This library is compatible with both Python 2 and 3. It has been tested on recent versions of Windows, macOS, and multiple Linux distros. It features the ability to create stand-alone binaries, and is capable of building installers in a cross platform manner (via QtIFW). These installers can be produced for either gui or non-gui (i.e terminal interface) contexts. Note that the later is a feature QtIFW does not naturally provide. The library can also be used to obfuscate code (via Opy), so as to protect proprietary work. See the Quick Start Guide for instructions on installation and getting started with the tool. For a more thorough explanation of how to use it, it is recommended you proceed to High Level Classes . Then, as needed, move on to Configuration Classes and/or Low Level Classes And Functions . If you wish to contribute, please review the To-Do List for a collection of desired tasks to be completed and the priority they have been currently designated, as part of a loose road map for planned releases. Additional Project Goals \u00b6 In addition to everything which is already fleshed out and functional within it, \u201cDistribution Builder\u201d will soon supply a new development paradigm \u2026 Using the obfuscation and library management features, it will provide the ability for collaborators to work on a Python project together, without directly sharing source code ! We acknowledge this idea may to be deemed \u201canti-Pythonic\u201d by purists, since the language is commonly employed for open source purposes, and the Python ecosystem is almost 100% open source. Note that the \u201cDistribution Builder\u201d developers are not anti-open source! In fact, observe that this project is itself open source, and built over the top of other open source projects! We are, however, pro-security, and we advocate for the owners of intellectual property. We argue that if it is not universally \u201cwrong\u201d to produce close sourced programs, doing so should not be dubbed off limits with Python, if an organization or individual so choses. Once theses features (in development) are completed and smoothed over, each Python developer on a project could independently create libraries with a clear text public interface, but which employ code bases that are obfuscated. Other developers could then implement the functionality of those libraries as they develop their modules. \u201cDistribution Builder\u201d could next seamlessly bring together everyone\u2019s work into a single project, where all of the protected code bases work together and even the \u201cseams\u201d between those public interfaces become obfuscated. In this scenario, each developer will have this capability, and therefore be able to test their own work - on the fly - within the context of the larger product. Producing software in this manner, allows engineers to work together on endeavors where there are gray areas pertaining to intellectual rights and/or the legalities of such have yet to be solidified. This mechanism mitigates the risk of an individual stealing an entire code base, or being \u201cboxed out\u201d of a project for which they made considerable contributions. While this overarching concept has long been available with other languages (e.g. with C++ dll\u2019s and other analogous compiled components), this has not generally been an option for Python. Even in those languages where such is a \u201cready option\u201d, a development scheme of this nature is often too cumbersome to employ, or simply not an option developers have considered. \u201cDistribution Builder\u201d aims to make this a painless and realistic mode of operation for Python. Important Notes \u00b6 BEFORE USE, BACK UP YOUR CODE TO ENSURE THERE COULD NOT POSSIBLY BE ANYTHING LOST!!! This library is actively under development. It is not yet officially released for production use. Function signatures, class definitions, etc. are NOT currently guaranteed to be stable / backwards compatible. Client implementations may require modification upon pulling the latest revisions to this. At the present time, the weakest components in the library are admittedly the obfuscation features. There is a bit of a learning curve for utilizing such, and a fair degree of effort is likely required to perfect it for your own project right now. It is recommended that you employ these security features only after getting the rest of your build process defined.","title":"Home"},{"location":"index.html#distribution-builder-python-library","text":"","title":"Distribution Builder Python Library"},{"location":"index.html#introduction","text":"\u201cDistribution Builder\u201d (distbuilder) is an open source Python library. It is a \u201cmeta tool\u201d, which wraps and combines other related libraries and utilities including PyInstaller , IExpress , the Qt Installer Framework , Opy (Obfuscator for Python), pip , and more. As one might guess, the primary role which Distribution Builder can serve for your development needs is packaging and deploying Python based programs. It can, however, be employed for distributing software written in other languages as well. To this end, a dedicated module, has been provided which is specific for Qt C++ Integration . The library also includes the means to transform simple Windows scripts (Batch, PowerShell, VBScript, or JScript) into full blown executable programs. More cross language / cross framework integration modules will become available in the future. This library is compatible with both Python 2 and 3. It has been tested on recent versions of Windows, macOS, and multiple Linux distros. It features the ability to create stand-alone binaries, and is capable of building installers in a cross platform manner (via QtIFW). These installers can be produced for either gui or non-gui (i.e terminal interface) contexts. Note that the later is a feature QtIFW does not naturally provide. The library can also be used to obfuscate code (via Opy), so as to protect proprietary work. See the Quick Start Guide for instructions on installation and getting started with the tool. For a more thorough explanation of how to use it, it is recommended you proceed to High Level Classes . Then, as needed, move on to Configuration Classes and/or Low Level Classes And Functions . If you wish to contribute, please review the To-Do List for a collection of desired tasks to be completed and the priority they have been currently designated, as part of a loose road map for planned releases.","title":"Introduction"},{"location":"index.html#additional-project-goals","text":"In addition to everything which is already fleshed out and functional within it, \u201cDistribution Builder\u201d will soon supply a new development paradigm \u2026 Using the obfuscation and library management features, it will provide the ability for collaborators to work on a Python project together, without directly sharing source code ! We acknowledge this idea may to be deemed \u201canti-Pythonic\u201d by purists, since the language is commonly employed for open source purposes, and the Python ecosystem is almost 100% open source. Note that the \u201cDistribution Builder\u201d developers are not anti-open source! In fact, observe that this project is itself open source, and built over the top of other open source projects! We are, however, pro-security, and we advocate for the owners of intellectual property. We argue that if it is not universally \u201cwrong\u201d to produce close sourced programs, doing so should not be dubbed off limits with Python, if an organization or individual so choses. Once theses features (in development) are completed and smoothed over, each Python developer on a project could independently create libraries with a clear text public interface, but which employ code bases that are obfuscated. Other developers could then implement the functionality of those libraries as they develop their modules. \u201cDistribution Builder\u201d could next seamlessly bring together everyone\u2019s work into a single project, where all of the protected code bases work together and even the \u201cseams\u201d between those public interfaces become obfuscated. In this scenario, each developer will have this capability, and therefore be able to test their own work - on the fly - within the context of the larger product. Producing software in this manner, allows engineers to work together on endeavors where there are gray areas pertaining to intellectual rights and/or the legalities of such have yet to be solidified. This mechanism mitigates the risk of an individual stealing an entire code base, or being \u201cboxed out\u201d of a project for which they made considerable contributions. While this overarching concept has long been available with other languages (e.g. with C++ dll\u2019s and other analogous compiled components), this has not generally been an option for Python. Even in those languages where such is a \u201cready option\u201d, a development scheme of this nature is often too cumbersome to employ, or simply not an option developers have considered. \u201cDistribution Builder\u201d aims to make this a painless and realistic mode of operation for Python.","title":"Additional Project Goals"},{"location":"index.html#important-notes","text":"BEFORE USE, BACK UP YOUR CODE TO ENSURE THERE COULD NOT POSSIBLY BE ANYTHING LOST!!! This library is actively under development. It is not yet officially released for production use. Function signatures, class definitions, etc. are NOT currently guaranteed to be stable / backwards compatible. Client implementations may require modification upon pulling the latest revisions to this. At the present time, the weakest components in the library are admittedly the obfuscation features. There is a bit of a learning curve for utilizing such, and a fair degree of effort is likely required to perfect it for your own project right now. It is recommended that you employ these security features only after getting the rest of your build process defined.","title":"Important Notes"},{"location":"Code%20Signing.html","text":"CodeSignConfig class \u00b6 Magic Methods: __init__ Instance Methods: Instance Attributes: keyFilePath keyPassword signToolPath fileDigest timeStampDigest timeStampServerUrl otherSignToolArgs isDebugMode Class/Static Attributes: DEFAULT_DIGEST DEFAULT_TIMESTAMP_SERVER CodeSignConfig ( keyFilePath = None , keyPassword = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . keyFilePath class \u2018NoneType\u2019 default: None \u00b6 obj . keyPassword class \u2018NoneType\u2019 default: None \u00b6 obj . signToolPath class \u2018NoneType\u2019 default: None \u00b6 obj . fileDigest class \u2018str\u2019 default: \u201csha256\u201d \u00b6 obj . timeStampDigest class \u2018str\u2019 default: \u201csha256\u201d \u00b6 obj . timeStampServerUrl class \u2018str\u2019 default: \u201c http://timestamp.digicert.com \u201c \u00b6 obj . otherSignToolArgs class \u2018str\u2019 default: \u201c<empty string>\u201c \u00b6 obj . isDebugMode class \u2018bool\u2019 default: True \u00b6 CodeSignConfig . DEFAULT_DIGEST class \u2018str\u2019 default: \u201csha256\u201d \u00b6 CodeSignConfig . DEFAULT_TIMESTAMP_SERVER class \u2018str\u2019 default: \u201c http://timestamp.digicert.com \u201c \u00b6 SelfSignedCertConfig class \u00b6 Magic Methods: __init__ Instance Methods: Instance Attributes: commonName endDate destDirPath caCertPath privateKeyPath makeCertPath otherArgs isDebugMode Class/Static Attributes: DEFAULT_END_DATE LIFETIME_SIGNING_EKU NO_MAX_CHILDREN SelfSignedCertConfig ( companyTradeName , destDirPath = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . commonName class \u2018NoneType\u2019 default: None \u00b6 obj . endDate class \u2018NoneType\u2019 default: None \u00b6 obj . destDirPath class \u2018NoneType\u2019 default: None \u00b6 obj . caCertPath class \u2018NoneType\u2019 default: None \u00b6 obj . privateKeyPath class \u2018NoneType\u2019 default: None \u00b6 obj . makeCertPath class \u2018NoneType\u2019 default: None \u00b6 obj . otherArgs class \u2018NoneType\u2019 default: None \u00b6 obj . isDebugMode class \u2018NoneType\u2019 default: None \u00b6 SelfSignedCertConfig . DEFAULT_END_DATE class \u2018str\u2019 default: None \u00b6 SelfSignedCertConfig . LIFETIME_SIGNING_EKU class \u2018str\u2019 default: None \u00b6 SelfSignedCertConfig . NO_MAX_CHILDREN class \u2018int\u2019 default: None \u00b6 TrustInstallerBuilderProcess class \u00b6 Base Classes: _DistBuildProcessBase, _BuildPackageProcess, PyToBinPackageProcess Instance Methods: onFinalize onInitialize onMakeSpec onOpyConfig onPyInstConfig run Class/Static Attributes: DIVIDER obj . onFinalize ( self ) \u00b6 VIRTUAL obj . onInitialize ( self ) \u00b6 VIRTUAL obj . onMakeSpec ( self , spec ) \u00b6 VIRTUAL obj . onOpyConfig ( self , cfg ) \u00b6 VIRTUAL obj . onPyInstConfig ( self , cfg ) \u00b6 VIRTUAL obj . run ( self ) \u00b6 TrustInstallerBuilderProcess . DIVIDER class \u2018str\u2019 default: \u201d------------------------------------\u201c \u00b6 Functions \u00b6 generateTrustCerts ( certConfig , keyPassword = None , isOverwrite = False ) \u00b6 Returns CA Cert Path, Key Path signExe ( exePath , codeSignConfig ) \u00b6 Returns exePath trustCertInstallerConfigFactory ( companyTradeName , caCertPath , keyFilePath , keyPassword = None , companyLegalName = None , version = ( 1 , 0 , 0 , 0 ), iconFilePath = None , isSilent = False , script = None ) \u00b6 Constants and Globals \u00b6 MAKECERT_PATH_ENV_VAR class \u2018str\u2019 default: \u201cMAKECERT_PATH\u201d \u00b6 PVK2PFX_PATH_ENV_VAR class \u2018str\u2019 default: \u201cPVK2PFX_PATH\u201d \u00b6 SIGNTOOL_PATH_ENV_VAR class \u2018str\u2019 default: \u201cSIGNTOOL_PATH\u201d \u00b6","title":"Code Signing"},{"location":"Code%20Signing.html#CodeSignConfig","text":"Magic Methods: __init__ Instance Methods: Instance Attributes: keyFilePath keyPassword signToolPath fileDigest timeStampDigest timeStampServerUrl otherSignToolArgs isDebugMode Class/Static Attributes: DEFAULT_DIGEST DEFAULT_TIMESTAMP_SERVER","title":"CodeSignConfig"},{"location":"Code%20Signing.html#SelfSignedCertConfig","text":"Magic Methods: __init__ Instance Methods: Instance Attributes: commonName endDate destDirPath caCertPath privateKeyPath makeCertPath otherArgs isDebugMode Class/Static Attributes: DEFAULT_END_DATE LIFETIME_SIGNING_EKU NO_MAX_CHILDREN","title":"SelfSignedCertConfig"},{"location":"Code%20Signing.html#TrustInstallerBuilderProcess","text":"Base Classes: _DistBuildProcessBase, _BuildPackageProcess, PyToBinPackageProcess Instance Methods: onFinalize onInitialize onMakeSpec onOpyConfig onPyInstConfig run Class/Static Attributes: DIVIDER","title":"TrustInstallerBuilderProcess"},{"location":"Code%20Signing.html#Functions","text":"","title":"Functions"},{"location":"Code%20Signing.html#Constants-and-Globals","text":"","title":"Constants and Globals"},{"location":"Config%20Factory.html","text":"ConfigFactory class \u00b6 It is typical for a build script to start by creating a high-level ConfigFactory object and set its attributes. The primary functions within this library rely upon a collection of \u201cconfiguration\u201d objects which act as \u201csmart parameter sets\u201d. Those parameters are used to drive various processes. Many of these config classes have overlapping attributes. Scripts which employ a collection of those low levels objects in the raw tend to include a lot of tedious and redundant assignment operations. With this in mind, the ConfigFactory class was created, to radically simplify many scripts. See Configuration Classes for more information on the types of objects generated by this factory class. Note that this class is NOT intended to have a one-to-one correspondence for every attribute within all of the configuration objects it can generate. If that were provided, this class would become an overwhelmingly bloated monster! Only the more commonly needed (and/or shared) attributes are provided on this level. You must manipulate those config objects generated by the factory directly if you need to access their more extended features. Typically, you will want to access those objects from a \u201ccallback\u201d function within a derived \u201cProcess\u201d class implementation. Magic Methods: __init__ Instance Methods: exeVersionInfo iExpressConfig opyConfig pyInstallerConfig qtIfwConfig qtIfwConfigXml qtIfwControlScript qtIfwExeWrapper qtIfwPackage qtIfwPackageScript qtIfwPackageXml Instance Attributes: cfgId productName description companyTradeName companyLegalName version isGui binaryName sourceDir iconFilePath entryPointPy specFilePath isOneFile entryPointScript distResources isObfuscating opyBundleLibs opyPatches isSilentSetup setupName ifwDefDirPath ifwPackages isLimitedMaintenance replaceTarget ifwWizardStyle ifwLogoFilePath ifwBannerFilePath licensePath ifwUiPages ifwWidgets ifwCntrlScript ifwCntrlScriptText ifwCntrlScriptPath ifwCntrlScriptName ifwPkgId ifwPkgName ifwPkgNamePrefix ifwPkgIsDefault ifwPkgIsRequired ifwPkgIsHidden ifwPkgScript ifwPkgScriptText ifwPkgScriptPath ifwPkgScriptName pkgType pkgSubDirName pkgSrcDirPath pkgSrcExePath pkgCodeSignTargets pkgExeWrapper pkgExternalDependencies pkgConfigs startOnBoot codeSignConfig qtCppConfig Class/Static Methods: copy ConfigFactory ( cfgId = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . exeVersionInfo ( self , ifwConfig = None ) \u00b6 obj . iExpressConfig ( self ) \u00b6 obj . opyConfig ( self ) \u00b6 obj . pyInstallerConfig ( self ) \u00b6 obj . qtIfwConfig ( self , packages = None ) \u00b6 obj . qtIfwConfigXml ( self ) \u00b6 obj . qtIfwControlScript ( self , configXml ) \u00b6 obj . qtIfwExeWrapper ( self , wrapperScript = None , workingDir = None , isElevated = False , envVars = None , args = None , isExe = False ) \u00b6 obj . qtIfwPackage ( self , pyInstConfig = None , iExpressConfig = None , isTempSrc = False ) \u00b6 obj . qtIfwPackageScript ( self , pyInstConfig = None ) \u00b6 obj . qtIfwPackageXml ( self ) \u00b6 obj . cfgId class \u2018NoneType\u2019 default: None \u00b6 Useful to distinguish between multiple ConfigFactory objects, as are often employed by a RobustInstallerProcess . obj . productName class \u2018NoneType\u2019 default: None \u00b6 The name for the product on the whole, or a sub component within it (based upon the context of how the factory object is used). Such will appear as \u201cbrandings\u201d upon a Stand Alone Executable and/or as labels/details within Installer menus. obj . description class \u2018NoneType\u2019 default: None \u00b6 The description for the product on the whole, or a sub component within it (based upon the context of how the factory object is used). Such will appear as \u201cbrandings\u201d upon a Stand Alone Executable and/or as labels/details within Installer menus. obj . companyTradeName class \u2018NoneType\u2019 default: None \u00b6 Akin to productName and description attributes. Note the companyTradeName will be used in standard labels, directory names, shortcuts, etc. produced by the process employing the ConfigFactory. In contrast, companyLegalName will appear within copyrights, EULAs, and the like where an \u201cofficial\u201d / legal name is called for. obj . companyLegalName class \u2018NoneType\u2019 default: None \u00b6 Akin to productName and description attributes. Note the companyTradeName will be used in standard labels, directory names, shortcuts, etc. produced by the process employing the ConfigFactory. In contrast, companyLegalName will appear within copyrights, EULAs, and the like where an \u201cofficial\u201d / legal name is called for. obj . version class \u2018tuple\u2019 default: (0, 0, 0, 0) \u00b6 Akin to productName and description attributes, this can be applied to either a Stand Alone Executable or an Installer based on the context of what uses the config factory. A version should be defined as a 4 part tuple of unsigned integers, in the form: ( MAJOR, MINOR, PATCH, BUILD ) Alternatively, a string representation may be supplied. See versionTuple, versionStr . Note that each part maybe any number of digits long. i.e. this is a perfectly valid version stamp: 2.11.6.139 . That example would be denoted in tuple form as: (2,11,6,139) obj . isGui class \u2018bool\u2019 default: False \u00b6 This is attribute used for a variety of purposes, which would be difficult to list here. Perhaps most notably, it is applied directly to the production of Stand Alone Executables . obj . binaryName class \u2018NoneType\u2019 default: None \u00b6 This is attribute used for a variety of purposes, which would be difficult to list here. Perhaps most notably, it is applied directly to the production of Stand Alone Executables . obj . sourceDir class \u2018NoneType\u2019 default: None \u00b6 This attribute is used to resolve relative paths to absolute paths in various contexts. When omitted, such paths are normally resolved relative to the directory containing the build script (NOT the current working directory!). obj . iconFilePath class \u2018NoneType\u2019 default: None \u00b6 Based upon context, this attribute is used to embedded (or bundle) an icon for a Stand Alone Executable or an Installer . As demoed in the Hello World Example , on Windows you must use a \u201c.ico\u201d file, on macOS a \u201c.icns\u201d, or on Linux a \u201c.png\u201d. You do NOT have to specify the extension, however, when setting this attribute. Such will be automatically determined per the platform at runtime. obj . entryPointPy class \u2018NoneType\u2019 default: None \u00b6 This attribute is most notably used when producing a Stand Alone Executable . In that context, it points PyInstaller to the starting point for the source from which to build a binary. This is also used during an Executable Obfuscation process. The entry point module name is not obfuscated (though its contents are). obj . specFilePath class \u2018NoneType\u2019 default: None \u00b6 This attribute is a relatively sophisticated component used for producing a given Stand Alone Executable . Most users of this library will never need to use this, though some may wish to if they are migrating from a legacy build script which employed a PyInstaller \u201cspec file\u201d they maintained. This attribute is a means to specify a relative file path to an existing \u201cspec\u201d file. Note that distbuilder provides a PyInstSpec class which allows for programmatic generation and manipulation of such files and configurations. Also, many of the process classes which employ a config factory provide an onMakeSpec( spec ) function. And, if writing your own low level equivalents of the process class operations, the library provides an makePyInstSpec function. obj . isOneFile class \u2018bool\u2019 default: True \u00b6 This switch controls a notable PyInstaller feature, i.e. bundling dependencies into a single (compressed) exe when creating a Stand Alone Executable vs leaving the dependencies outside of the exe. Unlike PyInstaller, this library wrapper defaults to employing the single file feature. That produces a more \u201cclean\u201d, streamlined, product which appears (on the surface) nearly identical across build environments - including cross platform. But, this comes at the expense of slowing down the launching of an executable. We recommend using the one file option for \u201csmall\u201d programs, or ones which will not likely be opened very often. Set this to False , however, to boost a program\u2019s performance as far as load time is concerned. obj . entryPointScript class \u2018NoneType\u2019 default: None \u00b6 This attribute is used when producing a Stand Alone Executable via an implementation of IExpress . Using this mechanism, you may convert a program written in a native Windows script (currently supporting Batch, PowerShell, VBScript, and JScript), into a binary executable. For more information on IExpress , see: https://en.wikipedia.org/wiki/IExpress https://docs.microsoft.com/en-us/internet-explorer/ie11-ieak/iexpress-wizard-for-win-server https://ss64.com/nt/iexpress.html http://www.mdgx.com/INF_web/ Note this argument may be simple file path, pointing to source script, or an object of type ExecutableScript . When using an ExecutableScript , a \u201cscript header\u201d will automatically be injected. This header modifies the context so that the implied working directory will be where the exe\u2019s is launched from. Without this code, the script will run from a (pseudo random) temporary location. This is a critical detail when resources are bundled with the program. Additionally the header provides the following global variables (which are named identically across the supported scripting languages): PID , PPID , EXE_PATH , THIS_DIR , LIB_DIR , RES_DIR obj . distResources class \u2018list\u2019 default: [] \u00b6 The distResources attribute is an optional list of external resources to bundle into the distribution package. You may use a simple list of strings containing file/directory names or paths relative to the build script directory. Else, you may provide a list of two element tuples, with a specific source and destination. In addition, source paths may be specified with globing wildcards if desired. They may even include environmental variables or path symbols. See distResources within pyScriptToExe for more details on this. Notably, this attribute is used when generating a PyInstallerConfig object when invoking the pyInstallerConfig() function for this class, and then ultimately invoking the low level pyScriptToExe operation with that. Note this may be done for you via various high level process classes. This attribute is also used for producing a QtIfwPackage object when invoking the qtIfwPackage() function for this class. This too may be done for you via various high level process classes. obj . isObfuscating class \u2018bool\u2019 default: False \u00b6 The isObfuscating switch toggles whether code obfuscation is employed by a process using the config factory (based upon context). obj . opyBundleLibs class \u2018NoneType\u2019 default: None \u00b6 The opyBundleLibs and opyPatches are details used for generating an OpyConfig object when invoking the opyConfig() function for this class. For more information, refer to the following: - Executable Obfuscation - Obfuscation Features - Hello World Tk Example - Opy for Distribution Builder obj . opyPatches class \u2018NoneType\u2019 default: None \u00b6 The opyBundleLibs and opyPatches are details used for generating an OpyConfig object when invoking the opyConfig() function for this class. obj . isSilentSetup class \u2018bool\u2019 default: False \u00b6 When isSilentSetup is enabled, the QtIFW installer produced will not display a GUI or provide any interactive prompts for the user. All options are dictated by command line arguments. While this may certainly be desirable on any platform, it is necessary to create an installer for a target OS with no GUI (e.g. many Linux distros). For more information refer to: buildInstaller Silent Installers Hello Silent Example obj . setupName class \u2018str\u2019 default: \u201csetup.exe\u201d \u00b6 This is the file name given to a QtIFW installer when the config factory is used in a context to produce one. This attribute is specifically applied when generating a QtIfwConfig object upon invoking the qtIfwConfig() function for this class. obj . ifwDefDirPath class \u2018NoneType\u2019 default: None \u00b6 When producing a QtIFW installer this attribute may optionally be used to specify an external, hard coded definition for the installer. This is useful when either integrating the distbuilder library with an existing QtIFW installer, or when a developer would prefer to use the traditional QtIFW approach (perhaps due to extensive customizations). Note: This hard coded definition may include target installation content, and it may be used as a partial definition or hybrid with distbuilder manipulations and additions applied to it. This attribute is specifically applied when generating a QtIfwConfig object upon invoking the qtIfwConfig() function for this class. obj . ifwPackages class \u2018NoneType\u2019 default: None \u00b6 When producing a QtIFW installer, this attribute maybe used to list of \u201cQt IFW Packages\u201d. Items in this list may be dynamic QtIfwPackage objects, or be simple strings defining relative paths to QtIFW packages which are defined as external resources, in the traditional (hard coded, content containing) IFW manner. When building Python only derived installers, this attribute will be set automatically by a process class, and NOT have to be manually defined or manipulated unless there is a need to merge or modify packages pro grammatically. This attribute is specifically applied when upon invoking the qtIfwPackage() function for this class. For more information refer to: RobustInstallerProcess QtIfwPackage list manipulation obj . isLimitedMaintenance class \u2018bool\u2019 default: True \u00b6 When producing a QtIFW installer, when this attribute is set to True (the default) the \u201cmaintenance tool\u201d included with the distribution will not display an introduction page with the options to add, remove, or update components. It will only allow for uninstallation. The extended options are only naturally functional within QtIFW in the context of an online installer, which is not the default product of this library, and thus the selection of these radio buttons only produce errors. Further, having this limitation imposed simplifies both the end user workflow and the developer\u2019s coding / testing tasks. When building an online installer, you may wish to enable the extended features, by disabling this switch. obj . replaceTarget class \u2018bool\u2019 default: False \u00b6 When producing a QtIFW installer, switch this attribute to True if you wish for the installer to automatically replace a prior installation. On Windows, this will reference the applications registered in the OS, and run the uninstallation for the prior install via that mechanism. On other platforms, this uses the QtIFW Maintenance Tool directly to \u201csilently\u201d uninstall a prior install found at the target location. obj . ifwWizardStyle class \u2018NoneType\u2019 default: None \u00b6 QtIFW installer predefined visual style. QtIfwConfigXml.DEFAULT_WIZARD_STYLE per platform QtIfwConfigXml.WizardStyle.AERO Windows Default QtIfwConfigXml.WizardStyle.MAC MacOS Default QtIfwConfigXml.WizardStyle.MODERN Linux Default QtIfwConfigXml.WizardStyle.CLASSIC Simliar to MODERN obj . ifwLogoFilePath class \u2018NoneType\u2019 default: None \u00b6 Relative or absolute path to QtIFW installer image resources. These should .png files (on any platform). Transparency is supported. Note: this is only applied in MODERN or CLASSIC style installers. obj . ifwBannerFilePath class \u2018NoneType\u2019 default: None \u00b6 Relative or absolute path to QtIFW installer image resources. These should .png files (on any platform). Transparency is supported. Note: this is only applied in MODERN style installers. obj . licensePath class \u2018NoneType\u2019 default: None \u00b6 Relative or absolute path to a license file to be included in an installer, which the end user will be required to agree to. obj . ifwUiPages class \u2018NoneType\u2019 default: None \u00b6 Use this to specify a list of QtIfwUiPage objects. With that, you may fully customize the installer\u2019s UI using the Qt Designer WYSIWYG tool! Installer Scripting , or the higher level script abstraction classes QtIfwControlScript and QtIfwPackageScript can be used to provide dynamic features for the page. obj . ifwWidgets class \u2018NoneType\u2019 default: None \u00b6 obj . ifwCntrlScript class \u2018NoneType\u2019 default: None \u00b6 QtIFW installers may have a \u201cControl Script\u201d and/or a collection of \u201cPackage Scripts\u201d. The \u201cControl Script\u201d is intended to dictate how the installer interface behaves, and other high level logic pertaining to the installer itself. In contrast, \u201cPackage Scripts\u201d are intended for applying custom logic to manipulate a target environment when installing a given package. These \u201cControl Script\u201d attributes are specifically applied when invoking the qtIfwControlScript() function for this class. The attributes ifwCntrlScript , ifwCntrlScriptText , ifwCntrlScriptPath are mutually exclusive. Only one will be applied (the others such be set to None ), with the priority being in that order. The ifwCntrlScript attribute is a QtIfwControlScript object. The ifwCntrlScriptText attribute is a means to supply the script as a raw string. The ifwCntrlScriptPath is a file path (relative to the build script) to an externally defined script. ifwCntrlScriptName provides a means to define the name of the file generated, in case there is need or desire to override the default. obj . ifwCntrlScriptText class \u2018NoneType\u2019 default: None \u00b6 obj . ifwCntrlScriptPath class \u2018NoneType\u2019 default: None \u00b6 obj . ifwCntrlScriptName class \u2018str\u2019 default: \u201cinstallscript.qs\u201d \u00b6 obj . ifwPkgId class \u2018NoneType\u2019 default: None \u00b6 ifwPkgId is employed for distbuilder operations where multiple packages are involved. For more information refer to: QtIfwPackage list manipulation obj . ifwPkgName class \u2018NoneType\u2019 default: None \u00b6 This attribute is utilized to differentiate QtIfwPackage objects, and the packages which are produced for an installer. RobustInstallerProcess . ifwPkgName and ifwPkgNamePrefix are provided to override the name used by the QtInstaller for deployment on a target environment. Normally, you may allow distbuilder to set the name for you automatically. obj . ifwPkgNamePrefix class \u2018str\u2019 default: \u201ccom\u201d \u00b6 This attribute is utilized to differentiate QtIfwPackage objects, and the packages which are produced for an installer. RobustInstallerProcess . ifwPkgName and ifwPkgNamePrefix are provided to override the name used by the QtInstaller for deployment on a target environment. Normally, you may allow distbuilder to set the name for you automatically. obj . ifwPkgIsDefault class \u2018bool\u2019 default: True \u00b6 Simple option for controlling how the package (i.e. component) will be selected by the end user of the installer. ifwPkgIsDefault will automatically select (or not select) the component by default. obj . ifwPkgIsRequired class \u2018bool\u2019 default: False \u00b6 Simple option for controlling how the package (i.e. component) will be selected by the end user of the installer. ifwPkgIsRequired dictates if the user can opt out of the component. obj . ifwPkgIsHidden class \u2018bool\u2019 default: False \u00b6 Simple option for controlling how the package (i.e. component) will be selected by the end user of the installer. ifwPkgIsHidden is similar to ifwPkgIsDefault and ifwPkgIsRequired , but insulates the user from even seeing the component as separate entity when enabled. obj . ifwPkgScript class \u2018NoneType\u2019 default: None \u00b6 QtIFW installers may have a \u201cControl Script\u201d and/or a collection of \u201cPackage Scripts\u201d. The \u201cControl Script\u201d is intended to dictate how the installer interface behaves, and other high level logic pertaining to the installer itself. In contrast, \u201cPackage Scripts\u201d are intended for applying custom logic to manipulate a target environment when installing a given package. These \u201cPackage Script\u201d attributes are specifically applied when invoking the qtIfwPackageScript() function for this class. The attributes ifwPkgScript , ifwPkgScriptText , ifwPkgScriptPath are mutually exclusive. Only one will be applied (the others such be set to None ), with the priority being in that order. The ifwPkgScript attribute is a QtIfwPackageScript object. The ifwPkgScriptText attribute is a means to supply the script as a raw string. The ifwPkgScriptPath is a file path (relative to the build script) to an externally defined script. ifwPkgScriptName provides a means to define the name of the file generated, in case there is need or desire to override the default. obj . ifwPkgScriptText class \u2018NoneType\u2019 default: None \u00b6 obj . ifwPkgScriptPath class \u2018NoneType\u2019 default: None \u00b6 obj . ifwPkgScriptName class \u2018str\u2019 default: \u201cinstallscript.qs\u201d \u00b6 obj . pkgType class \u2018NoneType\u2019 default: None \u00b6 This specifies the type ( QtIfwPackage.Type ) of package being built. The options for this include: QtIfwPackage.Type.RAW QtIfwPackage.Type.DATA QtIfwPackage.Type.RESOURCE QtIfwPackage.Type.PY_INSTALLER QtIfwPackage.Type.IEXPRESS QtIfwPackage.Type.QT_CPP If this is omitted, and a binaryName attribute is specified, type PY_INSTALLER is assumed. If this is omitted, but no binaryName is specified, the DATA type is assumed. The RESOURCE type indicates that the package does not contain any \u201cdirectly installed content\u201d (in the traditional sense at least). This is to be used in situations where you want to simply bundle custom installation operations / scripts as a \u201ccomponent\u201d. Note, however, that installer resources may be attached to such operations, and which are not \u201cdirectly installed content\u201d. A notable use case where you would include a resource, but no content files in a package, would be to \u201cnest\u201d another installer inside of the outer one. The nested installer would be a resource, invoked by a custom operation. See: QtIfwExternalResource QtIfwExternalOp obj . pkgSubDirName class \u2018NoneType\u2019 default: None \u00b6 If a pkgSubDirName is specified, this places the package inside of sub directory, rather than having the contents there of installed directly to the top level directory of the target. By default, this attribute is None , which is ideal for single package products. When multiple packages are present, however, the content of each will be merged into one directory during installation (if the end user selects more than one package). In the event \u201ccollisions\u201d could occur (at installation or run time) due to this, the suggested resolution is to employ this option, thereby encapsulating the package(s). obj . pkgSrcDirPath class \u2018NoneType\u2019 default: None \u00b6 When building installers that have external resources which are not part of automatically generated products/packages, these attributes may be used to define the paths to that package\u2019s content. When the pkgSrcDirPath is not supplied, this is path defined by either a PyInstallerConfig object definition, or assumed to simply be a sub directory adjacent to the build script with the same name as the binaryName attribute. The attribute pkgSrcExePath must only be supplied when the package contains a \u201cprimary\u201d executable which was not produced by a process with the library (i.e. it was complied previously by some other build system). Note, that if binaryName is also defined, the pkgSrcExePath file will be renamed to that name upon building the package. See: RobustInstallerProcess . obj . pkgSrcExePath class \u2018NoneType\u2019 default: None \u00b6 When building installers that have external resources which are not part of automatically generated products/packages, these attributes may be used to define the paths to that package\u2019s content. When the pkgSrcDirPath is not supplied, this is path defined by either a PyInstallerConfig object definition, or assumed to simply be a sub directory adjacent to the build script with the same name as the binaryName attribute. The attribute pkgSrcExePath must only be supplied when the package contains a \u201cprimary\u201d executable which was not produced by a process with the library (i.e. it was complied previously by some other build system). Note, that if binaryName is also defined, the pkgSrcExePath file will be renamed to that name upon building the package. See: RobustInstallerProcess . obj . pkgCodeSignTargets class \u2018NoneType\u2019 default: None \u00b6 obj . pkgExeWrapper class \u2018NoneType\u2019 default: None \u00b6 A QtIfwExeWrapper object used to \u201cwrap\u201d the primary executable in a QtIfwPackage being built using the factory provided configurations. Such a wrapper can super impose environmental conditions on the context within which the binary is run. Notably, this may include an ExecutableScript for maximum flexibility. Follow the links to learn to more. obj . pkgExternalDependencies class \u2018NoneType\u2019 default: None \u00b6 MAC / LINUX Only External packages to be installed. This takes place prior to any other installer operations, in case those operations (rather the program being installed) are dependent upon such. Provide a list of either simple strings and/or nested lists of strings. When nesting lists, such represents alternate names to try based upon what is available within a given package manager on the target. For example, the package \u201cxvfb\u201d maybe specified as [\"xvfb\",\"Xvfb\"] . That handles the fact the \u201cX\u201d is capitalized within some contexts (e.g. within YUM on RHEL\u2026) but is lower case in others. obj . pkgConfigs class \u2018NoneType\u2019 default: None \u00b6 obj . startOnBoot class \u2018bool\u2019 default: False \u00b6 Enable startOnBoot to have the installer register the \u201cprimary\u201d exe within a package as a program to launch upon booting the system. By default, this is set to False , setting it to either True or to CURRENT_USER will have the same effect. Assign it to ALL_USERS to have this applied for all system users. In Windows, this will lead to an auto implementation of a QtIfwExeWrapper , which employs the special isExe feature, producing a \u201cwrapper/proxy/launcher\u201d exe adjacent to the actual one. That launcher is what will actually be registered in the OS. obj . codeSignConfig class \u2018NoneType\u2019 default: None \u00b6 obj . qtCppConfig class \u2018NoneType\u2019 default: None \u00b6 A QtCppConfig object. Used to define how to package programs developed within the Qt C++ libraries / framework. See the Qt C++ Integration document for more information. ConfigFactory . copy ( instance ) \u00b6","title":"Config Factory"},{"location":"Config%20Factory.html#ConfigFactory","text":"It is typical for a build script to start by creating a high-level ConfigFactory object and set its attributes. The primary functions within this library rely upon a collection of \u201cconfiguration\u201d objects which act as \u201csmart parameter sets\u201d. Those parameters are used to drive various processes. Many of these config classes have overlapping attributes. Scripts which employ a collection of those low levels objects in the raw tend to include a lot of tedious and redundant assignment operations. With this in mind, the ConfigFactory class was created, to radically simplify many scripts. See Configuration Classes for more information on the types of objects generated by this factory class. Note that this class is NOT intended to have a one-to-one correspondence for every attribute within all of the configuration objects it can generate. If that were provided, this class would become an overwhelmingly bloated monster! Only the more commonly needed (and/or shared) attributes are provided on this level. You must manipulate those config objects generated by the factory directly if you need to access their more extended features. Typically, you will want to access those objects from a \u201ccallback\u201d function within a derived \u201cProcess\u201d class implementation. Magic Methods: __init__ Instance Methods: exeVersionInfo iExpressConfig opyConfig pyInstallerConfig qtIfwConfig qtIfwConfigXml qtIfwControlScript qtIfwExeWrapper qtIfwPackage qtIfwPackageScript qtIfwPackageXml Instance Attributes: cfgId productName description companyTradeName companyLegalName version isGui binaryName sourceDir iconFilePath entryPointPy specFilePath isOneFile entryPointScript distResources isObfuscating opyBundleLibs opyPatches isSilentSetup setupName ifwDefDirPath ifwPackages isLimitedMaintenance replaceTarget ifwWizardStyle ifwLogoFilePath ifwBannerFilePath licensePath ifwUiPages ifwWidgets ifwCntrlScript ifwCntrlScriptText ifwCntrlScriptPath ifwCntrlScriptName ifwPkgId ifwPkgName ifwPkgNamePrefix ifwPkgIsDefault ifwPkgIsRequired ifwPkgIsHidden ifwPkgScript ifwPkgScriptText ifwPkgScriptPath ifwPkgScriptName pkgType pkgSubDirName pkgSrcDirPath pkgSrcExePath pkgCodeSignTargets pkgExeWrapper pkgExternalDependencies pkgConfigs startOnBoot codeSignConfig qtCppConfig Class/Static Methods: copy","title":"ConfigFactory"},{"location":"ConfigClasses.html","text":"Configuration Classes \u00b6 The following classes are used to create objects which are employed as arguments to various functions within the library. Many of these can be generated for you using the Configuration Factory . PyInstallerConfig \u00b6 Objects of this type define optional details for building binaries from .py scripts using the PyInstaller utility invoked via the pyScriptToExe function (which maybe employed by higher level Process Classes under the hood). Note that if a PyInstSpec attribute is provided for one of these objects, the build settings contained within that will override any which conflict with those specified via the attributes set directly on the PyInstallerConfig object. PyInstSpec objects may be created by supplying a traditional (perhaps legacy) spec file definition, or you may wish to generate one with distbuilder via the makePyInstSpec() function. In either case, you may also opt to dynamically manipulate the spec via the implementation of that class. Constructor: PyInstallerConfig() Attributes & default values: pyInstallerPath = <python scripts directory>/pyinstaller name = None entryPointPy = None pyInstSpec = None isGui = False iconFilePath = None versionInfo = None versionFilePath = None isAutoElevated = False isOneFile = True (note this differs from PyInstaller default) importPaths = [] hiddenImports = [] dataFilePaths = [] binaryFilePaths = [] distResources = [] distDirs = [] codeSignConfig = [] codeSignTargets = [] otherPyInstArgs = \"\" (open ended argument string) distDirPath = None _pngIconResPath = None isSpecFileRemoved = False PyInstHook \u00b6 Objects of this type are used for PyInstaller \u201chook\u201d script creation, and programmatic manipulation. Such hooks are executed during a PyInstaller analyis process when an import is encountered with a matching hook name. The purpose of a hook is to help PyInstaller find and collect resources it would otherwise not know to include in the bundle. Hooks are commonly installed by third party libraries for use across your Python environment whenever you employ PyInstaller. It is also possible to use custom hooks during a given a build process via the PyInstaller option --additional-hooks-dir (though that parameter does not override a hook which is registered for the system on the whole\u2026) If you are working in a context in which you can manipulate the build environment freely, the use of hooks is arguably a better means by which to gather resources for a distribition rather than by adding them through PyInstallerConfig attributes hiddenImports , dataFilePaths , binaryFilePaths , etc. Use cases for this class include: adding hooks to patch a build process, replacing bad hooks installed on your system, or to simply revisw them for some additional custom need. For more on hooks, see: Understanding PyInstaller Hooks Constructor: PyInstHook( name, script=None, isContribHook=True, isRunTimeHook=False ) Attributes & default values: name = *required script = None isContribHook = True isRunTimeHook = False hooksDirPath = None Object Methods: fileName() read() write() remove() debug() toLines() fromLines( lines ) injectLine( injection, lineNo ) Details: The name attribute should simply specify the name of import which invokes the script . The name should not contain the literal \u201chook-\u201d file name prefix, or a .py file extension . isContribHook : Only respected for PyInstaller v4 or later, when it became available, and the new standard practice for hook distribution. hooksDirPath may be override, as needed. If left as the default None , the path will be automatically resolved. PyInstSpec \u00b6 Objects of this type are used for PyInstaller spec file parsing, and programmatic manipulation. This class provides an easy mechanism for applying known PyInstaller patches, as well as convenient mechanisms for applying custom revisions for similar purposes. Constructor: PyInstSpec( filePath=None, pyInstConfig=None, content=None ) Attributes & default values: filePath = None pyInstConfig = None content = None warningBehavior = None <options: PyInstSpec.WARN_IGNORE, PyInstSpec.WARN_ONCE, PyInstSpec.WARN_ERROR> isUnBufferedStdIo = False isModInitDebug = False isInjected = False Static Method: cfgToPath( pyInstConfig ) Object Methods: path() read() write() debug() toLines() fromLines( lines ) injectLine( injection, lineNo ) injectDuplicateDataPatch() _parseAssigments() IExpressConfig \u00b6 WINDOWS ONLY Objects of this type define optional details for building binaries from native Windows scripts (currently supporting Batch, PowerShell, VBScript, and JScript), using the IExpress utility built into the OS, as invoked via the batchScriptToExe , powerShellScriptToExe , vbScriptToExe , or jScriptToExe functions (which maybe employed by higher level Process Classes under the hood). Constructor: IExpressConfig() Attributes & default values: name = None sourceDir = None entryPointScript = None scriptHeader = None isScriptDebug = False versionInfo = None iconFilePath = None isAutoElevated = False scriptImports = [] #Embedded embeddedResources = [] #Embedded distResources = [] #External distDirs = [] #External (mkDir) codeSignConfig = [] codeSignTargets = [] # result destDirPath = None isScriptDebug : TODO: Fill-in - Note the extended VbScript functionality CodeSignConfig \u00b6 This class defines the details used for code signing executables. TODO: Make Cross Platform Constructor: CodeSignConfig( keyFilePath=None, keyPassword=None ) Attributes & default values: keyFilePath = None keyPassword = None signToolPath = None <None==auto resolved> fileDigest = CodeSignConfig.DEFAULT_DIGEST timeStampDigest = CodeSignConfig.DEFAULT_DIGEST timeStampServerUrl = CodeSignConfig.DEFAULT_TIMESTAMP_SERVER otherSignToolArgs = \"\" isDebugMode = True Class Constants: DEFAULT_DIGEST = \"sha256\" DEFAULT_TIMESTAMP_SERVER = \"http://timestamp.digicert.com\" signToolPath : Only applicable on WINDOWS. If None , this defaults to the path the this library will auto install the tool as needed. This attribute may also be set indirectly by running the script where an environmental variable call SIGNTOOL_PATH (defined the in constant SIGNTOOL_PATH_ENV_VAR ) has been defined. SelfSignedCertConfig \u00b6 This class defines the details used for generating self-signed code signing certificates and keys. TODO: Make Cross Platform Constructor: CodeSignConfig( companyTradeName, destDirPath=None ) Attributes & default values: commonName = companyTradeName endDate = SelfSignedCertConfig . DEFAULT_END_DATE destDirPath = destDirPath or THIS_DIR caCertPath = < auto , based on destDirPath > privateKeyPath = < auto , based on destDirPath > makeCertPath = None < None , auto resolved > _maxCertChildren = SelfSignedCertConfig . NO_MAX_CHILDREN _enhancedKeyUsage = SelfSignedCertConfig . LIFETIME_SIGNING_EKU otherArgs = \"\" isDebugMode = True Object Methods: _forceMakeCertMethod() Class Constants: DEFAULT_END_DATE = '12/31/2050' NO_MAX_CHILDREN = 0 LIFETIME_SIGNING_EKU = '1.3.6.1.5.5.7.3.3,1.3.6.1.4.1.311.10.3.13' makeCertPath : Only applicable on WINDOWS. Normally used on legacy versions of Windows (v8.0 an earlier), where new standard means for creating such files - i.e. the PowerShell function New-SelfSignedCertificate is not available. If None , this defaults to the path where this library will auto install the tool as needed. This attribute may also be set indirectly by running the script where an environmental variable call MAKECERT_PATH (defined the in constant MAKECERT_PATH_ENV_VAR ) has been defined. Pvk2PfxConfig \u00b6 Used in legacy Windows mechanisms for creating code signing certificates. Specified defines the details for converting .pvk files (old style private keys) generated by the now defunct makecert utility, into .pfx files. Constructor: Pvk2PfxConfig( caCertPath, privateKeyPath, keyPassword=None, pfxFilePath=None ) Attributes & default values: caCertPath = <required> privateKeyPath = <required> keyPassword = None keyFilePath = <result - pfxFilePath or auto based on privateKeyPath> pvk2PfxPath = None <None, auto resolved> otherArgs = \"\" isDebugMode = True pvk2PfxPath : If None , this defaults to the path the this library will auto install the tool as needed. This attribute may also be set indirectly by running the script where an environmental variable call PVK2PFX_PATH (defined the in constant PVK2PFX_PATH_ENV_VAR ) has been defined. WindowsExeVersionInfo \u00b6 Objects of this type define meta data branded into Windows executables. This is the object type intended for PyInstallerConfig.versionInfo attributes. Constructor: WindowsExeVersionInfo() Attributes & default values: major = 0 minor = 0 micro = 0 build = 0 companyName = \"\" productName = \"\" description = \"\" exeName = \"\" Static Methods: defaultPath() Object Methods: version( isCommaDelim=False ) copyright() internalName() fileName() write() debug() QtIfwConfig \u00b6 Objects of this type provide the highest level definition of a QtIFW installer configuration to use for building an installer via the buildInstaller function (which maybe employed by higher level Process Classes under the hood). Constructor: QtIfwConfig( installerDefDirPath=None, packages=None, configXml=None, controlScript=None, setupExeName=\"setup\" ) Attributes & default values: installerDefDirPath = None packages = None <list of QtIfwPackages OR directory paths> configXml = None controlScript = None setupExeName = \"setup\" <other IFW command line options> isDebugMode = True otherQtIfwArgs = \"\" Functions: addUiElements ( uiElements , isOverWrite = True ) addLicense ( licensePath , name = \" End User License Agreement \" ) QtIfwConfigXml \u00b6 Objects of this type define the contents of a QtIFW config.xml which will be dynamically generated when invoking the buildInstaller function. The config.xml file represents the highest level definition of a QtIFW installer, containing information such as the product name and version. Most of the attributes in this class correspond directly to the name of the tags added to the xml file. Attributes set to None values will not be written, otherwise they will be. Constructor: QtIfwConfigXml( name, version, publisher, iconFilePath=None, controlScriptName=None, primaryContentExe=None, isPrimaryExeGui=True, primaryExeWrapper=None, companyTradeName=None, wizardStyle=None, logoFilePath=None, bannerFilePath=None ) Attributes: primaryContentExe (used indirectly w/ isGui) companyTradeName (used indirectly) iconFilePath (used indirectly) logoFilePath (used indirectly) bannerFilePath (used indirectly) primaryExeWrapper Name Version Publisher <Windows / Mac> InstallerApplicationIcon (icon root name, i.e. omit extension) <Linux> InstallerWindowIcon (.png name, with extension) Title TitleColor (HTML color code, such as \"#88FF33\") ControlScript TargetDir StartMenuDir RunProgram RunProgramDescription WizardStyle WizardDefaultWidth WizardDefaultHeight Logo Banner ProductUrl runProgramArgList (used indirectly) otherElements (open ended dictionary of key/value pairs to inject) Functions: setPrimaryContentExe( ifwPackage ) setDefaultVersion() setDefaultTitle() setDefaultPaths() addCustomTags( root ) write() debug() toPrettyXml() exists() path() dirPath() Static Constants: DEFAULT_WIZARD_STYLE WizardStyle.AERO <Windows Default> WizardStyle.MAC <MacOS Default> WizardStyle.MODERN <Linux Default> WizardStyle.CLASSIC <Simliar to MODERN> QtIfwControlScript \u00b6 QtIfw installers may have a \u201cControl Script\u201d and/or a collection of \u201cPackage Scripts\u201d. The \u201cControl Script\u201d is intended to dictate how the installer interface behaves, and other high level logic pertaining to the installer itself. In contrast, \u201cPackage Scripts\u201d are intended for applying custom logic to manipulate a target environment when installing a given package. See QtIfwPackageScript for more info. The QtIfwControlScript class provides an abstraction layer for QtIfw script generation. QtIfw scripts are written in Qt Script (which is conceptually a spin off from JavaScript), with additional custom objects and methods for this context. Using this abstraction, you can achieve a great many custom behaviors without having to learn much about the language yourself. Refer to the details on Installer Scripting to learn more about the low level helpers provided by the library for this purpose. For maximum flexibility, rather than using the dynamic methods, you may directly define the entire script via a raw string, by setting the script attribute. Or, you may specify an external file as the source instead via script_path . In addition, you may always delegate scripts to a traditional QtIfw definition by using a higher level configuration QtIfwConfig to specify such. The way this class works, in summary, is that you may provide an optional script as a raw string, or a path to script you wish to load directly. If specified, those resources act as a base , from which you may continue to add on to. A QtIfw control script is \u201cdriven\u201d by the builtin framework. When a given \u201cevent\u201d occurs a \u201chandler\u201d function is invoked (if it has been defined). QtIfwControlScript object has a set of attributes related to each page and such event/handler pair in the framework. One is a boolean, controlling the \u201cvisibility\u201d of the page. Setting that to False skips over that wizard page entirely. Another boolean is provided, dictating whether to auto generate the event handler using a set of fixed, built-in logic provided by distbuilder to add a notable amount of additional features to your installers \u201cfor free\u201d. The final attribute in this pattern is the body of the event handler (normally auto generated), which allows for an atomic replacement of that code. When the write() function is invoked, the actual script file to be embedded in the installer is generated from the attributes. Prior to calling that, you may switch off the various auto generate options, and supply your own function definition from scratch. If you wish to use the bulk of the \u201cfree\u201d / standard add on logic, but then customize that the program flow should be to call _generate() first, which will define the function bodies using the auto generate options. Once that is done, you may disable select auto generates, and then directly add on to, or manipulate the event handling function bodies. A large number of abstract, static \u201chelper\u201d functions have been provided which you may use to build your logic. Otherwise, you may certainly just add Qt Script snippets directly in the raw. See Installer Scripting . The virtualArgs attribute is a dictionary, containing key/values which allows for hard coding Standard Installer Arguments into the installer, which are typically passed at runtime via the command line. Constructor: QtIfwControlScript( fileName=\"installscript.qs\", script=None, scriptPath=None, virtualArgs={} ) : Attributes & default values: isLimitedMaintenance = True virtualArgs = virtualArgs uiPages = [] widgets = [] controllerGlobals = None isAutoGlobals = True controllerConstructorBody = None controllerConstructorInjection = None isAutoControllerConstructor = True onPageChangeCallbackBody = None onPageChangeCallbackInjection = None isAutoPageChangeCallBack = True onFinishedClickedCallbackBody = None onFinishedClickedCallbackInjection = None isAutoFinishedClickedCallbackBody = True onPageInsertRequestCallbackBody = None isAutoPageInsertRequestCallBack = True onPageRemoveRequestCallbackBody = None isAutoPageRemoveRequestCallBack = True onPageVisibilityRequestCallbackBody = None isAutoPageVisibilityRequestCallBack = True onValueChangeCallbackBody = None onValueChangeCallbackInjection = None isAutoValueChangeCallBack = True isIntroductionPageVisible = True introductionPageCallbackBody = None introductionPageOnInstall = None introductionPageOnMaintain = None isAutoIntroductionPageCallback = True isTargetDirectoryPageVisible = True targetDirectoryPageCallbackBody = None isAutoTargetDirectoryPageCallback = True isComponentSelectionPageVisible = True componentSelectionPageCallbackBody = None componentSelectionPageInjection = None isAutoComponentSelectionPageCallback = True isLicenseAgreementPageVisible = True licenseAgreementPageCallbackBody = None isAutoLicenseAgreementPageCallback = True isStartMenuDirectoryPageVisible = True startMenuDirectoryPageCallbackBody = None isAutoStartMenuDirectoryPageCallback = True isReadyForInstallationPageVisible = True readyForInstallationPageCallbackBody = None readyForInstallationPageOnInstall = None readyForInstallationPageOnMaintain = None isAutoReadyForInstallationPageCallback = True isPerformInstallationPageVisible = True performInstallationPageCallbackBody = None isAutoPerformInstallationPageCallback = True isFinishedPageVisible = True finishedPageCallbackBody = None finishedPageOnInstall = None finishedPageOnMaintain = None isAutoFinishedPageCallback = True isRunProgVisible = True isRunProgEnabled = True isRunProgChecked = True Object Methods: registerAsyncFunc ( func ) < takes QtIfwAsyncFunc > registerStandardEventHandler ( signalName , slotName , slotBody ) registerAutoPilotEventHandler ( signalName , slotName , slotBody ) registerGuiEventHandler ( signalName , slotName , slotBody ) registerWidgetEventHandler ( pageId , controlName , signalName , slotName , slotBody ) _generate () write () debug () exists () path () dirPath () QtIfwPackage \u00b6 Objects of this type define the packages with an installer. A QtIfwConfig contains a list of these. Notably, these package objects define the source content to be included in the installer via srcDirPath or simply srcExePath attributes. They also contain QtIfwPackageXml and QtIfwPackageScript objects, for extended configuration details. Constructor: QtIfwPackage( pkgId=None, pkgType=None, name=None, subDirName=None, srcDirPath=None, srcExePath=None, resBasePath=None, isTempSrc=False, pkgXml=None, pkgScript=None, licenses={}, uiPages=[], widgets=[] ) Attributes: <internal id / type> pkgId = None pkgType = None <QtIFW definition> name = None pkgXml = None pkgScript = None uiPages = [] widgets = [] licenses = {} <in the form name:filePath> isLicenseFormatPreserved = False <source content> srcDirPath = None <package ENTIRE source directory> srcExePath = None resBasePath = None distResources = None isTempSrc = False <destination content> subDirName = None exeName = None exeWrapper = None <other configuration details> isGui = False codeSignTargets = None <list of relative paths within package> qtCppConfig = None Functions: dirPath() metaDirPath() contentTopDirPath() contentDirPath() Static Functions: topDirPath() QtIfwPackageXml \u00b6 Objects of this type define the a QtIFW package.xml file which will be dynamically generated when invoking the buildInstaller function. This file defines a component within the installer which maybe selected by the user to install. Most of the attributes in these objects correspond directly to the name of tags added to the xml. Attributes set to None values will not be written, otherwise they will be. Constructor: QtIfwPackageXml( pkgName, displayName, description, version, scriptName=None, isDefault=True, isRequired=False, isHidden=False, isCheckable=True ) Attributes & default values: pkgName = <required> SortingPriority = None DisplayName = <required> Description = <required> Version = <required> Script = None ReleaseDate = date.today() Default = True ForcedInstallation = False <isRequired> Virtual = False <isHidden> Checkable = True Dependencies = None AutoDependOn = None UserInterfaces = [] Licenses = [] Functions: addCustomTags( root ) write() debug() toPrettyXml() exists() path() dirPath() QtIfwPackageScript \u00b6 QtIFW installers may have a \u201cControl Script\u201d and/or a collection of \u201cPackage Scripts\u201d. The \u201cControl Script\u201d is intended to dictate how the installer interface behaves, and other high level logic pertaining to the installer itself. In contrast, \u201cPackage Scripts\u201d are intended for applying custom logic to manipulate a target environment when installing a given package. See QtIfwControlScript for more info. Objects of the type QtIfwPackageScript are used to dynamically generate a script used by a QtIFW package. Refer to the details on Installer Scripting to learn more about the low level helpers provided by the library for this purpose. For maximum flexibility, rather than using the dynamic methods, you may directly define the entire script via a raw string, by setting the script attribute. Or, you may specify an external file as the source instead via script_path . In addition, you may always delegate scripts to a traditional QtIFW definition by using a higher level configuration QtIfwConfig to specify such. This class works in an analogous manner to QtIfwControlScript . Please refer to the that documentation for an explanation of how use these script objects in general. Note that for this class QtIfwShortcut objects are used for the shortcuts attribute, QtIfwExternalOp objects are used for externalOps , and QtIfwKillOp objects are used for killOps . Constructor: QtIfwPackageScript( pkgName, pkgVersion, pkgSubDirName=None, shortcuts=[], bundledScripts=[], dynamicTexts={}, externalOps=[], installResources=[], uiPages=[], widgets=[], fileName=\"installscript.qs\", script=None, scriptPath=None ) Attributes & default values: pkgName = < required > pkgVersion = < required > pkgSubDirName = None fileName = \"installscript.qs\" script = None < or loaded via scriptPath > shortcuts = [] bundledScripts = [] dynamicTexts = {} fileName : content externalOps = [] installResources = [] killOps = [] preOpSupport = None customOperations = None < LINUX / MAC only > externalDependencies = [] areDependenciesPreserved = True uiPages = [] widgets = [] packageGlobals = None isAutoGlobals = True componentConstructorBody = None isAutoComponentConstructor = True componentLoadedCallbackBody = None isAutoComponentLoadedCallback = True componentCreateOperationsBody = None isAutoComponentCreateOperations = True componentCreateOperationsForArchiveBody = None isAutoComponentCreateOperationsForArchive = True < Linux Only > isAskPassProgRequired = False Methods addSimpleOperation( name, parms=[], isElevated=False, isAutoQuote=True ) addSimpleOperation : Appends a QScript snippet to be appended to the customOperations attribute. The available operations are documented on https://doc.qt.io/qtinstallerframework/operations.html . Note that these operations implicitly occur during installation, have implicit \u201cundo\u201d operations (where possible), and cannot be made to occur specifically during an install vs update vs uninstall. They are, however, cross platform and relatively painless to implement. For more flexibility, use QtIfwExternalOp objects. (The draw back to such is you will need to call upon / include utilities or add ExecutableScripts containing platform specific code. QtIfwShortcut \u00b6 These shortcut objects are use by QtIfwPackageScript objects, to create shortcuts on the installation target environments. Constructor: QtIfwShortcut( productName=QT_IFW_PRODUCT_NAME, command=None, args=[], exeDir=QT_IFW_TARGET_DIR, exeName=None, exeVersion=\"0.0.0.0\", isGui=True, pngIconResPath=None ) Attributes & default values: productName = \"@ProductName@\" < QtIfw Built - in Variable > command = None exeDir = \"@TargetDir@\" < QtIfw Built - in Variable > exeName = None args = None isGui = True < used in Mac / Linux > windowStyle = None < used in Windows > exeVersion = \"0.0.0.0\" < used in Linux > pngIconResPath = None < used in Linux > isAppShortcut = True isDesktopShortcut = False isAdjancentShortcut = False QtIfwExternalOp \u00b6 This class is used to represent and control the invocation of shell commands, external utilities, and embedded ExecutableScripts . It is employed by QtIfwPackageScript to add operations to the installation, and/or uninstallation, process of the package to which those operations are associated. This simple example (for *nix based systems), may serve well to clarify how this class is intended to be used: filePath = joinPathQtIfw ( QT_IFW_HOME_DIR , \"test.txt\" ) createFileOp = QtIfwExternalOp ( exePath = \"touch\" , args =[ filePath ] , uninstExePath = \"rm\" , uninstArgs =[ filePath ] ) pkg . pkgScript . externalOps = [ createFileOp ] This purpose of this class should not be confused with the Installer Scripting function execute( binPath, args ) . While that is also a means to invoke sub processes and shell commands from QtIWF, that is more generally used in a \u201cController scripting\u201d context for on demand, often conditional and/or dynamic needs. More to the point, QtIfwExternalOp objects are bound directly to packages and to install/uninstall events, where the QtScript execute function can be dropped into installation scripts anywhere, in an unrestricted manner. Note the intended design by Qt for creating sophisticated, cross platform, custom operations is to modify to the installer engine itself, writing in Qt C++, and recompile it yourself for a specific platform. See: https://doc.qt.io/qtinstallerframework/scripting.html#registering-custom-operations If you really want to do that, here\u2019s the source you\u2019ll require: https://github.com/qtproject/installer-framework It is the opinion of the distbuilder developers that this typically going to be an absurdly complicated and time consuming endeavor for most use cases. This \u201cexternal operation\u201d mechanism, while having draw backs is likely a good deal more practical! Constructor: QtIfwExternalOp( script=None, exePath=None, args=[], successRetCodes=[0], uninstScript=None, uninstExePath=None, uninstArgs=[], uninstRetCodes=[0], isElevated=False, workingDir=QT_IFW_TARGET_DIR, onErrorMessage=None, resourceScripts=[], uninstResourceScripts=[], externalRes=[] ) Attributes & default values: script = None exePath = None args = [] successRetCodes = [0] uninstScript = None uninstExePath = None uninstArgs = [] uninstRetCodes = [0] isElevated = False workingDir = QT_IFW_TARGET_DIR onErrorMessage = None resourceScripts = [] uninstResourceScripts = [] externalRes = [] Notes: QtIfw will execute these operations synchronously. By default, if the return code from the sub process is not 0, this is treated as an installation error. To expand the options for what is viewed as a \u201csuccess\u201d, or can at least be ignored, the attributes successRetCodes , and uninstRetCodes , allow specifying lists of codes for either the installation or uninstallation processes, respectively. The QtIfwPackageScript attribute externalOps is a list to be executed in order. Note that during uninstallation, that list is processed in reverse order . It is possible (and common), to define operations as only for installation or only for uninstallation. Having direct counterparts is not required. When defining an externalOps list with \u201cpure uninstallation\u201d actions, you should especially keep the reverse order of such operations in mind. resourceScripts, uninstResourceScripts : Lists of additional ExecutableScripts to make available on the target, for this operation to draw upon. To reference the script, build a path using the python constant QT_IFW_SCRIPTS_DIR or from directly within another script use @ScriptsDir@ . externalRes : A list of QtIfwExternalResource objects. Tools defined this list will be rolled into the installer without explicitly updating the QtIfwPackageScript owner of this operation object. QtIfwExternalOp Builders \u00b6 ON_INSTALL, ON_UNINSTALL, ON_BOTH, AUTO_UNDO \u00b6 Event constants for convenience methods. opDataPath \u00b6 opDataPath( rootFileName, isDetached=False, isNative=True, quotes=None, isDoubleBackslash=False ) Dynamically resolve paths to temp data files used by the operations, or to embed in custom scripts. rootFileName : Under normal circumstances, provide a simple \u201cdata key\u201d identifier (with no file extension) for this parameter. If a parent directory is included (be it an absolute or relative path), however, then the path will not be modified further (i.e. it will not built from a root name). Such allows for other functions that internally employ this one to implicitly handle files located elsewhere as well. For example, wrapping rootFileName in qtIfwDetachedOpDataPath() , is another means to reference the alternate \u201cdetached\u201d path (rather than via the isDetached option). isDetached : Operation data files are normally created within an installer sub directory , inside of the user/system temp directory. Everything in this directory is automatically purged when the installer/uninstaller completes. If you use a \u201cdetached op data file path\u201d, however, the file will be written to the root of the temp directory, and will not be automatically purged. That clean up is left for you to perform. The general use case for this feature is to support \u201cdetached operations\u201d which can, and typically do, live beyond the installer/uninstaller\u2019s process.. isNative : By default, paths are returned in a native format, i.e. with backslashes vs forward slashes as applicable. quotes : Optionally, you may provide explicit quote strings (e.g. \" or ' , or some escaped version of them) to wrap the returned path in such. isDoubleBackslash : Optionally, use this on Windows, to escape backslashes by doubling them up. QtIfwExternalOp.MakeDir \u00b6 MakeDir( event, dirPath, owner=QT_IFW_USER, group=QT_IFW_USER, <LINUX/MAC ONLY> access=\"755\", <LINUX/MAC ONLY> isElevated=True ) QtIfwExternalOp.RemoveDir \u00b6 RemoveDir( event, dirPath, isElevated=True ) QtIfwExternalOp.WriteFile \u00b6 WriteFile( event, filePath, data, isOverwrite=True, owner=QT_IFW_USER, group=QT_IFW_USER, <LINUX/MAC ONLY> access=\"644\", <LINUX/MAC ONLY> isElevated=True ) QtIfwExternalOp.RemoveFile \u00b6 RemoveFile( event, filePath, isElevated=True ) QtIfwExternalOp.CreateOpFlagFile \u00b6 CreateOpFlagFile( event, fileName, dynamicVar=None, isElevated=True ) dynamicVar : Control the creation of this file via a dynamic installer variable. Note that a \u201cfalse\u201d condition will be met when a boolean variable is explicitly set to false , or if the variable is undefined, or it contains no content, or if it is set to 0 . The opposing true condition, required to create the flag file, is simply the inverse of that. By default, this argument is set to None , and therefore the file will be created without any logical controls. QtIfwExternalOp.WriteOpDataFile \u00b6 WriteOpDataFile( event, fileName, data, isElevated=True ) QtIfwExternalOp.RunProgram \u00b6 RunProgram( event, path, arguments=None, isAutoQuote=True, isHidden=False, isSynchronous=True, isElevated=True, runConditionFileName=None, isRunConditionNegated=False, isAutoBitContext=True ) On Windows, set isAutoBitContext=False if you need to execute a 64 bit program from the installer\u2019s 32 bit context. QtIfwExternalOp.WaitForProcess \u00b6 WaitForProcess( event, exeName=None, pidFileName=None, timeOutSeconds=30, onTimeOut=None, isWaitForStart=False, isSuccessNoWait=True, isAutoBitContext=True ) pidFileName : This optional \u201cop data file\u201d argument, takes precedence over the exeName when provided. It should contain a process id to query. Such a file would normally be created via a prior QtIfwExternalOp.WriteOpDataFile operation or via a writeFile() invocation from QScript (leaning on QtIfwExternalOp.opDataPath() to dynamically resolve the path). onTimeOut : Additional script snippet to inject. Will be invoked on the event. On Windows, set isAutoBitContext=False if you need to execute a 64 bit program from the installer\u2019s 32 bit context. QtIfwExternalOp.CreateStartupEntry \u00b6 CreateStartupEntry( pkg=None, exePath=None, displayName=None, isAllUsers=False ) TODO: Add Linux & macOS implementations QtIfwExternalOp.CreateExternPackageFoundFlagFile \u00b6 MAC / LINUX CreateExternPackageFoundFlagFile( event, altPkgNames, fileName ) QtIfwExternalOp.InstallExternPackage \u00b6 MAC / LINUX InstallExternPackage( event, altPkgNames ) altPkgNames : May be a single string, or a list of them. If providing a list, alternate names will be used based on what is available within a given package manager on the target. For example, the package \u201cxvfb\u201d maybe specified as [\"xvfb\",\"Xvfb\"] . That handles the fact the \u201cX\u201d is capitalized within some contexts (e.g. within YUM on RHEL\u2026) but is lower case in others. QtIfwExternalOp.UninstallExternPackage \u00b6 MAC / LINUX UninstallExternPackage( event, altPkgNames ) altPkgNames : May be a single string, or a list of them. If providing a list, alternate names will be used based on what is available within a given package manager on the target. For example, the package \u201cxvfb\u201d maybe specified as [\"xvfb\",\"Xvfb\"] . That handles the fact the \u201cX\u201d is capitalized within some contexts (e.g. within YUM on RHEL\u2026) but is lower case in others. QtIfwExternalOp.CreateWindowsAppFoundFlagFile \u00b6 WINDOWS ONLY CreateWindowsAppFoundFlagFile( event, appName, fileName, isAutoBitContext=True ) QtIfwExternalOp.UninstallWindowsApp \u00b6 WINDOWS ONLY UninstallWindowsApp( appName, arguments=None, isSynchronous=True, isHidden=True, isAutoBitContext=True, isSuccessOnNotFound=True ) QtIfwExternalOp.CreateRegistryKey \u00b6 WINDOWS ONLY CreateRegistryKey( event, key, isAutoBitContext=True ) Set isAutoBitContext=False if you need to access 64 bit entries from the installer\u2019s 32 bit context, and/or wish to be explicit in the use of SysWow64 nodes. QtIfwExternalOp.RemoveRegistryKey \u00b6 WINDOWS ONLY RemoveRegistryKey( event, key, isAutoBitContext=True ) Set isAutoBitContext=False if you need to access 64 bit entries from the installer\u2019s 32 bit context, and/or wish to be explicit in the use of SysWow64 nodes. QtIfwExternalOp.CreateRegistryEntry \u00b6 WINDOWS ONLY CreateRegistryEntry( event, key, valueName=None, value=\"\", valueType=\"String\", isAutoBitContext=True ) Set isAutoBitContext=False if you need to access 64 bit entries from the installer\u2019s 32 bit context, and/or wish to be explicit in the use of SysWow64 nodes. QtIfwExternalOp.RemoveRegistryEntry \u00b6 WINDOWS ONLY RemoveRegistryEntry( event, key, valueName=None, isAutoBitContext=True ) Set isAutoBitContext=False if you need to access 64 bit entries from the installer\u2019s 32 bit context, and/or wish to be explicit in the use of SysWow64 nodes. QtIfwExternalOp.CreateExeFromScript \u00b6 WINDOWS ONLY CreateExeFromScript( script, brandingInfo, srcIconPath, targetDir=QT_IFW_TARGET_DIR ) script : ExecutableScripts QtIfwExternalOp.WrapperScript2Exe \u00b6 WINDOWS ONLY Script2Exe( scriptPath, exePath, brandingInfo, iconDirPath, iconName, isScriptRemoved=False, isIconDirRemoved=False ) QtIfwExternalOp.WrapperScript2Exe \u00b6 WINDOWS ONLY WrapperScript2Exe( scriptPath, exePath, targetPath, brandingInfo, iconName=\"0.ico\" ) QtIfwExternalOp Convenience Scripts \u00b6 Self-Destructing Script Snippets \u00b6 In some circumstances, e.g. when using scripts with QtIfwOnFinishedDetachedExec or QtIfwOnFinishedCheckbox , you may wish for your scripts to \u201cself-destruct\u201d (i.e. delete themselves). The following functions return strings that you may append to / weave into your custom scripts to serve this purpose. QtIfwExternalOp.batchSelfDestructSnippet \u00b6 QtIfwExternalOp.powerShellSelfDestructSnippet \u00b6 QtIfwExternalOp.vbScriptSelfDestructSnippet \u00b6 QtIfwExternalOp.shellScriptSelfDestructSnippet \u00b6 QtIfwExternalOp.appleScriptSelfDestructSnippet \u00b6 QtIfwExternalOp.CreateOpFlagFileScript \u00b6 CreateOpFlagFile( fileName, dynamicVar=None ) dynamicVar : Control the creation of the flag file via a dynamic installer variable. Note that a \u201cfalse\u201d condition will be met when a boolean variable is explicitly set to false , or if the variable is undefined , or it contains no content , or if it is set to 0 . The opposing true condition, required to create the flag file, is simply the inverse of that. So notably, the flag can be raised by having a value in the dynamic variable, to then just simply \u201ctrue\u201d. By default, this argument is set to None , and therefore the file will be created without any logical controls. Note that the flag is either raised by this function or not. This function does not remove a file that already exists. QtIfwExternalOp.MakeDirScript \u00b6 MakeDirScript( dirPath, owner=QT_IFW_USER, group=QT_IFW_USER, <LINUX/MAC ONLY> access=\"755\" ) <LINUX/MAC ONLY> Windows Type : Batch Mac/Linux Type : ShellScript QtIfwExternalOp.RemoveDirScript \u00b6 RemoveDirScript( dirPath ) Windows Type : Batch Mac/Linux Type : ShellScript QtIfwExternalOp.WriteFileScript \u00b6 WriteFileScript( filePath, data=None, isOverwrite=True, owner=QT_IFW_USER, group=QT_IFW_USER, <LINUX/MAC ONLY> access=\"644\" ) <LINUX/MAC ONLY> Windows Type : Batch Mac/Linux Type : ShellScript QtIfwExternalOp.RemoveFileScript \u00b6 RemoveFileScript( filePath ) Windows Type : Batch Mac/Linux Type : ShellScript QtIfwExternalOp.WriteOpDataFileScript \u00b6 WriteOpDataFileScript( fileName, data=None ) Windows Type : Batch Mac/Linux Type : ShellScript QtIfwExternalOp.RunProgramScript \u00b6 RunProgramScript( path, arguments=None, isAutoQuote=True, isHidden=False, isSynchronous=True, runConditionFileName=None, isRunConditionNegated=False, isAutoBitContext=True, replacements=None ) Windows Type : Batch or PowerShell (determined by options employed) Mac/Linux Type : ShellScript On Windows, set isAutoBitContext=False if you need to execute a 64 bit program from the installer\u2019s 32 bit context. Note: Elevation is controlled via the operation executing the script rather embedded within it. QtIfwExternalOp.WaitForProcessScript \u00b6 WaitForProcessScript( exeName=None, pidFileName=None, timeOutSeconds=30, onTimeout=None, isWaitForStart=False, isExitOnSuccess=True, isExitOnNoWait=True, isExitOnTimeout=True, isSelfDestruct=False, isAutoBitContext=True ) Windows Type : PowerShell Mac/Linux Type : ShellScript pidFileName : This optional \u201cop data file\u201d argument, takes precedence over the exeName when provided. It should contain a process id to query. Such a file would normally be created via a prior QtIfwExternalOp.WriteOpDataFile operation or via a writeFile() invocation from QScript (leaning on QtIfwExternalOp.opDataPath() to dynamically resolve the path). On Windows, set isAutoBitContext=False if you need to execute a 64 bit program from the installer\u2019s 32 bit context. Note: Elevation is controlled via the operation executing the script rather embedded within it. QtIfwExternalOp.CreateExternPackageFoundFlagFileScript \u00b6 MAC / LINUX Mac/Linux Type : ShellScript CreateExternPackageFoundFlagFile( altPkgNames, fileName, isSelfDestruct=False ) QtIfwExternalOp.InstallExternPackageScript \u00b6 MAC / LINUX Mac/Linux Type : ShellScript InstallExternPackage( altPkgNames, isExitOnFailure=False ) altPkgNames : May be a single string, or a list of them. If providing a list, alternate names will be used based on what is available within a given package manager on the target. For example, the package \u201cxvfb\u201d maybe specified as [\"xvfb\",\"Xvfb\"] . That handles the fact the \u201cX\u201d is capitalized within some contexts (e.g. within YUM on RHEL\u2026) but is lower case in others. QtIfwExternalOp.UninstallExternPackageScript \u00b6 MAC / LINUX Mac/Linux Type : ShellScript UninstallExternPackage( altPkgNames, isExitOnFailure=False ) altPkgNames : May be a single string, or a list of them. If providing a list, alternate names will be used based on what is available within a given package manager on the target. For example, the package \u201cxvfb\u201d maybe specified as [\"xvfb\",\"Xvfb\"] . That handles the fact the \u201cX\u201d is capitalized within some contexts (e.g. within YUM on RHEL\u2026) but is lower case in others. QtIfwExternalOp.CreateRegistryKeyScript \u00b6 WINDOWS ONLY CreateRegistryKeyScript( key, isAutoBitContext=True, replacements=None ) Type : PowerShell QtIfwExternalOp.RemoveRegistryKeyScript \u00b6 WINDOWS ONLY RemoveRegistryKeyScript( key, isAutoBitContext=True, replacements=None ) Type : PowerShell QtIfwExternalOp.CreateRegistryEntryScript \u00b6 WINDOWS ONLY CreateRegistryEntryScript( key, valueName=None, value=\"\", valueType=\"String\", isAutoBitContext=True, replacements=None ) Type : PowerShell QtIfwExternalOp.RemoveRegistryEntryScript \u00b6 WINDOWS ONLY RemoveRegistryEntryScript( key, valueName=None, isAutoBitContext=True, replacements=None ) Type : PowerShell QtIfwExternalOp.CreateWindowsAppFoundFlagFileScript \u00b6 WINDOWS ONLY CreateWindowsAppFoundFlagFileScript( appName, fileName, isAutoBitContext=True, isSelfDestruct=False ) Type : PowerShell QtIfwExternalOp.UninstallWindowsAppScript \u00b6 WINDOWS ONLY UninstallWindowsAppScript( appName, arguments=None, isSynchronous=True, isHidden=True, isAutoBitContext=True, isSelfDestruct=False ) Type : PowerShell QtIfwKillOp \u00b6 This class is used to drive process killing operations. Such actions are frequently useful prior to installing or uninstalling software, especially when it comes to instances of the target programs themselves. This class is employed by QtIfwPackageScript , and is internally used to actually generate and inject QtIfwExternalOp objects. Constructor: QtIfwKillOp( processName, onInstall=True, onUninstall=True ): Attributes & default values: proc es sName = < required > onInstall = True onUninstall = True isElevated = True Notes: Kill operations are performed prior to any others during either on install or uninstall process. ALL processes with the given processName will be forcefully terminated. For convenience, instead of passing the explicit name the of process, you may instead pass a QtIfwPackage . In which case, the name of the \u201cprimary executable\u201d will be automatically extracted from that. QtIfwExternalResource \u00b6 This class provides as a means to include \u201cresources\u201d (e.g. third party utility programs), in the installer which are not part of the product or intended for direct use by an end user. Such resources may then be utilized by your package script operations. These objects are typically added to in the externalRes attribute of QtIfwExternalOp objects, which in turn are utilized by QtIfwPackageScript objects. By default, such resources will be extracted into a temporary location on the target and removed at the end of installation. If you will require any for maintenance operations (i.e. during updates or uninstallation), enabling the isMaintenanceNeed attribute will cause the resource to be retained on the target, so it will be available later when needed. Constructor: QtIfwExternalResource( name, srcPath, srcBasePath=None, isMaintenanceNeed=False, contentKeys={} ) Object Attributes & default values: name = <required> srcPath = <required> srcBasePath = None isMaintenanceNeed = False contentKeys = {} Object Methods: targetPath( key=None ) targetDirPath() targetPathVar( key=None ) targetDirPathVar() Static Methods: BuiltIn( name, isMaintenanceNeed=False ) Built In Windows Resource Names: RESOURCE_HACKER http://www.angusj.com/resourcehacker/ name : The base id by which to reference the resources and to name a target container directory. srcPath : The path to the resources file or directory . This may be absolute or relative. srcBasePath : If using a relative srcPath , you may override the base path with this. isMaintenanceNeed : Enabling this will cause the resource to be retained on the target, so it will be available for the maintenance tool / uninstaller. contentKeys : A dictionary of key/value pairs to be registered in the installer, allowing you to dynamically access the paths within scripts on your target. If this detail is omitted during construction, and your QtIfwExternalResource contains only one file, a key will be automatically registered for you as the name of the object. targetPath( key ) : Use this to reference the resource paths when generating QtScripts / operations which will utilize it. Specify the key as registered via contentKeys . If you omit the key when calling this, and only one key exists (such as when bundling a single file), that default key will be implied. targetDirPath() : In the event you need to access the container directory for the tool, e.g. to change your working directory to it, you may employ this method. targetPathVar( key=None ), targetDirPathVar() : The place holders / variable names to use inside an ExecutableScript to refer to these paths. Assuming a key is valid, you could also just hardcode it like @key@ rather than call targetPathVar( key=None ) to get that back! QtIfwExternalResource.BuiltIn : Convenience method to bundle tools into an installer which are included with the library. QtIfwExeWrapper \u00b6 This class provides a means to \u201cwrap\u201d your exe inside of additional external layers. Such layers may take different forms, and be nested inside of one another. The benefit of this is to impose a specific environment and or set of parameters onto the exe without having to modify it internally. These options work cross platform, and could be slapped over the top of a program written in any language. You may, in fact, even wrap third-party (pre-compiled) programs in these layers! The easiest way to use this class is to set some of its basic attributes. For example, workingDir , isElevated , envVars , or args . The approach taken by the library is to use the \u201clightest touch\u201d possible. If you simply changed the default values for those example attributes, their shortcuts (on applicable platforms) and the way QtIFW would run the program post installation, would be altered to provided the functionality. The most flexible attribute you may impose is a wrapperScript layer. This is an ExecutableScript object, used to produce a persistent \u201ccompanion\u201d to your binary. Executing the script rather then the binary itself would be the intended means for launching the program. If this attribute is set, \u201cshortcuts\u201d which would normally point a user to the binary, will instead run this wrapper layer. On Windows, this (normally) equates to having a batch file companion. On Linux, a shell script companion is created (with an explicit .sh extension). On macOS, a shell script with no extension is embedded into the .app file when producing a gui application, else the same design used on Linux is employed for non-gui programs. The application of a wrapper script of this nature is not entirely uncommon - especially on Linux. As an example, when deploying Qt C++ applications on Linux which are dynamically linked, the standard procedure (per Qt documentation) is to use this (slightly modified) shell script to load the required libraries: 1 2 3 4 5 6 7 8 9 10 #!/bin/sh appname = ` basename \" $0 \" | sed s, \\. sh$,, ` dirname = ` dirname \" $0 \" ` tmp = \" ${ dirname #? } \" if [ \" ${ dirname % $tmp } \" ! = \"/\" ] ; then dirname = \" $PWD / $dirname \" fi LD_LIBRARY_PATH = \" $dirname \" export LD_LIBRARY_PATH \" $dirname / $appname \" \" $@ \" Other ways for using a wrapper like this include automatically detecting dependencies, and then downloading and installing them as needed. Or, doing something similar for updates to your software. Using a wrapper, you could launch a \u201ccompanion application\u201d along side the primary target. You could start a background service, or open help documentation\u2026 The possibilities are really boundless. Note: On Windows and Linux desktops (e.g. Ubuntu) for a gui application with shortcuts , the \u201cbuilt-in wrapper\u201d features ( workingDir , isElevated , envVars , args ) maybe used in combination with a custom wrapperScript . I.e. those options will be applied via the shortcut launching the script OR the executable. If you need the wrapper to work without a shortcut involved, you will have to manually include these other features in the script. On macOS , this will always be applicable because there is no \u201cshortcut\u201d involved. To add these details yourself, you may wish to first use the built-in attributes without the custom script, then copy what is written to the auto generated script into your own. Alternately, you could programmatically manipulate the wrapperScript attribute referencing an ExecutableScript generated for you by this class upon it\u2019s construction (or upon a call to refresh() ). On WINDOWS ONLY : You may optionally enable the isExe flag. Rather than a batch file, this will produce a proxy exe, which will live adjacent to the target it wraps. The icon and version / branding info from the original will be injected into it. Constructor: QtIfwExeWrapper( exeName, isGui=False, wrapperScript=None, exeDir=QT_IFW_TARGET_DIR, workingDir=None, args=None, envVars=None, isElevated=False, isExe=False ) Attributes & default values: exeName = < required > isGui = False wrapperScript = None exeDir = \"@TargetDir@\" < QtIfw Built - in Variable > workingDir = None < None = don ' t impose here , use QT_IFW_TARGET_DIR via other means > args = None envVars = None isElevated = False < Windows only > isExe = False wrapperExeName = \"<exeName>Launcher\" wrapperIconName = \"0.ico\" _winPsStartArgs = None < Auto defined via refresh > _runProgram _runProgArgs _shortcutCmd _shortcutArgs _shortcutWinStyle Functions: refresh() QtIfwOnFinishedDetachedExec \u00b6 This class defines an action to be invoked upon completing the wizard. It will launch a detached / asynchronous process when the user clicks the \u201cFinished\u201d button (which may occur virtually within a silent installer). Such actions may be invoked on installation, uninstallation, or both. While working independently from it, this class is closely related to QtIfwOnFinishedCheckbox . This class provides the framework for the core functionally, while that one contributes UI dimensions. Constructor: QtIfwOnFinishedDetachedExec( name, event=None, ifwPackage=None, runProgram=None, argList=None, shellCmd=None, script=None, openViaOsPath=None, isReboot=False, rebootDelaySecs=2, ifCondition=None ) onLoad=None, onEnter=None ) Attributes: name = name <QtIfwOnFinishedDetachedExec.ON_INSTALL / ON_UNINSTALL / ON_BOTH> event = ON_INSTALL runProgram = None argList = None script = None isReboot = isReboot ifCondition = None <QtScript snippet> _action = <auto defined> Details: ifCondition : Controls whether to invoke this action via QtScript. Note, this feature is not applied by the derived class QtIfwOnFinishedCheckbox. That class invokes the corresponding action if the checkbox is selected. QtIfwUiPage \u00b6 This class closely resembles QtIfwWidget . They internally derive from a common (protected) base class. In contrast, however, QtIfwWidgets are collections of user interface elements to be injected into default wizard pages, where QtIfwUiPages are entirely new steps/pages injected between (or over ) default wizard pages. A great deal can be done to customize the way an installer\u2019s interface works by simply adding custom widgets. There are limitations, however, to that approach. This class is used to completely add or overwrite pages in the an installer. The content of the pages are defined as Qt \u201cforms\u201d, i.e. .ui (xml) files which adhere to the Qt UI file format . While it is possible to manually create such forms, typically such files are machine generated using a WYSIWYG tool from within Qt Creator or Qt Designer . Constructor: QtIfwUiPage( name, pageOrder=None, sourcePath=None, content=None, onLoad=None, onEnter=None ) Attributes: name = <required> pageOrder = None content = None replacements = {} onLoad = None onEnter = None eventHandlers = {} supportScript = None isIncInAutoPilot = False _isOnLoadBase = True _isOnEnterBase = True Functions: fileName() resolve( qtIfwConfig ) write( dirPath ) Details: name : This identifier will be used to name a .ui file containing the form, and to reference the page widget within any scripting. If you wish to replace a default page, set the name for an object of this type to QT_IFW_REPLACE_PAGE_PREFIX concatenated with one of the following page name constants: QT_IFW_INTRO_PAGE QT_IFW_TARGET_DIR_PAGE QT_IFW_COMPONENTS_PAGE QT_IFW_LICENSE_PAGE QT_IFW_START_MENU_PAGE QT_IFW_READY_PAGE QT_IFW_INSTALL_PAGE QT_IFW_FINISHED_PAGE Conversely, to add a new page, give it some other name and specify the pageOrder using one the constants above. pageOrder : If not a replacement, the page will be added added BEFORE this specified page. onLoad : Qt Script snippet invoked when loading the page into memory. This is executed within a package script, when then \u201ccomponent\u201d is constructed. It\u2019s scope therefore is limited to such, and it cannot call functions defined in the controller script . UI page resources are contained within packages, which is why they are loaded and configured from there. onEnter : Qt Script snippet invoked upon entering / displaying the page to the user. This is executed within a controller script, it\u2019s scope is limited to such. Therefore, package script functions and globals are not available here. isIncInAutoPilot : This attribute is only applied when the page is not a replacement. Note, this is False by default. Set this to True , to load this \u201cadditional\u201d page when running in \u201cauto pilot mode\u201d (e.g. within a Silent Installer context. It is then on you to ensure that alternate installation mode functions as desired. See _isOnEnterBase . _isOnLoadBase : Protected Note, this is enabled by default. When this is set to True , an auto generated script will be added to the installer, which will execute prior to onLoad . This \u201cbase\u201d script will dynamically resize the page, so it fits properly on each alternate platform\u2019s version of the installer. It is recommended you leave this in place, unless you are overwriting it. Having this in place will additionally create a var page , which refers to this page. The onLoad script may then make use of that variant to access the page widget or the child widgets on it. See Installer Scripting _isOnEnterBase : Protected Note, this is enabled by default. When this is set to True , an auto generated script will be added to the installer, which will execute prior to onEnter . This \u201cbase\u201d script will automatically \u201cclick\u201d the \u201cNext\u201d button upon displaying the page, when running in \u201cauto pilot mode\u201d (e.g. within a Silent Installer context. Having this in place will additionally create a var page , which refers to this page. The onEnter script may then make use of that variant to access the page widget or the child widgets on it. See Installer Scripting eventHandlers : Qt Script simple \u201cevent handler\u201d dictionary containing entries in the form: name:body. The typical use case for this attribute involves the onLoad script connecting events (e.g. button clicks) to handlers. The eventHandlers then provide the definitions for what to do upon event occurrences. (Note: These are defined within a package script, but are controller.prototypes .) Note this uses the Qt signal/slot mechanism for built-in widget types. You must add your own \u201cconnections\u201d, via the Qt Script rules for such (again typically within your onLoad ). An example of that would look like: page.mybutton.released.connect(this, this.myhandler); . supportScript : A completely open ended Qt Script (string) attribute, for injecting any additional support/helper function definitions which maybe handy. Note that these will live in the global space of the controller script. Be careful to avoid name conflicts! replacements : A dictionary containing entries in the form: placeholder:value. Upon writing the .ui file for the installer definition the library the generates, all \u201creplacements\u201d in the content will be resolved. TODO: further explain the complicate logic for page order (for replacement pages, or multiple pages with the same order\u2026). Also elaborate on ui replacements, the \u201cresolve\u201d function, provide a base example .ui in the docs\u2026 QtIfwDynamicOperationsPage \u00b6 This class is derived from QtIfwUiPage . It provides a \u201cblank\u201d page for performing custom operations during the installation process. Note that these operations take place outside of the main, built-in \u201cinstaller operations\u201d, and instead allow more dynamic actions to place \u201caround\u201d that process. Optionally, you may also control the UI as your operation proceeds to indicate the status / result of the operations. Constructor: QtIfwDynamicOperationsPage( name, operation=\"\", asyncFuncs=[], order=QT_IFW_PRE_INSTALL, onCompletedDelayMillis=None ) Static Functions: onCompleted( name ) Details: operation : The custom QtScript to execute, kicking off the operation. At the end of this script, you this should explicitly return a boolean indication of completion. If completion is indicated (i.e. true is returned), the onCompletedDelayMillis parameter will dictate what occurs next (see the description for the constructor argument). If false is returned, then nothing will occur directly following the initial (synchronous) \u201ckick off\u201d. You may wish to return false from the operation script, so you that you may continue the custom task by employing a QtIfwDynamicOperationsPage.AsyncFunc - or a series of them. At the end of such a function, you may inject what is returned from the static onCompleted( name ) function of this class, in order to allow the advancement of the installer wizard. The operation function will have a reference to the UI page passed to it (called page ). During your operation, you may wish to call functions such as setCustomPageText( page, title, description ) (or build that script via the Python helper: setCustomPageText( title, description, isAutoQuote=True, pageVar=\"page\" ) ). asyncFuncs : List of QtIfwDynamicOperationsPage.AsyncFunc objects. See the description for operation above. order : Specify either QT_IFW_PRE_INSTALL or QT_IFW_POST_INSTALL . Note: You may NOT specify one of the standard options for a QtIfwUiPage attribute pageOrder . onCompletedDelayMillis : By default, this is set to None , which indicates that upon completion, the page should advanced instantly. If a value greater than 0 is provided, the page will automatically advance after a delay of that duration. Alternatively, an integer value of 0 (or less than 0), will indicate a manual advancement will take place. The \u201cNext\u201d button will become enabled, and the user may click such when they choose. onCompleted( name ) : Returns a string to do be injected into QtScript being dynamically generating. QtIfwDynamicOperationsPage.AsyncFunc \u00b6 This class is used to define QtScript functions to be used by a QtIfwDynamicOperationsPage , which may be invoked asynchronously . The primary application for this mechanism is to allow UI modifications to be redrawn on the screen, while performing long \u201cblocking\u201d operations. To use it in this manner, you should execute your UI modification code, and then invoke a blocking operation which is defined within one of these async functions. The UI will thus be updated prior to the block. At the end of the long running async function, you may repeat the pattern, if desired, to again update the screen prior to initiating another task which would prevent a screen refresh. Such a design pattern simulates synchronous code, while getting the benefit of having the UI change through out it. Note: multiple overlapping AsyncFunc invocations are not currently supported. The result of attempting will yield undesired results! Use these sequentially, one invoking another, in a chain is described previously. Constructor: AsyncFunc( name, parms=[], body=\"\", delayMillis=1, standardPageId=None, customPageName=None ) Attributes: name = <required> args = [] body = \"\" delayMillis = 1 standardPageId = None customPageName = None Functions: invoke( args=[], isAutoQuote=True ): Details: name : The function name. (Note this will not be the complete, real function name in the generated QtScript). args : The names of the function arguments. body : The body of the function. delayMillis : The number of milliseconds to wait before invoking the function. *standardPageId : Provide a standard page id constant to effectively bind the function to the page. You will magically have a page var within the function to access the UI elements. customPageName : Provide the name of a custom page effectively bind the function to the page. You will magically have a page var within the function to access the UI elements. invoke() : Returns a string to do be injected into whatever QtScript you are dynamically generating. (This not somehow literally \u201cinvoke\u201d the function when called from the Python library! ) QtIfwOnPriorInstallationPage \u00b6 This class is derived from QtIfwUiPage . As one would assume, this provides a base from which to start modifying the distbuilder addition to QtIFW \u201cPrior Installation Detected\u201d installer page. If another page has not been supplied for this, distbuilder will use this class to apply it\u2019s own default customization to the natural QtIfw interface. Constructor: QtIfwOnPriorInstallationPage() # 0 arguments! QtIfwRemovePriorInstallationPage \u00b6 This class is derived from QtIfwDynamicOperationsPage . It works in concert with QtIfwOnPriorInstallationPage , performing the actual action of the removal. If desired, you may supply your own custom definition of this page, else the library will inject the default version of this. Constructor: QtIfwRemoveInstallationPage() # 0 arguments! QtIfwTargetDirPage \u00b6 This class is derived from QtIfwUiPage . As one would assume, this provides a base from which to start modifying the \u201cTarget Directory\u201d installer page. If another page has not been supplied for this, distbuilder will use this class to apply it\u2019s own default customization to the natural QtIfw interface. Constructor: QtIfwTargetDirPage() # 0 arguments! QtIfwSimpleTextPage \u00b6 This class is derived from QtIfwUiPage . It does not require ANY form / .ui content passed to it. It provides a page layout with the only elements being title and description , which can both be set easily via arguments to the constructor of this class. That text may contain all valid QtIFW dynamic substitutions e.g. these Installer Variables , or directly using the @variable@ syntax. See https://doc.qt.io/qtinstallerframework/scripting.html#predefined-variables . By providing an onLoad or onEnter script, you may define more comprehensive manipulations of the pages elements. Alternatively, you wish to specify no text or content at all for the page, other than perhaps including a message such as \u201cworking\u2026\u201d and then use the page as a place holder to perform a given process. There are many imaginative ways for using this class as a convenient platform from which to start a custom, dynamic page. Constructor: QtIfwSimpleTextPage( name, pageOrder=None, title=\"\", text=\"\", onLoad=None, onEnter=None ) QtIfwWidget \u00b6 This class closely resembles QtIfwUiPage . They internally derive from a common (protected) base class. In contrast, however, QtIfwWidgets are collections of user interface elements to be injected into default wizard pages, where QtIfwUiPages are entirely new steps/pages injected between (or over ) default wizard pages. Note that a QtIfwWidget that you create and inject into a page will generally contain other widgets. To access the nested widgets in a QtScript, you would use the notation page.parent.child . The content of the widgets are defined as Qt \u201cforms\u201d, i.e. .ui (xml) files which adhere to the Qt UI file format . While it is possible to manually create such forms, typically such files are machine generated using a WYSIWYG tool from within Qt Creator or Qt Designer . Constructor: QtIfwWidget( name, pageName, position=None, sourcePath=None, content=None, onLoad=None, onEnter=None ) Attributes: name = <required> pageName = <required> position = None content = None replacements = {} onLoad = None onEnter = None eventHandlers = {} supportScript = None _isOnLoadBase = True _isOnEnterBase = True Functions: fileName() resolve( qtIfwConfig ) write( dirPath ) pageName : The wizard page where the widget will be added. position : 0 based index where the widget will be injected onto the page. Injections occur at the bottom of the default page, below the default elements. (per Qt\u2019s design). onEnter : Qt Script snippet invoked upon entering / displaying the page to the user. This code will be invoked AFTER the initial \u201cpage call back\u201d on which the widget was injected. To modify those page call backs instead, see QtIfwControlScript . QtIfwOnFinishedCheckbox \u00b6 A QtIfwWidget to be injected into the Finished QtIFW wizard page. If one of these checkboxes is selected upon exiting a successfully completed wizard, the action associated with that will be executed in a \u201cdetached\u201d manner (i.e. a process which is spawned by the installer, but not bound to it, so that it may live on after the installer process no longer exists). In addition to inheriting from class QtIfwWidget, this class is also a decedent of QtIfwOnFinishedDetachedExec . That class provides the framework for the core functionally, while this one contributes UI dimensions. Note: This class only adds checkboxes to the installer finished page. It is not possible to add custom widgets to the uninstaller finished page, because widgets are bundled and loaded via components (i.e. packages), and the QtIFW uninstaller does not load components! For comparable functionality, you may employ QtIfwOnFinishedDetachedExec. Constructor: QtIfwOnFinishedCheckbox( name, text=None, position=None, ifwPackage=None, runProgram=None, argList=None, shellCmd=None, script=None, openViaOsPath=None, isReboot=False, rebootDelaySecs=2, isVisible=True, isEnabled=True, isChecked=True ) Attributes & default values: name = <required> checkboxName = <automatic> position = None <automatic, per object instantiation order> isReboot = False Functions: < These return QScript snippets > isChecked () setChecked () enable ( isEnable = True ) setVisible ( isVisible = True ) PipConfig \u00b6 Objects of this type define the details for downloading and/or installing Python libraries via the pip utility. These objects are used directly by the installLibrary function as well indirectly via the obfuscation functions and support classes. Constructor: PipConfig( source = None , version = None , verEquality = \"==\" , destPath = None , asSource = False , incDependencies = True , isForced= False , isCacheUsed = True , isUpgrade = False , otherPipArgs = \"\" ) Attributes: pipCmdBase = \"[PYTHON BINARY PATH]\" -m pip source version verEquality destPath asSource incDependencies isForced isCacheUsed isUpgrade otherPipArgs (open ended argument string) TODO: Expand on this considerably\u2026 The source attribute is the the \u201cheart\u201d of this class. It can take many different forms. Including library names registered at PyPi, local paths, and urls. Other Notable attributes include incDpndncsSwitch , destPath and asSource . These allow you to skip dependency gathering if desired, install to a specific path such as a temp build directory, and to request raw .py scripts be placed there. Note that remote raw pip packages will require an alternate vcs url be supplied to a \u201cdevelopment\u201d repository in place of the simple package name as the source attribute. See editable installs OpyConfig \u00b6 Objects of this type define obfuscation details for use by the Opy Library. Refer to the documentation for that library for details. This library EXTENDS the natural OpyConfig, however, adding the attributes / features described below. See Obfuscation Features for a description of how objects of this type are used. Constructor: OpyConfig( name, entryPointPy=None, bundleLibs=None, sourceDir=None, patches=None ) Attributes: name entryPointPy bundleLibs (list of LibToBundle objects) sourceDir (dynamically defined when ommited) patches (list of OpyPatch objects) OpyPatch \u00b6 See Obfuscation Features for a description of how objects of this type are used. Constructor: OpyPatch( relPath, patches, parentDir=OBFUS_DIR_PATH ) Attributes: relPath path patches Functions: obfuscatePath( obfuscatedFileDict ) apply() LibToBundle \u00b6 See Obfuscation Features for a description of how objects of this type are used. Constructor: LibToBundle( name, localDirPath=None, pipConfig=None, isObfuscated=False ) Attributes: name localDirPath pipConfig isObfuscated","title":"Configuration Classes"},{"location":"ConfigClasses.html#configuration-classes","text":"The following classes are used to create objects which are employed as arguments to various functions within the library. Many of these can be generated for you using the Configuration Factory .","title":"Configuration Classes"},{"location":"ConfigClasses.html#pyinstallerconfig","text":"Objects of this type define optional details for building binaries from .py scripts using the PyInstaller utility invoked via the pyScriptToExe function (which maybe employed by higher level Process Classes under the hood). Note that if a PyInstSpec attribute is provided for one of these objects, the build settings contained within that will override any which conflict with those specified via the attributes set directly on the PyInstallerConfig object. PyInstSpec objects may be created by supplying a traditional (perhaps legacy) spec file definition, or you may wish to generate one with distbuilder via the makePyInstSpec() function. In either case, you may also opt to dynamically manipulate the spec via the implementation of that class. Constructor: PyInstallerConfig() Attributes & default values: pyInstallerPath = <python scripts directory>/pyinstaller name = None entryPointPy = None pyInstSpec = None isGui = False iconFilePath = None versionInfo = None versionFilePath = None isAutoElevated = False isOneFile = True (note this differs from PyInstaller default) importPaths = [] hiddenImports = [] dataFilePaths = [] binaryFilePaths = [] distResources = [] distDirs = [] codeSignConfig = [] codeSignTargets = [] otherPyInstArgs = \"\" (open ended argument string) distDirPath = None _pngIconResPath = None isSpecFileRemoved = False","title":"PyInstallerConfig"},{"location":"ConfigClasses.html#pyinsthook","text":"Objects of this type are used for PyInstaller \u201chook\u201d script creation, and programmatic manipulation. Such hooks are executed during a PyInstaller analyis process when an import is encountered with a matching hook name. The purpose of a hook is to help PyInstaller find and collect resources it would otherwise not know to include in the bundle. Hooks are commonly installed by third party libraries for use across your Python environment whenever you employ PyInstaller. It is also possible to use custom hooks during a given a build process via the PyInstaller option --additional-hooks-dir (though that parameter does not override a hook which is registered for the system on the whole\u2026) If you are working in a context in which you can manipulate the build environment freely, the use of hooks is arguably a better means by which to gather resources for a distribition rather than by adding them through PyInstallerConfig attributes hiddenImports , dataFilePaths , binaryFilePaths , etc. Use cases for this class include: adding hooks to patch a build process, replacing bad hooks installed on your system, or to simply revisw them for some additional custom need. For more on hooks, see: Understanding PyInstaller Hooks Constructor: PyInstHook( name, script=None, isContribHook=True, isRunTimeHook=False ) Attributes & default values: name = *required script = None isContribHook = True isRunTimeHook = False hooksDirPath = None Object Methods: fileName() read() write() remove() debug() toLines() fromLines( lines ) injectLine( injection, lineNo ) Details: The name attribute should simply specify the name of import which invokes the script . The name should not contain the literal \u201chook-\u201d file name prefix, or a .py file extension . isContribHook : Only respected for PyInstaller v4 or later, when it became available, and the new standard practice for hook distribution. hooksDirPath may be override, as needed. If left as the default None , the path will be automatically resolved.","title":"PyInstHook"},{"location":"ConfigClasses.html#pyinstspec","text":"Objects of this type are used for PyInstaller spec file parsing, and programmatic manipulation. This class provides an easy mechanism for applying known PyInstaller patches, as well as convenient mechanisms for applying custom revisions for similar purposes. Constructor: PyInstSpec( filePath=None, pyInstConfig=None, content=None ) Attributes & default values: filePath = None pyInstConfig = None content = None warningBehavior = None <options: PyInstSpec.WARN_IGNORE, PyInstSpec.WARN_ONCE, PyInstSpec.WARN_ERROR> isUnBufferedStdIo = False isModInitDebug = False isInjected = False Static Method: cfgToPath( pyInstConfig ) Object Methods: path() read() write() debug() toLines() fromLines( lines ) injectLine( injection, lineNo ) injectDuplicateDataPatch() _parseAssigments()","title":"PyInstSpec"},{"location":"ConfigClasses.html#iexpressconfig","text":"WINDOWS ONLY Objects of this type define optional details for building binaries from native Windows scripts (currently supporting Batch, PowerShell, VBScript, and JScript), using the IExpress utility built into the OS, as invoked via the batchScriptToExe , powerShellScriptToExe , vbScriptToExe , or jScriptToExe functions (which maybe employed by higher level Process Classes under the hood). Constructor: IExpressConfig() Attributes & default values: name = None sourceDir = None entryPointScript = None scriptHeader = None isScriptDebug = False versionInfo = None iconFilePath = None isAutoElevated = False scriptImports = [] #Embedded embeddedResources = [] #Embedded distResources = [] #External distDirs = [] #External (mkDir) codeSignConfig = [] codeSignTargets = [] # result destDirPath = None isScriptDebug : TODO: Fill-in - Note the extended VbScript functionality","title":"IExpressConfig"},{"location":"ConfigClasses.html#codesignconfig","text":"This class defines the details used for code signing executables. TODO: Make Cross Platform Constructor: CodeSignConfig( keyFilePath=None, keyPassword=None ) Attributes & default values: keyFilePath = None keyPassword = None signToolPath = None <None==auto resolved> fileDigest = CodeSignConfig.DEFAULT_DIGEST timeStampDigest = CodeSignConfig.DEFAULT_DIGEST timeStampServerUrl = CodeSignConfig.DEFAULT_TIMESTAMP_SERVER otherSignToolArgs = \"\" isDebugMode = True Class Constants: DEFAULT_DIGEST = \"sha256\" DEFAULT_TIMESTAMP_SERVER = \"http://timestamp.digicert.com\" signToolPath : Only applicable on WINDOWS. If None , this defaults to the path the this library will auto install the tool as needed. This attribute may also be set indirectly by running the script where an environmental variable call SIGNTOOL_PATH (defined the in constant SIGNTOOL_PATH_ENV_VAR ) has been defined.","title":"CodeSignConfig"},{"location":"ConfigClasses.html#selfsignedcertconfig","text":"This class defines the details used for generating self-signed code signing certificates and keys. TODO: Make Cross Platform Constructor: CodeSignConfig( companyTradeName, destDirPath=None ) Attributes & default values: commonName = companyTradeName endDate = SelfSignedCertConfig . DEFAULT_END_DATE destDirPath = destDirPath or THIS_DIR caCertPath = < auto , based on destDirPath > privateKeyPath = < auto , based on destDirPath > makeCertPath = None < None , auto resolved > _maxCertChildren = SelfSignedCertConfig . NO_MAX_CHILDREN _enhancedKeyUsage = SelfSignedCertConfig . LIFETIME_SIGNING_EKU otherArgs = \"\" isDebugMode = True Object Methods: _forceMakeCertMethod() Class Constants: DEFAULT_END_DATE = '12/31/2050' NO_MAX_CHILDREN = 0 LIFETIME_SIGNING_EKU = '1.3.6.1.5.5.7.3.3,1.3.6.1.4.1.311.10.3.13' makeCertPath : Only applicable on WINDOWS. Normally used on legacy versions of Windows (v8.0 an earlier), where new standard means for creating such files - i.e. the PowerShell function New-SelfSignedCertificate is not available. If None , this defaults to the path where this library will auto install the tool as needed. This attribute may also be set indirectly by running the script where an environmental variable call MAKECERT_PATH (defined the in constant MAKECERT_PATH_ENV_VAR ) has been defined.","title":"SelfSignedCertConfig"},{"location":"ConfigClasses.html#pvk2pfxconfig","text":"Used in legacy Windows mechanisms for creating code signing certificates. Specified defines the details for converting .pvk files (old style private keys) generated by the now defunct makecert utility, into .pfx files. Constructor: Pvk2PfxConfig( caCertPath, privateKeyPath, keyPassword=None, pfxFilePath=None ) Attributes & default values: caCertPath = <required> privateKeyPath = <required> keyPassword = None keyFilePath = <result - pfxFilePath or auto based on privateKeyPath> pvk2PfxPath = None <None, auto resolved> otherArgs = \"\" isDebugMode = True pvk2PfxPath : If None , this defaults to the path the this library will auto install the tool as needed. This attribute may also be set indirectly by running the script where an environmental variable call PVK2PFX_PATH (defined the in constant PVK2PFX_PATH_ENV_VAR ) has been defined.","title":"Pvk2PfxConfig"},{"location":"ConfigClasses.html#windowsexeversioninfo","text":"Objects of this type define meta data branded into Windows executables. This is the object type intended for PyInstallerConfig.versionInfo attributes. Constructor: WindowsExeVersionInfo() Attributes & default values: major = 0 minor = 0 micro = 0 build = 0 companyName = \"\" productName = \"\" description = \"\" exeName = \"\" Static Methods: defaultPath() Object Methods: version( isCommaDelim=False ) copyright() internalName() fileName() write() debug()","title":"WindowsExeVersionInfo"},{"location":"ConfigClasses.html#qtifwconfig","text":"Objects of this type provide the highest level definition of a QtIFW installer configuration to use for building an installer via the buildInstaller function (which maybe employed by higher level Process Classes under the hood). Constructor: QtIfwConfig( installerDefDirPath=None, packages=None, configXml=None, controlScript=None, setupExeName=\"setup\" ) Attributes & default values: installerDefDirPath = None packages = None <list of QtIfwPackages OR directory paths> configXml = None controlScript = None setupExeName = \"setup\" <other IFW command line options> isDebugMode = True otherQtIfwArgs = \"\" Functions: addUiElements ( uiElements , isOverWrite = True ) addLicense ( licensePath , name = \" End User License Agreement \" )","title":"QtIfwConfig"},{"location":"ConfigClasses.html#qtifwconfigxml","text":"Objects of this type define the contents of a QtIFW config.xml which will be dynamically generated when invoking the buildInstaller function. The config.xml file represents the highest level definition of a QtIFW installer, containing information such as the product name and version. Most of the attributes in this class correspond directly to the name of the tags added to the xml file. Attributes set to None values will not be written, otherwise they will be. Constructor: QtIfwConfigXml( name, version, publisher, iconFilePath=None, controlScriptName=None, primaryContentExe=None, isPrimaryExeGui=True, primaryExeWrapper=None, companyTradeName=None, wizardStyle=None, logoFilePath=None, bannerFilePath=None ) Attributes: primaryContentExe (used indirectly w/ isGui) companyTradeName (used indirectly) iconFilePath (used indirectly) logoFilePath (used indirectly) bannerFilePath (used indirectly) primaryExeWrapper Name Version Publisher <Windows / Mac> InstallerApplicationIcon (icon root name, i.e. omit extension) <Linux> InstallerWindowIcon (.png name, with extension) Title TitleColor (HTML color code, such as \"#88FF33\") ControlScript TargetDir StartMenuDir RunProgram RunProgramDescription WizardStyle WizardDefaultWidth WizardDefaultHeight Logo Banner ProductUrl runProgramArgList (used indirectly) otherElements (open ended dictionary of key/value pairs to inject) Functions: setPrimaryContentExe( ifwPackage ) setDefaultVersion() setDefaultTitle() setDefaultPaths() addCustomTags( root ) write() debug() toPrettyXml() exists() path() dirPath() Static Constants: DEFAULT_WIZARD_STYLE WizardStyle.AERO <Windows Default> WizardStyle.MAC <MacOS Default> WizardStyle.MODERN <Linux Default> WizardStyle.CLASSIC <Simliar to MODERN>","title":"QtIfwConfigXml"},{"location":"ConfigClasses.html#qtifwcontrolscript","text":"QtIfw installers may have a \u201cControl Script\u201d and/or a collection of \u201cPackage Scripts\u201d. The \u201cControl Script\u201d is intended to dictate how the installer interface behaves, and other high level logic pertaining to the installer itself. In contrast, \u201cPackage Scripts\u201d are intended for applying custom logic to manipulate a target environment when installing a given package. See QtIfwPackageScript for more info. The QtIfwControlScript class provides an abstraction layer for QtIfw script generation. QtIfw scripts are written in Qt Script (which is conceptually a spin off from JavaScript), with additional custom objects and methods for this context. Using this abstraction, you can achieve a great many custom behaviors without having to learn much about the language yourself. Refer to the details on Installer Scripting to learn more about the low level helpers provided by the library for this purpose. For maximum flexibility, rather than using the dynamic methods, you may directly define the entire script via a raw string, by setting the script attribute. Or, you may specify an external file as the source instead via script_path . In addition, you may always delegate scripts to a traditional QtIfw definition by using a higher level configuration QtIfwConfig to specify such. The way this class works, in summary, is that you may provide an optional script as a raw string, or a path to script you wish to load directly. If specified, those resources act as a base , from which you may continue to add on to. A QtIfw control script is \u201cdriven\u201d by the builtin framework. When a given \u201cevent\u201d occurs a \u201chandler\u201d function is invoked (if it has been defined). QtIfwControlScript object has a set of attributes related to each page and such event/handler pair in the framework. One is a boolean, controlling the \u201cvisibility\u201d of the page. Setting that to False skips over that wizard page entirely. Another boolean is provided, dictating whether to auto generate the event handler using a set of fixed, built-in logic provided by distbuilder to add a notable amount of additional features to your installers \u201cfor free\u201d. The final attribute in this pattern is the body of the event handler (normally auto generated), which allows for an atomic replacement of that code. When the write() function is invoked, the actual script file to be embedded in the installer is generated from the attributes. Prior to calling that, you may switch off the various auto generate options, and supply your own function definition from scratch. If you wish to use the bulk of the \u201cfree\u201d / standard add on logic, but then customize that the program flow should be to call _generate() first, which will define the function bodies using the auto generate options. Once that is done, you may disable select auto generates, and then directly add on to, or manipulate the event handling function bodies. A large number of abstract, static \u201chelper\u201d functions have been provided which you may use to build your logic. Otherwise, you may certainly just add Qt Script snippets directly in the raw. See Installer Scripting . The virtualArgs attribute is a dictionary, containing key/values which allows for hard coding Standard Installer Arguments into the installer, which are typically passed at runtime via the command line. Constructor: QtIfwControlScript( fileName=\"installscript.qs\", script=None, scriptPath=None, virtualArgs={} ) : Attributes & default values: isLimitedMaintenance = True virtualArgs = virtualArgs uiPages = [] widgets = [] controllerGlobals = None isAutoGlobals = True controllerConstructorBody = None controllerConstructorInjection = None isAutoControllerConstructor = True onPageChangeCallbackBody = None onPageChangeCallbackInjection = None isAutoPageChangeCallBack = True onFinishedClickedCallbackBody = None onFinishedClickedCallbackInjection = None isAutoFinishedClickedCallbackBody = True onPageInsertRequestCallbackBody = None isAutoPageInsertRequestCallBack = True onPageRemoveRequestCallbackBody = None isAutoPageRemoveRequestCallBack = True onPageVisibilityRequestCallbackBody = None isAutoPageVisibilityRequestCallBack = True onValueChangeCallbackBody = None onValueChangeCallbackInjection = None isAutoValueChangeCallBack = True isIntroductionPageVisible = True introductionPageCallbackBody = None introductionPageOnInstall = None introductionPageOnMaintain = None isAutoIntroductionPageCallback = True isTargetDirectoryPageVisible = True targetDirectoryPageCallbackBody = None isAutoTargetDirectoryPageCallback = True isComponentSelectionPageVisible = True componentSelectionPageCallbackBody = None componentSelectionPageInjection = None isAutoComponentSelectionPageCallback = True isLicenseAgreementPageVisible = True licenseAgreementPageCallbackBody = None isAutoLicenseAgreementPageCallback = True isStartMenuDirectoryPageVisible = True startMenuDirectoryPageCallbackBody = None isAutoStartMenuDirectoryPageCallback = True isReadyForInstallationPageVisible = True readyForInstallationPageCallbackBody = None readyForInstallationPageOnInstall = None readyForInstallationPageOnMaintain = None isAutoReadyForInstallationPageCallback = True isPerformInstallationPageVisible = True performInstallationPageCallbackBody = None isAutoPerformInstallationPageCallback = True isFinishedPageVisible = True finishedPageCallbackBody = None finishedPageOnInstall = None finishedPageOnMaintain = None isAutoFinishedPageCallback = True isRunProgVisible = True isRunProgEnabled = True isRunProgChecked = True Object Methods: registerAsyncFunc ( func ) < takes QtIfwAsyncFunc > registerStandardEventHandler ( signalName , slotName , slotBody ) registerAutoPilotEventHandler ( signalName , slotName , slotBody ) registerGuiEventHandler ( signalName , slotName , slotBody ) registerWidgetEventHandler ( pageId , controlName , signalName , slotName , slotBody ) _generate () write () debug () exists () path () dirPath ()","title":"QtIfwControlScript"},{"location":"ConfigClasses.html#qtifwpackage","text":"Objects of this type define the packages with an installer. A QtIfwConfig contains a list of these. Notably, these package objects define the source content to be included in the installer via srcDirPath or simply srcExePath attributes. They also contain QtIfwPackageXml and QtIfwPackageScript objects, for extended configuration details. Constructor: QtIfwPackage( pkgId=None, pkgType=None, name=None, subDirName=None, srcDirPath=None, srcExePath=None, resBasePath=None, isTempSrc=False, pkgXml=None, pkgScript=None, licenses={}, uiPages=[], widgets=[] ) Attributes: <internal id / type> pkgId = None pkgType = None <QtIFW definition> name = None pkgXml = None pkgScript = None uiPages = [] widgets = [] licenses = {} <in the form name:filePath> isLicenseFormatPreserved = False <source content> srcDirPath = None <package ENTIRE source directory> srcExePath = None resBasePath = None distResources = None isTempSrc = False <destination content> subDirName = None exeName = None exeWrapper = None <other configuration details> isGui = False codeSignTargets = None <list of relative paths within package> qtCppConfig = None Functions: dirPath() metaDirPath() contentTopDirPath() contentDirPath() Static Functions: topDirPath()","title":"QtIfwPackage"},{"location":"ConfigClasses.html#qtifwpackagexml","text":"Objects of this type define the a QtIFW package.xml file which will be dynamically generated when invoking the buildInstaller function. This file defines a component within the installer which maybe selected by the user to install. Most of the attributes in these objects correspond directly to the name of tags added to the xml. Attributes set to None values will not be written, otherwise they will be. Constructor: QtIfwPackageXml( pkgName, displayName, description, version, scriptName=None, isDefault=True, isRequired=False, isHidden=False, isCheckable=True ) Attributes & default values: pkgName = <required> SortingPriority = None DisplayName = <required> Description = <required> Version = <required> Script = None ReleaseDate = date.today() Default = True ForcedInstallation = False <isRequired> Virtual = False <isHidden> Checkable = True Dependencies = None AutoDependOn = None UserInterfaces = [] Licenses = [] Functions: addCustomTags( root ) write() debug() toPrettyXml() exists() path() dirPath()","title":"QtIfwPackageXml"},{"location":"ConfigClasses.html#qtifwpackagescript","text":"QtIFW installers may have a \u201cControl Script\u201d and/or a collection of \u201cPackage Scripts\u201d. The \u201cControl Script\u201d is intended to dictate how the installer interface behaves, and other high level logic pertaining to the installer itself. In contrast, \u201cPackage Scripts\u201d are intended for applying custom logic to manipulate a target environment when installing a given package. See QtIfwControlScript for more info. Objects of the type QtIfwPackageScript are used to dynamically generate a script used by a QtIFW package. Refer to the details on Installer Scripting to learn more about the low level helpers provided by the library for this purpose. For maximum flexibility, rather than using the dynamic methods, you may directly define the entire script via a raw string, by setting the script attribute. Or, you may specify an external file as the source instead via script_path . In addition, you may always delegate scripts to a traditional QtIFW definition by using a higher level configuration QtIfwConfig to specify such. This class works in an analogous manner to QtIfwControlScript . Please refer to the that documentation for an explanation of how use these script objects in general. Note that for this class QtIfwShortcut objects are used for the shortcuts attribute, QtIfwExternalOp objects are used for externalOps , and QtIfwKillOp objects are used for killOps . Constructor: QtIfwPackageScript( pkgName, pkgVersion, pkgSubDirName=None, shortcuts=[], bundledScripts=[], dynamicTexts={}, externalOps=[], installResources=[], uiPages=[], widgets=[], fileName=\"installscript.qs\", script=None, scriptPath=None ) Attributes & default values: pkgName = < required > pkgVersion = < required > pkgSubDirName = None fileName = \"installscript.qs\" script = None < or loaded via scriptPath > shortcuts = [] bundledScripts = [] dynamicTexts = {} fileName : content externalOps = [] installResources = [] killOps = [] preOpSupport = None customOperations = None < LINUX / MAC only > externalDependencies = [] areDependenciesPreserved = True uiPages = [] widgets = [] packageGlobals = None isAutoGlobals = True componentConstructorBody = None isAutoComponentConstructor = True componentLoadedCallbackBody = None isAutoComponentLoadedCallback = True componentCreateOperationsBody = None isAutoComponentCreateOperations = True componentCreateOperationsForArchiveBody = None isAutoComponentCreateOperationsForArchive = True < Linux Only > isAskPassProgRequired = False Methods addSimpleOperation( name, parms=[], isElevated=False, isAutoQuote=True ) addSimpleOperation : Appends a QScript snippet to be appended to the customOperations attribute. The available operations are documented on https://doc.qt.io/qtinstallerframework/operations.html . Note that these operations implicitly occur during installation, have implicit \u201cundo\u201d operations (where possible), and cannot be made to occur specifically during an install vs update vs uninstall. They are, however, cross platform and relatively painless to implement. For more flexibility, use QtIfwExternalOp objects. (The draw back to such is you will need to call upon / include utilities or add ExecutableScripts containing platform specific code.","title":"QtIfwPackageScript"},{"location":"ConfigClasses.html#qtifwshortcut","text":"These shortcut objects are use by QtIfwPackageScript objects, to create shortcuts on the installation target environments. Constructor: QtIfwShortcut( productName=QT_IFW_PRODUCT_NAME, command=None, args=[], exeDir=QT_IFW_TARGET_DIR, exeName=None, exeVersion=\"0.0.0.0\", isGui=True, pngIconResPath=None ) Attributes & default values: productName = \"@ProductName@\" < QtIfw Built - in Variable > command = None exeDir = \"@TargetDir@\" < QtIfw Built - in Variable > exeName = None args = None isGui = True < used in Mac / Linux > windowStyle = None < used in Windows > exeVersion = \"0.0.0.0\" < used in Linux > pngIconResPath = None < used in Linux > isAppShortcut = True isDesktopShortcut = False isAdjancentShortcut = False","title":"QtIfwShortcut"},{"location":"ConfigClasses.html#qtifwexternalop","text":"This class is used to represent and control the invocation of shell commands, external utilities, and embedded ExecutableScripts . It is employed by QtIfwPackageScript to add operations to the installation, and/or uninstallation, process of the package to which those operations are associated. This simple example (for *nix based systems), may serve well to clarify how this class is intended to be used: filePath = joinPathQtIfw ( QT_IFW_HOME_DIR , \"test.txt\" ) createFileOp = QtIfwExternalOp ( exePath = \"touch\" , args =[ filePath ] , uninstExePath = \"rm\" , uninstArgs =[ filePath ] ) pkg . pkgScript . externalOps = [ createFileOp ] This purpose of this class should not be confused with the Installer Scripting function execute( binPath, args ) . While that is also a means to invoke sub processes and shell commands from QtIWF, that is more generally used in a \u201cController scripting\u201d context for on demand, often conditional and/or dynamic needs. More to the point, QtIfwExternalOp objects are bound directly to packages and to install/uninstall events, where the QtScript execute function can be dropped into installation scripts anywhere, in an unrestricted manner. Note the intended design by Qt for creating sophisticated, cross platform, custom operations is to modify to the installer engine itself, writing in Qt C++, and recompile it yourself for a specific platform. See: https://doc.qt.io/qtinstallerframework/scripting.html#registering-custom-operations If you really want to do that, here\u2019s the source you\u2019ll require: https://github.com/qtproject/installer-framework It is the opinion of the distbuilder developers that this typically going to be an absurdly complicated and time consuming endeavor for most use cases. This \u201cexternal operation\u201d mechanism, while having draw backs is likely a good deal more practical! Constructor: QtIfwExternalOp( script=None, exePath=None, args=[], successRetCodes=[0], uninstScript=None, uninstExePath=None, uninstArgs=[], uninstRetCodes=[0], isElevated=False, workingDir=QT_IFW_TARGET_DIR, onErrorMessage=None, resourceScripts=[], uninstResourceScripts=[], externalRes=[] ) Attributes & default values: script = None exePath = None args = [] successRetCodes = [0] uninstScript = None uninstExePath = None uninstArgs = [] uninstRetCodes = [0] isElevated = False workingDir = QT_IFW_TARGET_DIR onErrorMessage = None resourceScripts = [] uninstResourceScripts = [] externalRes = [] Notes: QtIfw will execute these operations synchronously. By default, if the return code from the sub process is not 0, this is treated as an installation error. To expand the options for what is viewed as a \u201csuccess\u201d, or can at least be ignored, the attributes successRetCodes , and uninstRetCodes , allow specifying lists of codes for either the installation or uninstallation processes, respectively. The QtIfwPackageScript attribute externalOps is a list to be executed in order. Note that during uninstallation, that list is processed in reverse order . It is possible (and common), to define operations as only for installation or only for uninstallation. Having direct counterparts is not required. When defining an externalOps list with \u201cpure uninstallation\u201d actions, you should especially keep the reverse order of such operations in mind. resourceScripts, uninstResourceScripts : Lists of additional ExecutableScripts to make available on the target, for this operation to draw upon. To reference the script, build a path using the python constant QT_IFW_SCRIPTS_DIR or from directly within another script use @ScriptsDir@ . externalRes : A list of QtIfwExternalResource objects. Tools defined this list will be rolled into the installer without explicitly updating the QtIfwPackageScript owner of this operation object.","title":"QtIfwExternalOp"},{"location":"ConfigClasses.html#qtifwkillop","text":"This class is used to drive process killing operations. Such actions are frequently useful prior to installing or uninstalling software, especially when it comes to instances of the target programs themselves. This class is employed by QtIfwPackageScript , and is internally used to actually generate and inject QtIfwExternalOp objects. Constructor: QtIfwKillOp( processName, onInstall=True, onUninstall=True ): Attributes & default values: proc es sName = < required > onInstall = True onUninstall = True isElevated = True Notes: Kill operations are performed prior to any others during either on install or uninstall process. ALL processes with the given processName will be forcefully terminated. For convenience, instead of passing the explicit name the of process, you may instead pass a QtIfwPackage . In which case, the name of the \u201cprimary executable\u201d will be automatically extracted from that.","title":"QtIfwKillOp"},{"location":"ConfigClasses.html#qtifwexternalresource","text":"This class provides as a means to include \u201cresources\u201d (e.g. third party utility programs), in the installer which are not part of the product or intended for direct use by an end user. Such resources may then be utilized by your package script operations. These objects are typically added to in the externalRes attribute of QtIfwExternalOp objects, which in turn are utilized by QtIfwPackageScript objects. By default, such resources will be extracted into a temporary location on the target and removed at the end of installation. If you will require any for maintenance operations (i.e. during updates or uninstallation), enabling the isMaintenanceNeed attribute will cause the resource to be retained on the target, so it will be available later when needed. Constructor: QtIfwExternalResource( name, srcPath, srcBasePath=None, isMaintenanceNeed=False, contentKeys={} ) Object Attributes & default values: name = <required> srcPath = <required> srcBasePath = None isMaintenanceNeed = False contentKeys = {} Object Methods: targetPath( key=None ) targetDirPath() targetPathVar( key=None ) targetDirPathVar() Static Methods: BuiltIn( name, isMaintenanceNeed=False ) Built In Windows Resource Names: RESOURCE_HACKER http://www.angusj.com/resourcehacker/ name : The base id by which to reference the resources and to name a target container directory. srcPath : The path to the resources file or directory . This may be absolute or relative. srcBasePath : If using a relative srcPath , you may override the base path with this. isMaintenanceNeed : Enabling this will cause the resource to be retained on the target, so it will be available for the maintenance tool / uninstaller. contentKeys : A dictionary of key/value pairs to be registered in the installer, allowing you to dynamically access the paths within scripts on your target. If this detail is omitted during construction, and your QtIfwExternalResource contains only one file, a key will be automatically registered for you as the name of the object. targetPath( key ) : Use this to reference the resource paths when generating QtScripts / operations which will utilize it. Specify the key as registered via contentKeys . If you omit the key when calling this, and only one key exists (such as when bundling a single file), that default key will be implied. targetDirPath() : In the event you need to access the container directory for the tool, e.g. to change your working directory to it, you may employ this method. targetPathVar( key=None ), targetDirPathVar() : The place holders / variable names to use inside an ExecutableScript to refer to these paths. Assuming a key is valid, you could also just hardcode it like @key@ rather than call targetPathVar( key=None ) to get that back! QtIfwExternalResource.BuiltIn : Convenience method to bundle tools into an installer which are included with the library.","title":"QtIfwExternalResource"},{"location":"ConfigClasses.html#qtifwexewrapper","text":"This class provides a means to \u201cwrap\u201d your exe inside of additional external layers. Such layers may take different forms, and be nested inside of one another. The benefit of this is to impose a specific environment and or set of parameters onto the exe without having to modify it internally. These options work cross platform, and could be slapped over the top of a program written in any language. You may, in fact, even wrap third-party (pre-compiled) programs in these layers! The easiest way to use this class is to set some of its basic attributes. For example, workingDir , isElevated , envVars , or args . The approach taken by the library is to use the \u201clightest touch\u201d possible. If you simply changed the default values for those example attributes, their shortcuts (on applicable platforms) and the way QtIFW would run the program post installation, would be altered to provided the functionality. The most flexible attribute you may impose is a wrapperScript layer. This is an ExecutableScript object, used to produce a persistent \u201ccompanion\u201d to your binary. Executing the script rather then the binary itself would be the intended means for launching the program. If this attribute is set, \u201cshortcuts\u201d which would normally point a user to the binary, will instead run this wrapper layer. On Windows, this (normally) equates to having a batch file companion. On Linux, a shell script companion is created (with an explicit .sh extension). On macOS, a shell script with no extension is embedded into the .app file when producing a gui application, else the same design used on Linux is employed for non-gui programs. The application of a wrapper script of this nature is not entirely uncommon - especially on Linux. As an example, when deploying Qt C++ applications on Linux which are dynamically linked, the standard procedure (per Qt documentation) is to use this (slightly modified) shell script to load the required libraries: 1 2 3 4 5 6 7 8 9 10 #!/bin/sh appname = ` basename \" $0 \" | sed s, \\. sh$,, ` dirname = ` dirname \" $0 \" ` tmp = \" ${ dirname #? } \" if [ \" ${ dirname % $tmp } \" ! = \"/\" ] ; then dirname = \" $PWD / $dirname \" fi LD_LIBRARY_PATH = \" $dirname \" export LD_LIBRARY_PATH \" $dirname / $appname \" \" $@ \" Other ways for using a wrapper like this include automatically detecting dependencies, and then downloading and installing them as needed. Or, doing something similar for updates to your software. Using a wrapper, you could launch a \u201ccompanion application\u201d along side the primary target. You could start a background service, or open help documentation\u2026 The possibilities are really boundless. Note: On Windows and Linux desktops (e.g. Ubuntu) for a gui application with shortcuts , the \u201cbuilt-in wrapper\u201d features ( workingDir , isElevated , envVars , args ) maybe used in combination with a custom wrapperScript . I.e. those options will be applied via the shortcut launching the script OR the executable. If you need the wrapper to work without a shortcut involved, you will have to manually include these other features in the script. On macOS , this will always be applicable because there is no \u201cshortcut\u201d involved. To add these details yourself, you may wish to first use the built-in attributes without the custom script, then copy what is written to the auto generated script into your own. Alternately, you could programmatically manipulate the wrapperScript attribute referencing an ExecutableScript generated for you by this class upon it\u2019s construction (or upon a call to refresh() ). On WINDOWS ONLY : You may optionally enable the isExe flag. Rather than a batch file, this will produce a proxy exe, which will live adjacent to the target it wraps. The icon and version / branding info from the original will be injected into it. Constructor: QtIfwExeWrapper( exeName, isGui=False, wrapperScript=None, exeDir=QT_IFW_TARGET_DIR, workingDir=None, args=None, envVars=None, isElevated=False, isExe=False ) Attributes & default values: exeName = < required > isGui = False wrapperScript = None exeDir = \"@TargetDir@\" < QtIfw Built - in Variable > workingDir = None < None = don ' t impose here , use QT_IFW_TARGET_DIR via other means > args = None envVars = None isElevated = False < Windows only > isExe = False wrapperExeName = \"<exeName>Launcher\" wrapperIconName = \"0.ico\" _winPsStartArgs = None < Auto defined via refresh > _runProgram _runProgArgs _shortcutCmd _shortcutArgs _shortcutWinStyle Functions: refresh()","title":"QtIfwExeWrapper"},{"location":"ConfigClasses.html#qtifwonfinisheddetachedexec","text":"This class defines an action to be invoked upon completing the wizard. It will launch a detached / asynchronous process when the user clicks the \u201cFinished\u201d button (which may occur virtually within a silent installer). Such actions may be invoked on installation, uninstallation, or both. While working independently from it, this class is closely related to QtIfwOnFinishedCheckbox . This class provides the framework for the core functionally, while that one contributes UI dimensions. Constructor: QtIfwOnFinishedDetachedExec( name, event=None, ifwPackage=None, runProgram=None, argList=None, shellCmd=None, script=None, openViaOsPath=None, isReboot=False, rebootDelaySecs=2, ifCondition=None ) onLoad=None, onEnter=None ) Attributes: name = name <QtIfwOnFinishedDetachedExec.ON_INSTALL / ON_UNINSTALL / ON_BOTH> event = ON_INSTALL runProgram = None argList = None script = None isReboot = isReboot ifCondition = None <QtScript snippet> _action = <auto defined> Details: ifCondition : Controls whether to invoke this action via QtScript. Note, this feature is not applied by the derived class QtIfwOnFinishedCheckbox. That class invokes the corresponding action if the checkbox is selected.","title":"QtIfwOnFinishedDetachedExec"},{"location":"ConfigClasses.html#qtifwuipage","text":"This class closely resembles QtIfwWidget . They internally derive from a common (protected) base class. In contrast, however, QtIfwWidgets are collections of user interface elements to be injected into default wizard pages, where QtIfwUiPages are entirely new steps/pages injected between (or over ) default wizard pages. A great deal can be done to customize the way an installer\u2019s interface works by simply adding custom widgets. There are limitations, however, to that approach. This class is used to completely add or overwrite pages in the an installer. The content of the pages are defined as Qt \u201cforms\u201d, i.e. .ui (xml) files which adhere to the Qt UI file format . While it is possible to manually create such forms, typically such files are machine generated using a WYSIWYG tool from within Qt Creator or Qt Designer . Constructor: QtIfwUiPage( name, pageOrder=None, sourcePath=None, content=None, onLoad=None, onEnter=None ) Attributes: name = <required> pageOrder = None content = None replacements = {} onLoad = None onEnter = None eventHandlers = {} supportScript = None isIncInAutoPilot = False _isOnLoadBase = True _isOnEnterBase = True Functions: fileName() resolve( qtIfwConfig ) write( dirPath ) Details: name : This identifier will be used to name a .ui file containing the form, and to reference the page widget within any scripting. If you wish to replace a default page, set the name for an object of this type to QT_IFW_REPLACE_PAGE_PREFIX concatenated with one of the following page name constants: QT_IFW_INTRO_PAGE QT_IFW_TARGET_DIR_PAGE QT_IFW_COMPONENTS_PAGE QT_IFW_LICENSE_PAGE QT_IFW_START_MENU_PAGE QT_IFW_READY_PAGE QT_IFW_INSTALL_PAGE QT_IFW_FINISHED_PAGE Conversely, to add a new page, give it some other name and specify the pageOrder using one the constants above. pageOrder : If not a replacement, the page will be added added BEFORE this specified page. onLoad : Qt Script snippet invoked when loading the page into memory. This is executed within a package script, when then \u201ccomponent\u201d is constructed. It\u2019s scope therefore is limited to such, and it cannot call functions defined in the controller script . UI page resources are contained within packages, which is why they are loaded and configured from there. onEnter : Qt Script snippet invoked upon entering / displaying the page to the user. This is executed within a controller script, it\u2019s scope is limited to such. Therefore, package script functions and globals are not available here. isIncInAutoPilot : This attribute is only applied when the page is not a replacement. Note, this is False by default. Set this to True , to load this \u201cadditional\u201d page when running in \u201cauto pilot mode\u201d (e.g. within a Silent Installer context. It is then on you to ensure that alternate installation mode functions as desired. See _isOnEnterBase . _isOnLoadBase : Protected Note, this is enabled by default. When this is set to True , an auto generated script will be added to the installer, which will execute prior to onLoad . This \u201cbase\u201d script will dynamically resize the page, so it fits properly on each alternate platform\u2019s version of the installer. It is recommended you leave this in place, unless you are overwriting it. Having this in place will additionally create a var page , which refers to this page. The onLoad script may then make use of that variant to access the page widget or the child widgets on it. See Installer Scripting _isOnEnterBase : Protected Note, this is enabled by default. When this is set to True , an auto generated script will be added to the installer, which will execute prior to onEnter . This \u201cbase\u201d script will automatically \u201cclick\u201d the \u201cNext\u201d button upon displaying the page, when running in \u201cauto pilot mode\u201d (e.g. within a Silent Installer context. Having this in place will additionally create a var page , which refers to this page. The onEnter script may then make use of that variant to access the page widget or the child widgets on it. See Installer Scripting eventHandlers : Qt Script simple \u201cevent handler\u201d dictionary containing entries in the form: name:body. The typical use case for this attribute involves the onLoad script connecting events (e.g. button clicks) to handlers. The eventHandlers then provide the definitions for what to do upon event occurrences. (Note: These are defined within a package script, but are controller.prototypes .) Note this uses the Qt signal/slot mechanism for built-in widget types. You must add your own \u201cconnections\u201d, via the Qt Script rules for such (again typically within your onLoad ). An example of that would look like: page.mybutton.released.connect(this, this.myhandler); . supportScript : A completely open ended Qt Script (string) attribute, for injecting any additional support/helper function definitions which maybe handy. Note that these will live in the global space of the controller script. Be careful to avoid name conflicts! replacements : A dictionary containing entries in the form: placeholder:value. Upon writing the .ui file for the installer definition the library the generates, all \u201creplacements\u201d in the content will be resolved. TODO: further explain the complicate logic for page order (for replacement pages, or multiple pages with the same order\u2026). Also elaborate on ui replacements, the \u201cresolve\u201d function, provide a base example .ui in the docs\u2026","title":"QtIfwUiPage"},{"location":"ConfigClasses.html#qtifwwidget","text":"This class closely resembles QtIfwUiPage . They internally derive from a common (protected) base class. In contrast, however, QtIfwWidgets are collections of user interface elements to be injected into default wizard pages, where QtIfwUiPages are entirely new steps/pages injected between (or over ) default wizard pages. Note that a QtIfwWidget that you create and inject into a page will generally contain other widgets. To access the nested widgets in a QtScript, you would use the notation page.parent.child . The content of the widgets are defined as Qt \u201cforms\u201d, i.e. .ui (xml) files which adhere to the Qt UI file format . While it is possible to manually create such forms, typically such files are machine generated using a WYSIWYG tool from within Qt Creator or Qt Designer . Constructor: QtIfwWidget( name, pageName, position=None, sourcePath=None, content=None, onLoad=None, onEnter=None ) Attributes: name = <required> pageName = <required> position = None content = None replacements = {} onLoad = None onEnter = None eventHandlers = {} supportScript = None _isOnLoadBase = True _isOnEnterBase = True Functions: fileName() resolve( qtIfwConfig ) write( dirPath ) pageName : The wizard page where the widget will be added. position : 0 based index where the widget will be injected onto the page. Injections occur at the bottom of the default page, below the default elements. (per Qt\u2019s design). onEnter : Qt Script snippet invoked upon entering / displaying the page to the user. This code will be invoked AFTER the initial \u201cpage call back\u201d on which the widget was injected. To modify those page call backs instead, see QtIfwControlScript .","title":"QtIfwWidget"},{"location":"ConfigClasses.html#pipconfig","text":"Objects of this type define the details for downloading and/or installing Python libraries via the pip utility. These objects are used directly by the installLibrary function as well indirectly via the obfuscation functions and support classes. Constructor: PipConfig( source = None , version = None , verEquality = \"==\" , destPath = None , asSource = False , incDependencies = True , isForced= False , isCacheUsed = True , isUpgrade = False , otherPipArgs = \"\" ) Attributes: pipCmdBase = \"[PYTHON BINARY PATH]\" -m pip source version verEquality destPath asSource incDependencies isForced isCacheUsed isUpgrade otherPipArgs (open ended argument string) TODO: Expand on this considerably\u2026 The source attribute is the the \u201cheart\u201d of this class. It can take many different forms. Including library names registered at PyPi, local paths, and urls. Other Notable attributes include incDpndncsSwitch , destPath and asSource . These allow you to skip dependency gathering if desired, install to a specific path such as a temp build directory, and to request raw .py scripts be placed there. Note that remote raw pip packages will require an alternate vcs url be supplied to a \u201cdevelopment\u201d repository in place of the simple package name as the source attribute. See editable installs","title":"PipConfig"},{"location":"ConfigClasses.html#opyconfig","text":"Objects of this type define obfuscation details for use by the Opy Library. Refer to the documentation for that library for details. This library EXTENDS the natural OpyConfig, however, adding the attributes / features described below. See Obfuscation Features for a description of how objects of this type are used. Constructor: OpyConfig( name, entryPointPy=None, bundleLibs=None, sourceDir=None, patches=None ) Attributes: name entryPointPy bundleLibs (list of LibToBundle objects) sourceDir (dynamically defined when ommited) patches (list of OpyPatch objects)","title":"OpyConfig"},{"location":"ConfigClasses.html#opypatch","text":"See Obfuscation Features for a description of how objects of this type are used. Constructor: OpyPatch( relPath, patches, parentDir=OBFUS_DIR_PATH ) Attributes: relPath path patches Functions: obfuscatePath( obfuscatedFileDict ) apply()","title":"OpyPatch"},{"location":"ConfigClasses.html#libtobundle","text":"See Obfuscation Features for a description of how objects of this type are used. Constructor: LibToBundle( name, localDirPath=None, pipConfig=None, isObfuscated=False ) Attributes: name localDirPath pipConfig isObfuscated","title":"LibToBundle"},{"location":"Contribute.html","text":"Contact / Contribute \u00b6 Join GitHub \u00b6 If you wish to report bugs, make request features, or contribute to this project, please join GitHub . Post An Issue \u00b6 Once you have a GitHub account, you can post an issue for this project. Contribute Code \u00b6 If you wish to contribute code, create your own fork from distbuilder . After that, git clone your fork, and push the commits. Finally, issue a pull request . Upon review, your contribution maybe merged into the official project.","title":"Contact / Contribute"},{"location":"Contribute.html#contact-contribute","text":"","title":"Contact / Contribute"},{"location":"Contribute.html#join-github","text":"If you wish to report bugs, make request features, or contribute to this project, please join GitHub .","title":"Join GitHub"},{"location":"Contribute.html#post-an-issue","text":"Once you have a GitHub account, you can post an issue for this project.","title":"Post An Issue"},{"location":"Contribute.html#contribute-code","text":"If you wish to contribute code, create your own fork from distbuilder . After that, git clone your fork, and push the commits. Finally, issue a pull request . Upon review, your contribution maybe merged into the official project.","title":"Contribute Code"},{"location":"Examples.html","text":"Examples \u00b6 Source Code / Resources \u00b6 All of the examples discussed here are included in the \u201csource distribution\u201d of the library. The PyPi downloads page for this project is arguably the fastest route to acquire that. See From source installation to learn about other ways of downloading these files. Hello World Example \u00b6 The Hello World Example is a simple demonstration of using the PyToBinPackageProcess class. This is one of the most straightforward, simple use cases for the library. If you did not download the full source for the library (inclusive of the examples) you may download/copy the following individual files directly from GitHub into a local directory. It is recommended that you place them in a directory named hello_world . Example program: hello.py Build script: build.py Example resource: LICENSE Start by confirming you can run the program script in the \u201cnatural\u201d manner: python hello.py Don\u2019t expect it to do much\u2026 It simply writes \u201cHello World!\u201d to the console. Now, run the build script: python build.py The build script should achieve the following: converts the Python script to a stand-alone executable binary bundles the example resource (license file) into a directory with the binary compresses the distribution into a simple zip file (left in the same directory as the source) Having witnessed that function, review the build.py script for yourself. It should be self-explanatory for a moderately seasoned Python developer. Hello World Tk Example \u00b6 This next example is a more comprehensive version of the first Hello World. It is a demonstration of using the PyToBinInstallerProcess class. Note: This example requires the standard Python TKinter library be installed. You may download/copy the following individual files directly from GitHub into a local directory. It is recommended that you place them in a directory named hello_world_tk . Example app: hello.py Build script: build.py Windows resource: demo.ico Mac resource: demo.icns Linux resource: demo.png Start by confirming you can run the program script in the \u201cnatural\u201d manner: python hello.py The program is a single button GUI. Clicking the button writes \u201cHello World!\u201d to the console. Now, run the build script: python build.py The build script should achieve the following: obfuscates the code (to mitigate the risk of reverse engineering) converts the obfuscated version of the source to a stand-alone executable builds a full installer with the executable bundled into it moves the installer to your desktop (for convenience) launches the installer (for testing) Proceed through the installer, and then run the program to confirm it works. Having witnessed everything function, review the build.py script. The script is a simple example, but covers a good portion of the \u201ccore\u201d distbuilder features. Feature spotlight: \u201cfile name normalization\u201d \u00b6 You might notice that binary names/paths (in any of the examples) may or may not include extensions such as .exe . Likewise, icons may or may not have extensions such as .ico specified. Yet, these scripts work cross platform, where the extensions differ! That is due to the use of normBinaryName and normIconName functions under the hood of distbuilder\u2019s processes. The library corrects those names for you automatically based upon the environmental context. Currently, alternate icon resources must be provided which align with the platform context. There are plans, however, for future releases of the library to generate missing icon formats for you as needed. Extended feature demo: \u201cdebug mode\u201d \u00b6 Here is a good place to illustrate one very useful extended feature of this library, which may prove immeaditely valuable to you. This is will also help you to understand a common pattern for using some of the primary distbuilder classes. Locate the following commented out line in the Hello World Tk build script: #def onPyPackageProcess( self, prc ): prc.isExeTest = True Uncomment that, and run the build process again. In the middle of the process, the standalone binary will be run for you in \u201cdebug\u201d mode. Upon closing the program, the rest of the build process will continue. This code demonstrates a design pattern employed by the \u201chigh level\u201d process classes in distbuilder. That pattern is for a high level class to generate a \u201cconfiguration object\u201d, or a lower level \u201cprocess object\u201d, automatically set it up for the client implementation, and then \u201cpass it through\u201d an overridable function where you may access such and revise it for your own needs prior to its use. So, what\u2019s the point of setting prc.isExeTest = True ? If you have run this example program, the most astute observer may notice (on Windows or Mac, but not Linux\u2026) that the stdout/err messages (seen by clicking the \u201cHello Tkinter\u201d button when running the raw .py script) are not produced on the terminal by the standalone version of the program when it is launched in the normal manner. That is due to a feature of PyInstaller (and/or by additional platform details regarding standard output streams) to \u201cswallow\u201d console messages produced by gui applications. That may be desired behavior for a public release, but it may be also be highly counterproductive for debugging, since there are times when the standalone version may require specialized coding to make it work correctly in that context compared to how it did as a basic .py script. As such, distbuilder has included a solution for this, as demonstrated here. Refer to Testing for more details. Hello Dynamic Ini Example \u00b6 TODO: FILL IN! Hello Silent Example \u00b6 It is another demonstration of using the PyToBinInstallerProcess class. Hello Silent demonstrates how one can use distbuilder to build \u201csilent\u201d installers. These do not require user interactions for them to complete their tasks. Instead, they run automatically, while having the same flexible options present in the gui installers made available via command line arguments. \u201cSilent\u201d installers built by distbuilder provide a very important additional feature. They are able to be run in non-gui contexts , such as on \u201cheadless servers\u201d. Silent installers are, of course, also desirable (on any platform) for mass installation purposes such as when a network administrator needs to install the same program on countless workstations. Building a silent installer requires nothing more than setting the isSilentSetup configuration option to True . As such, you can easily define a full blown packaging and installation process that could be run in Windows (for example) using an interactive graphical interface, AND could also be used on a CentOS server (for example), with nothing but a terminal interface available. You would only have to toggle the isSilentSetup option before running the build script! This example expects that you already downloaded the first example (Hello World). That must be present in the testing environment within a directory adjacent to where you place the next file. That first directory must be named hello_world for this \u201cmaster\u201d script (which draws upon that) to function. You may download/copy the example file directly from GitHub (into a hello_silent directory): Build script: build.py Upon building the silent installer, the demo is set to test \u201cAuto Installation\u201d of it. With that enabled, it will run the installer with the command line argument to \u201cforce installation\u201d. If run more than once, that option will cause it to uninstall any prior existing installation rather than exiting with an error, as it would do by default when a conflict was detected. For more information, refer to Silent Installers . Hello Multi-Package Examples \u00b6 Hello Packages Example \u00b6 The Hello Packages Example is a demonstration of using the RobustInstallerProcess class. It demonstrates a way that you can generate and then \u201ccombine\u201d multiple \u201cpackages\u201d into a single installer with a single build process. In this case, those become separate components which may be installed selectively by the end user. This example requires that both of the first examples (Hello World & Hello World Tk) be present in the testing environment within directories adjacent to a third directory where you place the next file. Those first two must be named hello_world and hello_world_tk for this \u201cmaster\u201d script to function. You may download/copy the example file directly from GitHub (into a hello_packages directory): Build script: build.py Hello Merge Example \u00b6 This is another demonstration of using the RobustInstallerProcess class. Similar to the Hello Packages Example, Hello Merge demonstrates how you can \u201cmerge\u201d multiple \u201cpackages\u201d into a single package within an installer. The content of the two programs, which worked independently, will become one component which may NOT be installed selectively by the user. This example requires that both of the first examples (Hello World & Hello World Tk) be present in the testing environment within directories adjacent to a third directory where you place the next file. Those first two must be named hello_world and hello_world_tk for this \u201cmaster\u201d script to function. You may download/copy the example file directly from GitHub (into a hello_merge directory): Build script: build.py The key points to this example are to demo the implementation of the onPackagesStaged virtual function of RobustInstallerProcess . Within that, QtIfwPackage list manipulation is shown (by default) via mergeQtIfwPackages . If you comment that line out, and uncomment the call to nestQtIfwPackage below it, you may test the results of these alternate ways to combine packages. The demo goes on to show low-level manipulations, and regenerations of the files produced by, QtIfwConfigXml and QtIfwPackageXml objects to give you further insight into the design patterns and functionality of the library. Hello Code Signing Examples \u00b6 Generate Trust Certs w/ Installer \u00b6 TODO: FILL IN! Signed Python Executable Example \u00b6 TODO: FILL IN! Signed Installer Example \u00b6 TODO: FILL IN! Hello Wrapper Example \u00b6 This example provides a collection of demonstrations using the QtIfwExeWrapper class. A \u201cwrapper\u201d can super impose environmental conditions on the context within which the binary is run. Notably, this may include an ExecutableScript for maximum flexibility. Follow the links to learn to more. This example requires that both of the first examples (Hello World & Hello World Tk) be present in the testing environment within directories adjacent to a third directory where you place the next set of files. Those first two must be named hello_world and hello_world_tk for this \u201cmaster\u201d script to fully function. You may download/copy the example files directly from GitHub (into a hello_wrapper directory): Build script: build.py GUI app: hello_gui.py Terminal app: hello_terminal.py Within the build script, select a particular example to test and uncomment its p.run() line. Then, run the script to see the results. In conjunction with choosing a wrapper feature to test, you may switch between a gui and non-gui context. To do so, swap the commented out lines in the ConfigFactory attributes. That is, near the top of the script change: f.isGui = True f.entryPointPy = \"hello_gui.py\" To: f.isGui = False f.entryPointPy = \"hello_terminal.py\" When the resulting app is run, it will show the effect of implementing the various wrapper features e.g. the arguments the program received, or if you are running in an \u201celevated\u201d context, etc. If desired, you may also wish to test running these demo programs post installation in \u201cdebug mode\u201d. See the documentation on the run function. Hello Operations Examples \u00b6 TODO: FILL IN! Built-in Simple Operations Example \u00b6 TODO: FILL IN! Low Level Embedded Script Operations Example \u00b6 TODO: FILL IN! High Level Convenience Operations Example \u00b6 TODO: FILL IN! Cascading Scripts Example \u00b6 TODO: FILL IN! Windows Registry Interactions Example \u00b6 TODO: FILL IN! Hello Installer UI Examples \u00b6 Custom Graphics Examples \u00b6 TODO: FILL IN! Custom Interactions Examples \u00b6 TODO: FILL IN! Custom Pages Examples \u00b6 A QtIwf installer is extremely customizable. In addition to simply copying files to another machine, it can perform extended operations on that target to further refine the environment where the program will run. Not only that, but the installer\u2019s interface, and logic flow, can be manipulated to precisely fit your use case. This example demonstrates a proof of concept modification to that UI. This example requires the Hello World Tk files be present in the testing environment within a directory adjacent to where you will place the build script for this one. That required folder must be named hello_world_tk for this \u201cmaster\u201d script to function. You may download/copy the example file directly from GitHub (into a hello_qtifw_ui directory): Build script: build.py The demo shows how one may assign the ifwUiPages attribute of a ConfigFactory to to easily add or replace default installer \u201cpages\u201d / \u201cscreens\u201d with custom definitions. Those pages are represented using QtIfwUiPage objects. The QtIfwUiPage class is designed with the expectation that you may wish to create custom pages using the Qt Designer WYSIWYG tool. Alternatively, your needs maybe met by employing a derived class e.g. QtIfwSimpleTextPage , which draws upon a built-in library resource file for the page layout. In concert with altering these visual dimensions of the user experience, you may revise the logic via Installer Scripting , or call upon the higher level script abstraction classes QtIfwControlScript or QtIfwPackageScript . Widget Injections Example \u00b6 TODO: FILL IN! Hello Dynamic Finish Example \u00b6 TODO: FILL IN! Hello Startup Example \u00b6 TODO: FILL IN! Hello Opy Examples \u00b6 Hello Opy Example \u00b6 TODO: FILL IN! Hello Opy Bundle Example \u00b6 TODO: FILL IN! Hello IExpress Examples \u00b6 Hello Batch \u00b6 TODO: FILL IN! Hello PowerShell \u00b6 TODO: FILL IN! Hello VBScript \u00b6 TODO: FILL IN! Hello JScript \u00b6 TODO: FILL IN! Hello Dynamic Scripts \u00b6 TODO: FILL IN! Hello Resources \u00b6 TODO: FILL IN! Hello Imports \u00b6 TODO: FILL IN! Hello Installer \u00b6 TODO: FILL IN! Hello Mixed Source Installer \u00b6 TODO: FILL IN! Hello Qt C++ Examples \u00b6 Hello World Qt Example \u00b6 The Hello World Qt Example demos the Qt C++ Integration feature. If you wish to review / test the code, it is strongly recommended you read that section of the documentation in its entirety. Hello World QML Example \u00b6 See Hello World QML Example Hello World QML New Example \u00b6 See Hello World QML New Example","title":"Examples"},{"location":"Examples.html#examples","text":"","title":"Examples"},{"location":"Examples.html#source-code-resources","text":"All of the examples discussed here are included in the \u201csource distribution\u201d of the library. The PyPi downloads page for this project is arguably the fastest route to acquire that. See From source installation to learn about other ways of downloading these files.","title":"Source Code / Resources"},{"location":"Examples.html#hello-world-example","text":"The Hello World Example is a simple demonstration of using the PyToBinPackageProcess class. This is one of the most straightforward, simple use cases for the library. If you did not download the full source for the library (inclusive of the examples) you may download/copy the following individual files directly from GitHub into a local directory. It is recommended that you place them in a directory named hello_world . Example program: hello.py Build script: build.py Example resource: LICENSE Start by confirming you can run the program script in the \u201cnatural\u201d manner: python hello.py Don\u2019t expect it to do much\u2026 It simply writes \u201cHello World!\u201d to the console. Now, run the build script: python build.py The build script should achieve the following: converts the Python script to a stand-alone executable binary bundles the example resource (license file) into a directory with the binary compresses the distribution into a simple zip file (left in the same directory as the source) Having witnessed that function, review the build.py script for yourself. It should be self-explanatory for a moderately seasoned Python developer.","title":"Hello World Example"},{"location":"Examples.html#hello-world-tk-example","text":"This next example is a more comprehensive version of the first Hello World. It is a demonstration of using the PyToBinInstallerProcess class. Note: This example requires the standard Python TKinter library be installed. You may download/copy the following individual files directly from GitHub into a local directory. It is recommended that you place them in a directory named hello_world_tk . Example app: hello.py Build script: build.py Windows resource: demo.ico Mac resource: demo.icns Linux resource: demo.png Start by confirming you can run the program script in the \u201cnatural\u201d manner: python hello.py The program is a single button GUI. Clicking the button writes \u201cHello World!\u201d to the console. Now, run the build script: python build.py The build script should achieve the following: obfuscates the code (to mitigate the risk of reverse engineering) converts the obfuscated version of the source to a stand-alone executable builds a full installer with the executable bundled into it moves the installer to your desktop (for convenience) launches the installer (for testing) Proceed through the installer, and then run the program to confirm it works. Having witnessed everything function, review the build.py script. The script is a simple example, but covers a good portion of the \u201ccore\u201d distbuilder features.","title":"Hello World Tk Example"},{"location":"Examples.html#hello-dynamic-ini-example","text":"TODO: FILL IN!","title":"Hello Dynamic Ini Example"},{"location":"Examples.html#hello-silent-example","text":"It is another demonstration of using the PyToBinInstallerProcess class. Hello Silent demonstrates how one can use distbuilder to build \u201csilent\u201d installers. These do not require user interactions for them to complete their tasks. Instead, they run automatically, while having the same flexible options present in the gui installers made available via command line arguments. \u201cSilent\u201d installers built by distbuilder provide a very important additional feature. They are able to be run in non-gui contexts , such as on \u201cheadless servers\u201d. Silent installers are, of course, also desirable (on any platform) for mass installation purposes such as when a network administrator needs to install the same program on countless workstations. Building a silent installer requires nothing more than setting the isSilentSetup configuration option to True . As such, you can easily define a full blown packaging and installation process that could be run in Windows (for example) using an interactive graphical interface, AND could also be used on a CentOS server (for example), with nothing but a terminal interface available. You would only have to toggle the isSilentSetup option before running the build script! This example expects that you already downloaded the first example (Hello World). That must be present in the testing environment within a directory adjacent to where you place the next file. That first directory must be named hello_world for this \u201cmaster\u201d script (which draws upon that) to function. You may download/copy the example file directly from GitHub (into a hello_silent directory): Build script: build.py Upon building the silent installer, the demo is set to test \u201cAuto Installation\u201d of it. With that enabled, it will run the installer with the command line argument to \u201cforce installation\u201d. If run more than once, that option will cause it to uninstall any prior existing installation rather than exiting with an error, as it would do by default when a conflict was detected. For more information, refer to Silent Installers .","title":"Hello Silent Example"},{"location":"Examples.html#hello-multi-package-examples","text":"","title":"Hello Multi-Package Examples"},{"location":"Examples.html#hello-code-signing-examples","text":"","title":"Hello Code Signing Examples"},{"location":"Examples.html#hello-wrapper-example","text":"This example provides a collection of demonstrations using the QtIfwExeWrapper class. A \u201cwrapper\u201d can super impose environmental conditions on the context within which the binary is run. Notably, this may include an ExecutableScript for maximum flexibility. Follow the links to learn to more. This example requires that both of the first examples (Hello World & Hello World Tk) be present in the testing environment within directories adjacent to a third directory where you place the next set of files. Those first two must be named hello_world and hello_world_tk for this \u201cmaster\u201d script to fully function. You may download/copy the example files directly from GitHub (into a hello_wrapper directory): Build script: build.py GUI app: hello_gui.py Terminal app: hello_terminal.py Within the build script, select a particular example to test and uncomment its p.run() line. Then, run the script to see the results. In conjunction with choosing a wrapper feature to test, you may switch between a gui and non-gui context. To do so, swap the commented out lines in the ConfigFactory attributes. That is, near the top of the script change: f.isGui = True f.entryPointPy = \"hello_gui.py\" To: f.isGui = False f.entryPointPy = \"hello_terminal.py\" When the resulting app is run, it will show the effect of implementing the various wrapper features e.g. the arguments the program received, or if you are running in an \u201celevated\u201d context, etc. If desired, you may also wish to test running these demo programs post installation in \u201cdebug mode\u201d. See the documentation on the run function.","title":"Hello Wrapper Example"},{"location":"Examples.html#hello-operations-examples","text":"TODO: FILL IN!","title":"Hello Operations Examples"},{"location":"Examples.html#hello-installer-ui-examples","text":"","title":"Hello Installer UI Examples"},{"location":"Examples.html#hello-dynamic-finish-example","text":"TODO: FILL IN!","title":"Hello Dynamic Finish Example"},{"location":"Examples.html#hello-startup-example","text":"TODO: FILL IN!","title":"Hello Startup Example"},{"location":"Examples.html#hello-opy-examples","text":"","title":"Hello Opy Examples"},{"location":"Examples.html#hello-iexpress-examples","text":"","title":"Hello IExpress Examples"},{"location":"Examples.html#hello-qt-c-examples","text":"","title":"Hello Qt C++ Examples"},{"location":"HighLevel.html","text":"High Level Classes \u00b6 ConfigFactory \u00b6 It is typical for a build script to start by creating a high-level ConfigFactory object and set its attributes. The primary functions within this library rely upon a collection of \u201cconfiguration\u201d objects which act as \u201csmart parameter sets\u201d. Those parameters are used to drive various processes. Many of these config classes have overlapping attributes. Scripts which employ a collection of those low levels objects in the raw tend to include a lot of tedious and redundant assignment operations. With this in mind, the ConfigFactory class was created, to radically simplify many scripts. See Configuration Classes for more information on the types of objects generated by this factory class. Process Classes Overview \u00b6 Many build scripts will follow the same essential logic flow, to produce analogous distributions. As such, using high-level \u201cprocess classes\u201d can prevent having multiple implementation scripts be virtual duplicates of one another, each containing a fair volume of code which employs the \u201clow level\u201d functions in the library. Distbuilder currently provides three high-level \u201cprocess classes\u201d, each more powerful (and complex) then the prior: PyToBinPackageProcess PyToBinInstallerProcess RobustInstallerProcess PyToBinPackageProcess \u00b6 This \u201csimple\u201d process class converts a program written in Python scripts into a stand-alone executable binary. It additionally has built-in options for employing code obfuscation, for testing the resulting product, for \u201cresource bundling\u201d, and for packaging into an archive file. The process uses a ConfigFactory to automatically produce the config objects it requires, but allows a client to modify those objects before they are implemented by defining a derived class and overriding certain functions as needed for this purpose. Constructor: PyToBinPackageProcess( configFactory, name=\"Python to Binary Package Process\", isZipped=False, isDesktopTarget=False, isHomeDirTarget=False ) Attributes & default values: configFactory = <required> name = \"Python to Binary Package Process\" isZipped = False isDesktopTarget = False isHomeDirTarget = False isWarningSuppression = True isUnBufferedStdIo = False isPyInstDupDataPatched = None <auto> isObfuscationTest = False isExeTest = False isElevatedTest = False exeTestArgs = [] # Results binDir = None binPath = None \u201cVirtual\u201d configuration functions to optionally override: (Note the order shown is that in which these functions are invoked) onInitialize() onOpyConfig( cfg ) onPyInstConfig( cfg ) onMakeSpec( spec ) onFinalize() Use: Simply invoke the run() function to execute the process. Examples: Hello World Example configFactory \u00b6 The required ConfigFactory attribute contains many of the details used to drive this process. name \u00b6 Used simply for logging or custom implementations where it may be useful to distinguish between multiple processes. isZipped \u00b6 Setting this to True bundles the results into a zip file. isWarningSuppression \u00b6 By default, this is enabled by the library (thus differing from the standard in Python or PyInstaller). Such will prevent Python warning messages from being output to the terminal (they will be \u201cignored\u201d instead). Note this neither suppresses nor exposes exception messages / stderr output. That is an entirely distinct matter. Note that the inclusion of warning suppression which may be present in your Python source code will not actually be respected by PyInstaller binaries naturally! This mechanism (driven via a .spec file manipulation under the hood) is the means to control such. For more on Python warnings in general, refer to: https://docs.python.org/3/library/warnings.html isUnBufferedStdIo \u00b6 By default, this is disabled. Python stdin/out/err streams are naturally buffered, as that is more efficient and thus preferable for most use cases. Switching to \u201cunbuffered\u201d mode, will, however, produce more rapid responsiveness on these streams. Such may be desirable if your program will communicate with other programs via these streams, or if you want to view \u201creal-time debugging\u201d messages, or have other uses for fast i/o on in a shell/terminal context perhaps. isPyInstDupDataPatched \u00b6 If this is set to None (the default) or True , the results are the same. You must set this to False explicitly to disable this built-in feature. When enabled, this patches a known bug in PyInstaller when it is on Windows. PyInstaller analysis can build a set of data file names which contain \u201cduplicates\u201d due to the Windows file system case insensitivity. This patch eliminates such duplicates, thus preventing runtime errors in the binary produced. You will nearly always when to leave this alone. It is only made optional because it is not a \u201cstandard\u201d part of a PyInstaller process. isObfuscationTest \u00b6 This option is intended to be toggled manually during a testing and debugging phase of the build process definition. This is only applicable when when code obfuscation is enabled. When this is also enabled, this will interrupt the normal build process. Upon creating an obfuscated version of the scripts, the revised entry point module will be launched, thereby allowing you to confirm the program is still functional in this new state. Upon exiting the program, the build process is also exited. This option LEAVES the obfuscated code in place for further testing and inspection. This is in opposition to the normal deletion of such after having embedded the code in the binary. isExeTest, exeTestArgs, isElevatedTest \u00b6 The isExeTest attribute is similar in nature to is isObfuscationTest . This launches the resulting binary after building it. Unlike isObfuscationTest , this does NOT exit the build process. Upon exiting the program you are testing, any remaining steps in the build process are continued. The exeTestArgs and isElevatedTest attributes are additionally provided to vet the result in an automated fashion in the event such options are useful. onInitialize() \u00b6 This function is intended for adding any custom setup procedures to be run before any other operations are begun. That involve shuffling around files, downloading resources, etc. Notably, this is the ideal place to gather and install Python dependencies. By installing all of your dependencies here, you make your project and build script far more portable across machines / environments. Refer to the documentation on these useful utility functions for this purpose: installLibrary installLibraries onOpyConfig( cfg ) \u00b6 When code obfuscation is enabled, an OpyConfig object will be generated and passed here. You may then configure the details of such. onPyInstConfig( cfg ) \u00b6 Prior to running PyInstaller, a PyInstallerConfig object will be generated and passed here. You may then configure the details of such. onMakeSpec( spec ) \u00b6 This class employs the more advanced option of running PyInstaller against a \u201cspec\u201d file. After initial processing of the PyInstallerConfig object, a PyInstSpec object (with a corresponding temp spec file) will be generated. The onMakeSpec function allows a final manipulation of that prior to running the PyInstaller process. onFinalize() \u00b6 After every other task has been performed by this process class, this function will be called. This allows you to perform any custom clean up tasks, or other manipulations of the results. These notable object attributes will now be set for you to potentially use at this stage: binDir , binPath . IExpressPackageProcess \u00b6 WINDOWS ONLY This \u201csimple\u201d process class converts a program written in a native Windows script (currently supporting Batch, PowerShell, VBScript, and JScript), into a stand-alone executable binary. It additionally has built-in options for testing the resulting product, for \u201cresource bundling\u201d, and for packaging into an archive file. The process uses a ConfigFactory to automatically produce the config objects it requires, but allows a client to modify those objects before they are implemented by defining a derived class and overriding certain functions as needed for this purpose. Constructor: IExpressPackageProcess( configFactory, name=\"Windows Script to Binary Package Process\", isZipped=False, isDesktopTarget=False, isHomeDirTarget=False ) Attributes & default values: configFactory = <required> name = \"Windows Script to Binary Package Process\" isZipped = False isDesktopTarget = False isHomeDirTarget = False isExeTest = False isElevatedTest = False exeTestArgs = [] # Results binDir = None binPath = None \u201cVirtual\u201d configuration functions to optionally override: (Note the order shown is that in which these functions are invoked) onInitialize() onIExpressConfig( cfg ) onFinalize() Use: Simply invoke the run() function to execute the process. PyToBinInstallerProcess \u00b6 A PyToBinInstallerProcess process contains a PyToBinPackageProcess within it, and thus provides the full functionality of that to begin with. In addition, however, it rolls the product of that lower level process within a full fledged installer. Like the other process classes, this uses a ConfigFactory to automatically produce the config objects it requires, but allows a client to modify those objects before they are implemented by defining a derived class and overriding certain functions as needed for this purpose. This process is basically a simplified version of a RobustInstallerProcess . Use that class instead if you need to build an installable distribution which does NOT involve a Python to binary conversion process (e.g. packaging binaries produced in another language with some other compiler), or if you have more comprehensive needs such as producing multiple Python derived binaries or installable \u201cpackages\u201d bundled together. Constructor: PyToBinInstallerProcess( configFactory, name=\"Python To Binary Installer Process\", isDesktopTarget=False, isHomeDirTarget=False ) Attributes & default values: configFactory = <required> name = \"Python To Binary Installer Process\" isDesktopTarget = False isHomeDirTarget = False isInstallTest = False isAutoInstallTest = False isVerboseInstallTest = True isScriptDebugInstallTest = False \u201cVirtual\u201d configuration functions to override: (Note the order shown is that in which these functions are invoked) onInitialize() onPyPackageProcess( prc ) onOpyConfig( cfg ) onPyInstConfig( cfg ) onMakeSpec( spec ) onQtIfwConfig( cfg ) onFinalize() Use: Simply invoke the run() function to execute the process. Examples: Hello World Tk Example Hello Silent Example configFactory, name \u00b6 See the documentation for these attributes as provided for the PyToBinPackageProcess class. isDesktopTarget, isHomeDirTarget \u00b6 Set either of these to True , to have the final installer that is produced moved to either of these respective locations in the end. If neither are True , the installer is simply left in the build directory. If both are True , priority is given to isDesktopTarget . isInstallTest, isAutoInstallTest, isVerboseInstallTest \u00b6 Upon building the installer (and moving it to a target directory if so directed), the installer will be launched when either isInstallTest , or isAutoInstallTest is enabled. The isVerboseInstallTest option controls the level of debugging output logged to the console during the installation. The isInstallTest simply launches the installer. In contrast, isAutoInstallTest runs it in \u201cauto pilot\u201d mode (i.e. performs the installation as well). Note that an \u201celevated privileges\u201d option was NOT provided as such is to built into all silent installers (i.e. they auto elevate themselves), and \u201cloud\u201d/gui installers have their own internal controls for this. isScriptDebugInstallTest \u00b6 This flag may be useful in the event you are embedding scripts into an installer via a QtIfwExternalOp using an ExecutableScript . When enabled, the dynamically generated script (with installer driven value substitutions where applicable) will be left behind in a temp folder after running the installer, rather than auto purging that upon completion. If you have effectively built the script via Python \u201chelpers\u201d using a function e.g. QtIfwExternalOp.CreateStartupEntry(...) , this may be especially helpful to see what was actually produced and executed, through a series of abstraction layers that ultimately produce platform specific scripts, nested under the hood inside an installer. onInitialize(), onFinalize() \u00b6 See the documentation for these functions as provided for the PyToBinPackageProcess class. onOpyConfig( cfg ), onPyInstConfig( cfg ), onMakeSpec( spec ), \u00b6 See the documentation for these functions as provided for the PyToBinPackageProcess class. onPyPackageProcess( prc ) \u00b6 As stated in the overview, this class generates and employs its own PyToBinPackageProcess object. Upon doing so, it passes that object through this function, where you can manipulate it as needed for your implementation. onQtIfwConfig( cfg ) \u00b6 After building a \u201cpackage\u201d from the Python source, QtIFW is employed to build an installer for deploying that content. Those tasks are driven by a master QtIfwConfig object. A collection of related sub components are nested inside of that (e.g. QtIfwPackage ). Before running the process to build the installer, that master config object is passed through this function, where you can manipulate it as needed for your implementation. IExpressInstallerProcess \u00b6 A IExpressInstallerProcess process contains an IExpressPackageProcess within it, and thus provides the full functionality of that to begin with. In addition, however, it rolls the product of that lower level process within a full fledged installer. Like the other process classes, this uses a ConfigFactory to automatically produce the config objects it requires, but allows a client to modify those objects before they are implemented by defining a derived class and overriding certain functions as needed for this purpose. This process is basically a simplified version of a RobustInstallerProcess . Use that class instead if you need to build an installable distribution if you have more comprehensive needs such as producing multiple binaries or installable \u201cpackages\u201d bundled together. Constructor: IExpressInstallerProcess( configFactory, name=\"Windows Script to Binary Installer Process\", isDesktopTarget=False, isHomeDirTarget=False ) Attributes & default values: configFactory = <required> name = \"Windows Script to Binary Installer Process\" isDesktopTarget = False isHomeDirTarget = False isInstallTest = False isAutoInstallTest = False isVerboseInstallTest = True isScriptDebugInstallTest = False \u201cVirtual\u201d configuration functions to override: (Note the order shown is that in which these functions are invoked) onInitialize() onIExpressPackageProcess( prc ) onIExpressConfig( cfg ) onQtIfwConfig( cfg ) onFinalize() Use: Simply invoke the run() function to execute the process. RobustInstallerProcess \u00b6 A RobustInstallerProcess is the most advanced and intricate of these processes. It exposes details of the build process that PyToBinInstallerProcess insulates from the user. In addition to providing access to more nitty gritty details, this class is primarily intended for use when you need to produce multiple binaries from Python scripts and/or multiple installable \u201cpackages\u201d bundled together. This class is also useful for building an installer which does NOT involve a Python to binary conversion process (e.g. packaging binaries produced in another language, using some other compiler). What is most notable about this process class, compared to others, is that uses a \u201cMaster Config Factory\u201d, plus a dictionary containing multiple \u201cPy Package Config Factories\u201d. Further, it can additionally use a list of independent (non-Python related) \u201cQt IFW Packages\u201d. The \u201cMaster Config Factory\u201d is used to define the top level \u201cwrapper\u201d installer. For each element in the \u201cPy Package Config Factories\u201d dictionary, a \u201cpackage\u201d is created from a Python script. Those entries are sub components within the whole, built using separate instances of a PyToBinPackageProcess . If a value in the \u201cPy Package Config Factories\u201d dictionary is set to None , one will be generated for it, by cloning the master config. That cloned ConfigFactory will then be passed to the overridable function onConfigFactory( key, factory ) . Within that, your implementation may modify the object, but it will not have to start from \u201cscratch\u201d because whatever common attributes might be shared between the master and the sub components will already be defined (hence the purpose of the cloning option). The other notable attribute of this class is the list of \u201cQt IFW Packages\u201d. Items in this list may be dynamic QtIfwPackage objects, or be simple strings defining relative paths to QtIFW packages which are defined as external resources, in the traditional (hard coded, content containing) IFW manner. Using this class attribute, you may build installers with packages containing other programs that are not Python related, or may be comprised of optional resources that the end user might wish to selectively install. Constructor: RobustInstallerProcess( masterConfigFactory, name=\"Multi-Package Python to Binary Installer Process\", pyPkgConfigFactoryDict={}, iExpressPkgConfigFactoryDict={}, ifwPackages=[], isDesktopTarget=False, isHomeDirTarget=False ) Attributes & default values: configFactory = <required> name = \"Multi-Package Python to Binary Installer Process\" pyToBinPkgProcesses = [] iexpressPkgProcesses = [] ifwPackages = [] isDesktopTarget = False isHomeDirTarget = False isInstallTest = False isAutoInstallTest = False isVerboseInstallTest = True isScriptDebugInstallTest = False \u201cVirtual\u201d configuration functions to override: (Note the order shown is that in which these functions are invoked) onInitialize() onConfigFactory( key, factory ) onPyPackageProcess( key, prc ) onPyPackageInitialize( key ) onOpyConfig( key, cfg ) onPyInstConfig( key, cfg ) onMakeSpec( key, spec ) onPyPackageFinalize( key ) onPyPackagesBuilt( pkgs ) onIExpressPackageProcess( key, prc ) onIExpressPackageInitialize( key ) onIExpressConfig( key, cfg ) onIExpressPackageFinalize( key ) onIExpressPackagesBuilt( pkgs ) onQtIfwConfig( cfg ) onPackagesStaged( cfg, pkgs ) onFinalize() Use: Simply invoke the run() function to execute the process. Examples: Hello Packages Example Hello Merge Example configFactory, name \u00b6 See the documentation for these attributes as provided for the PyToBinPackageProcess class. Note configFactory == \u201cMaster Config Factory\u201d for this class. See the class overview for an explanation of what that means. pyToBinPkgProcesses, iexpressPkgProcesses, ifwPackages \u00b6 While technically exposed for access by an implementation, it is not generally advised that you directly modify these attributes . The pyToBinPkgProcesses list will be generated for you. If you need to manipulate a given sub process definition before its use, it is recommended that you do so via onPyPackageProcess( key, prc ) . If you wish to manipulate the packages after they have all been built, that should normally be done via onPyPackagesBuilt( pkgs ) . iexpressPkgProcesses \u2026 The ifwPackages attribute should normally be defined prior to creating this class, and simply be passed to its constructor. See the class overview for an explanation of how this attribute is used. isDesktopTarget, isHomeDirTarget \u00b6 See the documentation for these attributes as provided for the PyToBinInstallerProcess class. isInstallTest, isAutoInstallTest, isVerboseInstallTest \u00b6 See the documentation for these attributes as provided for the PyToBinInstallerProcess class. onInitialize(), onFinalize() \u00b6 See the documentation for these functions as provided for the PyToBinPackageProcess class. Note these are to be used in relation to the master process. onPyPackageInitialize( key ), onPyPackageFinalize( key ) \u00b6 These functions are analogous to onInitialize() and onFinalize() . They are, however, invoked around each PyToBinPackageProcess this master process runs. A key argument is provided to supply a means by which to identify the package being built upon on the given invocation of these functions. The keys passed here align with those defined in the pyPkgConfigFactoryDict argument passed to the constructor. onConfigFactory( key, factory ) \u00b6 This function receives a clone of the \u201cMaster Config Factory\u201d for each entry in the \u201cPy Package Config Factories\u201d dictionary that has a value set to None . A key argument is provided to supply a means by which to identify the Factory being configured upon on the given invocation of this function. The keys passed here align with those defined in the pyPkgConfigFactoryDict argument passed to the constructor. See the class overview for an explanation of how this is used. onOpyConfig( key, cfg ), onPyInstConfig( key, cfg ), onMakeSpec( key, spec ) \u00b6 See the documentation for these functions as provided for the PyToBinPackageProcess class. In addition to the standard object passed through these functions, a key is provided to supply a means by which to identify the package being built upon on the given invocation of these functions. The keys passed here align with those defined in the pyPkgConfigFactoryDict argument passed to the constructor. onPyPackageProcess( key, prc ) \u00b6 See the documentation for this function as provided for the PyToBinInstallerProcess class. In addition to the standard object passed through this function, a key is provided to supply a means by which to identify the package being built upon on the given invocation of this function. The keys passed here align with those defined in the pyPkgConfigFactoryDict argument passed to the constructor. onPyPackagesBuilt( pkgs ) \u00b6 After all of the Python packages have been built (if applicable), this function is invoked prior to running the installer building process. The pkgs parameter this receives is the list of corresponding QtIfwPackage objects, including those which have been generated from Python source. onPackagesStaged( cfg, pkgs ) \u00b6 After ALL of the packages have been fully staged, just prior to running the QtIFW process, this function is invoked. The cfg parameter this receives is the master QtIfwConfig object used to drive the installer build. The pkgs parameter this receives is the list of QtIfwPackage objects. Note, you could also access those via cfg.packages . The pkgs parameter is provided for convenience . This function maybe used to manipulate the packages before the final send off to QtIFW. See QtIfwPackage list manipulation for details, utility functions, and ideas surrounding how this can be applied.","title":"High Level Classes"},{"location":"HighLevel.html#high-level-classes","text":"","title":"High Level Classes"},{"location":"HighLevel.html#configfactory","text":"It is typical for a build script to start by creating a high-level ConfigFactory object and set its attributes. The primary functions within this library rely upon a collection of \u201cconfiguration\u201d objects which act as \u201csmart parameter sets\u201d. Those parameters are used to drive various processes. Many of these config classes have overlapping attributes. Scripts which employ a collection of those low levels objects in the raw tend to include a lot of tedious and redundant assignment operations. With this in mind, the ConfigFactory class was created, to radically simplify many scripts. See Configuration Classes for more information on the types of objects generated by this factory class.","title":"ConfigFactory"},{"location":"HighLevel.html#process-classes-overview","text":"Many build scripts will follow the same essential logic flow, to produce analogous distributions. As such, using high-level \u201cprocess classes\u201d can prevent having multiple implementation scripts be virtual duplicates of one another, each containing a fair volume of code which employs the \u201clow level\u201d functions in the library. Distbuilder currently provides three high-level \u201cprocess classes\u201d, each more powerful (and complex) then the prior: PyToBinPackageProcess PyToBinInstallerProcess RobustInstallerProcess","title":"Process Classes Overview"},{"location":"HighLevel.html#pytobinpackageprocess","text":"This \u201csimple\u201d process class converts a program written in Python scripts into a stand-alone executable binary. It additionally has built-in options for employing code obfuscation, for testing the resulting product, for \u201cresource bundling\u201d, and for packaging into an archive file. The process uses a ConfigFactory to automatically produce the config objects it requires, but allows a client to modify those objects before they are implemented by defining a derived class and overriding certain functions as needed for this purpose. Constructor: PyToBinPackageProcess( configFactory, name=\"Python to Binary Package Process\", isZipped=False, isDesktopTarget=False, isHomeDirTarget=False ) Attributes & default values: configFactory = <required> name = \"Python to Binary Package Process\" isZipped = False isDesktopTarget = False isHomeDirTarget = False isWarningSuppression = True isUnBufferedStdIo = False isPyInstDupDataPatched = None <auto> isObfuscationTest = False isExeTest = False isElevatedTest = False exeTestArgs = [] # Results binDir = None binPath = None \u201cVirtual\u201d configuration functions to optionally override: (Note the order shown is that in which these functions are invoked) onInitialize() onOpyConfig( cfg ) onPyInstConfig( cfg ) onMakeSpec( spec ) onFinalize() Use: Simply invoke the run() function to execute the process. Examples: Hello World Example","title":"PyToBinPackageProcess"},{"location":"HighLevel.html#iexpresspackageprocess","text":"WINDOWS ONLY This \u201csimple\u201d process class converts a program written in a native Windows script (currently supporting Batch, PowerShell, VBScript, and JScript), into a stand-alone executable binary. It additionally has built-in options for testing the resulting product, for \u201cresource bundling\u201d, and for packaging into an archive file. The process uses a ConfigFactory to automatically produce the config objects it requires, but allows a client to modify those objects before they are implemented by defining a derived class and overriding certain functions as needed for this purpose. Constructor: IExpressPackageProcess( configFactory, name=\"Windows Script to Binary Package Process\", isZipped=False, isDesktopTarget=False, isHomeDirTarget=False ) Attributes & default values: configFactory = <required> name = \"Windows Script to Binary Package Process\" isZipped = False isDesktopTarget = False isHomeDirTarget = False isExeTest = False isElevatedTest = False exeTestArgs = [] # Results binDir = None binPath = None \u201cVirtual\u201d configuration functions to optionally override: (Note the order shown is that in which these functions are invoked) onInitialize() onIExpressConfig( cfg ) onFinalize() Use: Simply invoke the run() function to execute the process.","title":"IExpressPackageProcess"},{"location":"HighLevel.html#pytobininstallerprocess","text":"A PyToBinInstallerProcess process contains a PyToBinPackageProcess within it, and thus provides the full functionality of that to begin with. In addition, however, it rolls the product of that lower level process within a full fledged installer. Like the other process classes, this uses a ConfigFactory to automatically produce the config objects it requires, but allows a client to modify those objects before they are implemented by defining a derived class and overriding certain functions as needed for this purpose. This process is basically a simplified version of a RobustInstallerProcess . Use that class instead if you need to build an installable distribution which does NOT involve a Python to binary conversion process (e.g. packaging binaries produced in another language with some other compiler), or if you have more comprehensive needs such as producing multiple Python derived binaries or installable \u201cpackages\u201d bundled together. Constructor: PyToBinInstallerProcess( configFactory, name=\"Python To Binary Installer Process\", isDesktopTarget=False, isHomeDirTarget=False ) Attributes & default values: configFactory = <required> name = \"Python To Binary Installer Process\" isDesktopTarget = False isHomeDirTarget = False isInstallTest = False isAutoInstallTest = False isVerboseInstallTest = True isScriptDebugInstallTest = False \u201cVirtual\u201d configuration functions to override: (Note the order shown is that in which these functions are invoked) onInitialize() onPyPackageProcess( prc ) onOpyConfig( cfg ) onPyInstConfig( cfg ) onMakeSpec( spec ) onQtIfwConfig( cfg ) onFinalize() Use: Simply invoke the run() function to execute the process. Examples: Hello World Tk Example Hello Silent Example","title":"PyToBinInstallerProcess"},{"location":"HighLevel.html#iexpressinstallerprocess","text":"A IExpressInstallerProcess process contains an IExpressPackageProcess within it, and thus provides the full functionality of that to begin with. In addition, however, it rolls the product of that lower level process within a full fledged installer. Like the other process classes, this uses a ConfigFactory to automatically produce the config objects it requires, but allows a client to modify those objects before they are implemented by defining a derived class and overriding certain functions as needed for this purpose. This process is basically a simplified version of a RobustInstallerProcess . Use that class instead if you need to build an installable distribution if you have more comprehensive needs such as producing multiple binaries or installable \u201cpackages\u201d bundled together. Constructor: IExpressInstallerProcess( configFactory, name=\"Windows Script to Binary Installer Process\", isDesktopTarget=False, isHomeDirTarget=False ) Attributes & default values: configFactory = <required> name = \"Windows Script to Binary Installer Process\" isDesktopTarget = False isHomeDirTarget = False isInstallTest = False isAutoInstallTest = False isVerboseInstallTest = True isScriptDebugInstallTest = False \u201cVirtual\u201d configuration functions to override: (Note the order shown is that in which these functions are invoked) onInitialize() onIExpressPackageProcess( prc ) onIExpressConfig( cfg ) onQtIfwConfig( cfg ) onFinalize() Use: Simply invoke the run() function to execute the process.","title":"IExpressInstallerProcess"},{"location":"HighLevel.html#robustinstallerprocess","text":"A RobustInstallerProcess is the most advanced and intricate of these processes. It exposes details of the build process that PyToBinInstallerProcess insulates from the user. In addition to providing access to more nitty gritty details, this class is primarily intended for use when you need to produce multiple binaries from Python scripts and/or multiple installable \u201cpackages\u201d bundled together. This class is also useful for building an installer which does NOT involve a Python to binary conversion process (e.g. packaging binaries produced in another language, using some other compiler). What is most notable about this process class, compared to others, is that uses a \u201cMaster Config Factory\u201d, plus a dictionary containing multiple \u201cPy Package Config Factories\u201d. Further, it can additionally use a list of independent (non-Python related) \u201cQt IFW Packages\u201d. The \u201cMaster Config Factory\u201d is used to define the top level \u201cwrapper\u201d installer. For each element in the \u201cPy Package Config Factories\u201d dictionary, a \u201cpackage\u201d is created from a Python script. Those entries are sub components within the whole, built using separate instances of a PyToBinPackageProcess . If a value in the \u201cPy Package Config Factories\u201d dictionary is set to None , one will be generated for it, by cloning the master config. That cloned ConfigFactory will then be passed to the overridable function onConfigFactory( key, factory ) . Within that, your implementation may modify the object, but it will not have to start from \u201cscratch\u201d because whatever common attributes might be shared between the master and the sub components will already be defined (hence the purpose of the cloning option). The other notable attribute of this class is the list of \u201cQt IFW Packages\u201d. Items in this list may be dynamic QtIfwPackage objects, or be simple strings defining relative paths to QtIFW packages which are defined as external resources, in the traditional (hard coded, content containing) IFW manner. Using this class attribute, you may build installers with packages containing other programs that are not Python related, or may be comprised of optional resources that the end user might wish to selectively install. Constructor: RobustInstallerProcess( masterConfigFactory, name=\"Multi-Package Python to Binary Installer Process\", pyPkgConfigFactoryDict={}, iExpressPkgConfigFactoryDict={}, ifwPackages=[], isDesktopTarget=False, isHomeDirTarget=False ) Attributes & default values: configFactory = <required> name = \"Multi-Package Python to Binary Installer Process\" pyToBinPkgProcesses = [] iexpressPkgProcesses = [] ifwPackages = [] isDesktopTarget = False isHomeDirTarget = False isInstallTest = False isAutoInstallTest = False isVerboseInstallTest = True isScriptDebugInstallTest = False \u201cVirtual\u201d configuration functions to override: (Note the order shown is that in which these functions are invoked) onInitialize() onConfigFactory( key, factory ) onPyPackageProcess( key, prc ) onPyPackageInitialize( key ) onOpyConfig( key, cfg ) onPyInstConfig( key, cfg ) onMakeSpec( key, spec ) onPyPackageFinalize( key ) onPyPackagesBuilt( pkgs ) onIExpressPackageProcess( key, prc ) onIExpressPackageInitialize( key ) onIExpressConfig( key, cfg ) onIExpressPackageFinalize( key ) onIExpressPackagesBuilt( pkgs ) onQtIfwConfig( cfg ) onPackagesStaged( cfg, pkgs ) onFinalize() Use: Simply invoke the run() function to execute the process. Examples: Hello Packages Example Hello Merge Example","title":"RobustInstallerProcess"},{"location":"IExpress.html","text":"IExpressConfig class \u00b6 Magic Methods: __init__ Instance Methods: iExpEmbResPath iExpLibPath iExpResPath scriptType Instance Attributes: name sourceDir entryPointScript scriptHeader isScriptDebug versionInfo iconFilePath isAutoElevated scriptImports embeddedResources distResources distDirs codeSignConfig codeSignTargets destDirPath IExpressConfig () \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . iExpEmbResPath ( self , path ) \u00b6 obj . iExpLibPath ( self , path ) \u00b6 obj . iExpResPath ( self , path , isEmbedded = False ) \u00b6 obj . scriptType ( self ) \u00b6 obj . name class \u2018NoneType\u2019 default: None \u00b6 obj . sourceDir class \u2018NoneType\u2019 default: None \u00b6 obj . entryPointScript class \u2018NoneType\u2019 default: None \u00b6 obj . scriptHeader class \u2018NoneType\u2019 default: None \u00b6 obj . isScriptDebug class \u2018bool\u2019 default: False \u00b6 obj . versionInfo class \u2018NoneType\u2019 default: None \u00b6 obj . iconFilePath class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoElevated class \u2018bool\u2019 default: False \u00b6 obj . scriptImports class \u2018list\u2019 default: [] \u00b6 obj . embeddedResources class \u2018list\u2019 default: [] \u00b6 obj . distResources class \u2018list\u2019 default: [] \u00b6 obj . distDirs class \u2018list\u2019 default: [] \u00b6 obj . codeSignConfig class \u2018list\u2019 default: [] \u00b6 obj . codeSignTargets class \u2018list\u2019 default: [] \u00b6 obj . destDirPath class \u2018NoneType\u2019 default: None \u00b6 IExpressInstallerProcess class \u00b6 Base Classes: _DistBuildProcessBase, _BuildInstallerProcess Magic Methods: __init__ Instance Methods: onFinalize onIExpressConfig onIExpressPackageProcess onIExpressPackagesBuilt onInitialize onPackagesStaged onPyPackagesBuilt onQtIfwConfig run Class/Static Attributes: DIVIDER IExpressInstallerProcess ( configFactory , name = 'Windows Script to Binary Installer Process' , isDesktopTarget = False , isHomeDirTarget = False ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . onFinalize ( self ) \u00b6 VIRTUAL obj . onIExpressConfig ( self , cfg ) \u00b6 VIRTUAL obj . onIExpressPackageProcess ( self , prc ) \u00b6 VIRTUAL obj . onIExpressPackagesBuilt ( self , pkgs ) \u00b6 VIRTUAL obj . onInitialize ( self ) \u00b6 VIRTUAL obj . onPackagesStaged ( self , cfg , pkgs ) \u00b6 VIRTUAL obj . onPyPackagesBuilt ( self , pkgs ) \u00b6 VIRTUAL obj . onQtIfwConfig ( self , cfg ) \u00b6 VIRTUAL obj . run ( self ) \u00b6 IExpressInstallerProcess . DIVIDER class \u2018str\u2019 default: \u201d------------------------------------\u201c \u00b6 IExpressPackageProcess class \u00b6 Base Classes: _DistBuildProcessBase, _BuildPackageProcess Magic Methods: __init__ Instance Methods: onFinalize onIExpressConfig onInitialize run Class/Static Attributes: DIVIDER IExpressPackageProcess ( configFactory , name = 'Windows Script to Binary Package Process' , isZipped = False , isDesktopTarget = False , isHomeDirTarget = False ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . onFinalize ( self ) \u00b6 VIRTUAL obj . onIExpressConfig ( self , cfg ) \u00b6 VIRTUAL obj . onInitialize ( self ) \u00b6 VIRTUAL obj . run ( self ) \u00b6 IExpressPackageProcess . DIVIDER class \u2018str\u2019 default: \u201d------------------------------------\u201c \u00b6 Functions \u00b6 batchScriptToExe ( name = None , entryPointScript = None , iExpressConfig = None , distResources = None , distDirs = None ) \u00b6 iExpEmbResPath ( path , scriptType ) \u00b6 iExpLibPath ( path , scriptType ) \u00b6 iExpResPath ( path , scriptType , isEmbedded ) \u00b6 jScriptToExe ( name = None , entryPointScript = None , iExpressConfig = None , distResources = None , distDirs = None ) \u00b6 powerShellScriptToExe ( name = None , entryPointScript = None , iExpressConfig = None , distResources = None , distDirs = None ) \u00b6 vbScriptToExe ( name = None , entryPointScript = None , iExpressConfig = None , distResources = None , distDirs = None ) \u00b6","title":"IExpress"},{"location":"IExpress.html#IExpressConfig","text":"Magic Methods: __init__ Instance Methods: iExpEmbResPath iExpLibPath iExpResPath scriptType Instance Attributes: name sourceDir entryPointScript scriptHeader isScriptDebug versionInfo iconFilePath isAutoElevated scriptImports embeddedResources distResources distDirs codeSignConfig codeSignTargets destDirPath","title":"IExpressConfig"},{"location":"IExpress.html#IExpressInstallerProcess","text":"Base Classes: _DistBuildProcessBase, _BuildInstallerProcess Magic Methods: __init__ Instance Methods: onFinalize onIExpressConfig onIExpressPackageProcess onIExpressPackagesBuilt onInitialize onPackagesStaged onPyPackagesBuilt onQtIfwConfig run Class/Static Attributes: DIVIDER","title":"IExpressInstallerProcess"},{"location":"IExpress.html#IExpressPackageProcess","text":"Base Classes: _DistBuildProcessBase, _BuildPackageProcess Magic Methods: __init__ Instance Methods: onFinalize onIExpressConfig onInitialize run Class/Static Attributes: DIVIDER","title":"IExpressPackageProcess"},{"location":"IExpress.html#Functions","text":"","title":"Functions"},{"location":"Issues.html","text":"Troubleshooting \u00b6 Tested Against \u00b6 Python: 2.7 3.5 3.7 3.8 Windows: 7 8.0 10 macOS: Sierra Mojave Linux: Ubuntu 16.04 Ubuntu 18.04 CentOS 7.6 (minimal) OS Language: English PyInstaller: 2.1 3.4 4.0 Binary / Script Qt Installer Framework: 2.0.5 3.0.6 3.1.1 3.2.2 Pip: 8.x 18.x 19.x 20.x Opy distbuilder: 0.9+ Qt C++ Integration: Qt 5.8 Qt 5.14 MSVC MinGW Clang GCC/G++ Binary launching runtime issues \u00b6 Relative resources \u00b6 If your application uses \u201crelative resources\u201d (e.g. images, etc. packaged with it external to the binary), you may encounter problems with such based on the context in which your application is launched. Perhaps the easiest solution to this may be to \u201cforce\u201d the work directory prior to launching the program. That can be accomplished via a \u201cwrapper script\u201d around the binary. See pkgExeWrapperScript and ExecutableScript for help adding this \u201cquick fix\u201d. Here is a better solution\u2026 Rather than depending upon the current working directory being set to your\u2019s program\u2019s location before it is started, you could acquire the directory path programmatically, and then resolving your relative paths to ones which are absolute. In Python, you could use a function such as this absPath example. (Note, the THIS_DIR assignment shown here is valid in both a script and binary (i.e. \u201cfrozen\u201d) context.) import os , sys THIS_DIR = os . path . dirname ( os . path . realpath ( sys . argv [ 0 ] ) ) def absPath ( relativePath ): return os . path . normpath ( os . path . join ( THIS_DIR , relativePath ) ) Unfortunately, in some situations, that preferred approach would take a great deal of effort to apply . In which case, yet another approach could be taken, which resembles the \u201cwrapper script\u201d concept, but is built into your program itself. Just set the working directory when the program is launched, for inside of, and then set it back to what it was upon exit. Python example: import os , sys THIS_DIR = os . path . dirname ( os . path . realpath ( sys . argv [ 0 ] ) ) __INIT_DIR = None def normalizeWorkDir () : global __INIT_DIR __INIT_DIR = os . curdir os . chdir ( THIS_DIR ) def restoreWorkDir () : if __INIT_DIR : os . chdir ( __INIT_DIR ) Example use of the above functions, to place in your \u201centry point\u201d: if __name__ == \" __main__ \" : normalizeWorkDir () launchApp () restoreWorkDir () Crash / failure with no debugging info \u00b6 If a (gui) PyInstaller built application fails, and you are seeking debugging info, refer to the Testing section of the Reference Manual for more details on viewing such. Qt Installer Framework issues \u00b6 Setting QT_IFW_DIR \u00b6 To use the Qt Installer Framework integration (manually), it is recommended to you set the QT_IFW_DIR environmental variable on a permanent (non-volatile) basis (so it doesn\u2019t have to set every time you want to use it). This method makes your build script portable across platforms and on all your project collaborator\u2019s machines. If that proves to be difficult, however, you may set that within the script. Refer to the Installers section of the Reference Manual for details. Setting environmental variables is beyond the scope of this document, but here some places to start looking for help. Windows variables macOS variables Ubuntu variables Launch App at end of install failures \u00b6 If the application appears to run in every other context, except when launched at the end of the Qt installer, a likely reason is that working directory is incorrect when it is executed. This library attempts to set the working directory for any program to the location where it resides implicitly. QtIFW, however, does not currently support setting the working directory as a \u201cRunProgram\u201d directive. A feature request for this was filed with Qt (long ago): https://bugreports.qt.io/browse/QTIFW-217 For now, while there are various potential solutions to this, the best one is arguably to resolve this directly within your program. See Relative resources for more help. If Qt does not finally resolve this themselves sometime in an upcoming IFW release, then distbuilder will provide a built-in work around. Note, this is also a known issue on macOS, when launching via symbolic links added to Applications or the desktop. That is NOT a problem via Windows shortcuts or Linux desktops entries. Windows 8 (and earlier?): Crash at end of install \u00b6 Recent versions of QtIFW have been observed to crash at the end of the installation on Windows 8. This bug has been reported to Qt and they appear to be actively patching it. https://bugreports.qt.io/browse/QTIFW-1248 The current work around is to directly launch the installer with elevated privileges (i.e as an administrator) on this version of Windows. Linux sudo password not accepted \u00b6 It has been observed that sometimes the sudo password is not accepted by the installer when it prompts for it. The contexts and details have yet to be narrowed down. The current work around is to directly launch the installer with elevated privileges (i.e as root / sudo) if you encounter this (inconsistent/odd) behavior. Get Help \u00b6 Refer to Post An Issue .","title":"Troubleshooting"},{"location":"Issues.html#troubleshooting","text":"","title":"Troubleshooting"},{"location":"Issues.html#tested-against","text":"Python: 2.7 3.5 3.7 3.8 Windows: 7 8.0 10 macOS: Sierra Mojave Linux: Ubuntu 16.04 Ubuntu 18.04 CentOS 7.6 (minimal) OS Language: English PyInstaller: 2.1 3.4 4.0 Binary / Script Qt Installer Framework: 2.0.5 3.0.6 3.1.1 3.2.2 Pip: 8.x 18.x 19.x 20.x Opy distbuilder: 0.9+ Qt C++ Integration: Qt 5.8 Qt 5.14 MSVC MinGW Clang GCC/G++","title":"Tested Against"},{"location":"Issues.html#binary-launching-runtime-issues","text":"","title":"Binary launching runtime issues"},{"location":"Issues.html#qt-installer-framework-issues","text":"","title":"Qt Installer Framework issues"},{"location":"Issues.html#get-help","text":"Refer to Post An Issue .","title":"Get Help"},{"location":"Logging.html","text":"Logger class \u00b6 Magic Methods: __init__ Instance Methods: close filePath isOpen isPaused open pause resume toStderr toStderrLn toStdout toStdoutLn write writeLn Instance Attributes: name isUniqueFile Class/Static Methods: isSingletonOpen singleton Logger ( name = None , isUniqueFile = False ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . close ( self ) \u00b6 obj . filePath ( self ) \u00b6 obj . isOpen ( self ) \u00b6 obj . isPaused ( self ) \u00b6 obj . open ( self ) \u00b6 obj . pause ( self ) \u00b6 obj . resume ( self ) \u00b6 obj . toStderr ( self , msg ) \u00b6 obj . toStderrLn ( self , msg ) \u00b6 obj . toStdout ( self , msg ) \u00b6 obj . toStdoutLn ( self , msg ) \u00b6 obj . write ( self , msg ) \u00b6 obj . writeLn ( self , msg ) \u00b6 obj . name class \u2018str\u2019 default: \u201cpymkdocs\u201d \u00b6 obj . isUniqueFile class \u2018NoneType\u2019 default: None \u00b6 Logger . isSingletonOpen () \u00b6 Logger . singleton ( name = None , isUniqueFile = False ) \u00b6 Functions \u00b6 isLogging () \u00b6 log ( msg ) \u00b6 startLogging ( name = None , isUniqueFile = False ) \u00b6 stopLogging () \u00b6","title":"Logging"},{"location":"Logging.html#Logger","text":"Magic Methods: __init__ Instance Methods: close filePath isOpen isPaused open pause resume toStderr toStderrLn toStdout toStdoutLn write writeLn Instance Attributes: name isUniqueFile Class/Static Methods: isSingletonOpen singleton","title":"Logger"},{"location":"Logging.html#Functions","text":"","title":"Functions"},{"location":"LowLevel.html","text":"Low Level Classes And Functions \u00b6 Stand Alone Executables \u00b6 pyScriptToExe \u00b6 To build a stand-alone binary distribution of a Python program, invoke the pyScriptToExe function: pyScriptToExe( name=None, entryPointPy=None, pyInstConfig=PyInstallerConfig(), opyConfig=None, distResources=[], distDirs=[] ) Returns (binDir, binPath) : a tuple containing: the absolute path to the package created, the absolute path to the binary created (within the package). name : The (optional) name given to both the resulting executable and package distribution directory. This argument is only applied if pyInstConfig is None. If omitted, the pyInstConfig attribute for this is used. entryPointPy : The (optional) path to the Python script where execution begins. This argument is only applied if pyInstConfig is None. If omitted, the pyInstConfig attribute for this is used. pyInstConfig : An (optional) PyInstallerConfig object to dictate extended details for building the binary using the PyInstaller Utility. If omitted, the name and entryPointPy arguments, plus other default settings will be used. opyConfig : An (optional) OpyConfig object, to dictate code obfuscation details using the Opy Library. If omitted (or explicitly specified as None), no obfuscation will be performed. See Executable Obfuscation . distResources : An (optional) list of external resources to bundle into the distribution package containing the binary. You may use a simple list of strings containing file/directory names or paths relative to the build script directory. Else, you may provide a list of two element tuples, with a specific source and destination. The source path may be either a relative or absolute path on your file system. The (optional) destination path should be specified relative to the package being created. In addition, source paths may be specified with globing wildcards if desired. They may even include environmental variables or path symbols e.g. ~ (as would be written in a given platform specific shell). Several convenience functions have been provided for building globing patterns. See Globing pattern builders . Regarding the destination argument, note that its default path is the root directory of the package, using the same file name as in the source. To package a resource within a sub directory , or with an alternate name : you must either explicitly provide the relative destination path or use the \u201cshortcut value\u201d True to indicate the source and destination are the same relative paths . distDirs : An (optional) list of directories to create within the package. Note distResources implicitly does this for you when there is a source to copy. This additional option is for adding new empty directories. batchScriptToExe \u00b6 WINDOWS ONLY This function ultimately produces an executable via IExpress . batchScriptToExe( name=None, entryPointScript=None, iExpressConfig=None, distResources=None, distDirs=None ) TODO: Fill in powerShellScriptToExe \u00b6 WINDOWS ONLY powerShellScriptToExe( name=None, entryPointScript=None, iExpressConfig=None, distResources=None, distDirs=None ) TODO: Fill in vbScriptToExe \u00b6 WINDOWS ONLY vbScriptToExe( name=None, entryPointScript=None, iExpressConfig=None, distResources=None, distDirs=None ) TODO: Fill in jScriptToExe \u00b6 WINDOWS ONLY jScriptToExe( name=None, entryPointScript=None, iExpressConfig=None, distResources=None, distDirs=None ) TODO: Fill in installPyInstaller, uninstallPyInstaller \u00b6 Distbuilder builds executables from Python source via PyInstaller. For convenience, these install/uninstall functions for the tool are provided. Note, you may install a specific version if desired, in this (example) manner: installPyInstaller( version=\"3.4\" ) PyInstallerVersion, PyInstallerMajorVer, PyInstallerMajorMinorVer \u00b6 These functions have been provided to help you in circumstances where you need to pivot on the specific PyInstaller version installed. PyInstallerVersion() returns the string representation, pulled directly from the library. PyInstallerMajorVer() , just the major version explicitly cast as an integer. PyInstallerMajorMinorVer() , returns a 2 element tuple with major and minor versions explicitly cast as integers. makePyInstSpec \u00b6 To generate a PyInstaller .spec file, using the secondary utility \u201cpyi-makespec\u201d (bundled with PyInstaller), invoke the makePyInstSpec function: makePyInstSpec( pyInstConfig, opyConfig=None ) **Returns: the absolute path to the spec file created. Also, updates the pyInstConfig argument, supplying a PyInstSpec object and effectively returning it \u201cby reference\u201d. pyInstConfig : An PyInstallerConfig object used to dictate the details for generating the spec file using the makespec Utility. opyConfig : An (optional) OpyConfig object, providing supplemental details regarding the spec file creation. Be sure to include this if you desire obfuscation and will be subsequently invoking the pyScriptToExe function. Installers \u00b6 Upon creating a distribution (especially a stand-alone executable), the next logical progression is to bundle that into a full-scale installer. This library is designed to employ the open source, cross platform utility: Qt IFW (i.e. \u201cQt Installer Framework\u201d) for such purposes. While the prototypical implementation of that tool is with a Qt C++ program, it is equally usable for a Python program (especially if using \u201cQt for Python\u201d, and a QML driven interface\u2026). installQtIfw \u00b6 When the QtIFW utility is required for use by the library (i.e. when buildInstaller is invoked), an attempt will be made to resolve the path to it via a collection of methods. First, if a QtIfwConfig object is provided which specifies a path via the qtIfwDirPath attribute, that will be employed. Second, if there is an environmental variable defined named QT_IFW_DIR , that path will be applied. Next, a default directory where the utility would typically be installed will be checked to see if that exists. If none of these found, distbuilder will simply download the program an install it for you in that \u201cdefault\u201d location, using the download function and this installQtIfw function. If you wish to take control of such yourself, or simply download QtIFW directly for some other purpose, this function provides the means. installQtIfw( installerPath=None, version=None, targetPath=None ) Returns : the absolute path to the directory where the utility was successfully installed. installerPath : (Optional) The path to the QtIFW installer to be run. This may either be a local path or a url to a location on the web. If omitted, the version argument will be used to dynamically resolve the url. version : (Optional) The version of QtIFW desired. This should be provided as a string e.g. \u201c3.1.1\u201d. If installerPath is omitted, this argument will be used to dynamically resolve the url. If this argument is also omitted, a default version will be selected automatically. targetPath : (Optional) The target directory for installation. If omitted, a default path will be used. unInstallQtIfw \u00b6 This is the counterpart to the installQtIfw() function. It will uninstall an existing installation of the QtIFW utility. unInstallQtIfw( qtIfwDirPath=None, version=None ) Returns : a boolean to indicate success or failure. qtIfwDirPath : (Optional) The absolute path to the directory where the utility was installed. (i.e. the return value of installQtIfw() ). If omitted, the version argument will be looked to next. version : (Optional) The version of QtIFW to uninstall. If qtIfwDirPath is omitted, this argument will be used to dynamically resolve the default install path to the utility for the version specified. If this argument is also omitted, a default version will be assumed. buildInstaller \u00b6 buildInstaller( qtIfwConfig, isSilent ) Returns : the absolute path to the setup executable created. qtIfwConfig : A (required) QtIfwConfig object which dictates the details for building an installer. The distbuilder library allows you either define a QtIFW installer in the full/natural manner, and then drawn upon that resource, or it can generate one from entirely from scratch, or any combination thereof is possible. Setting the attribute installerDefDirPath , indicates that the installer definition (or at least part of it) already exists and is to be used. Dynamic components can be defined via attributes for the nested objects of type QtIfwConfigXml , QtIfwControlScript , QtIfwPackage , QtIfwPackageXml , and QtIfwPackageScript . Other key attributes include the pkgName , which is the sub directory where your content will be dynamically copied to within the installer, and the pkgSrcDirPath (most typically the binDir returned by pyScriptToExe ), which is source path of the content. isSilent : When isSilent is enabled, the QtIFW installer produced will not display a GUI or provide any interactive prompts for the user. All options are dictated by command line arguments. While this may certainly be desirable on any platform, it is necessary to create an installer for a target OS with no GUI (e.g. many Linux distros). See Silent Installers for more information. Standard Installer Arguments \u00b6 The standard (non silent) QtIFW installer can accept a collection of command line arguments out of the box. To see the available options, simply pass the switch -h or --help when executing the installer binary from a terminal. The distbuilder library, has added a series of additional options as well (assuming the built-in default Control Script additions are preserved). Unfortunately, there does not appear to be a way to add these to the QtIFW help! Note these differ from the Silent Installer Arguments . The following custom arguments must be passed in the format \u201cKey=Value\u201d : outlog=[path] : The path where you would like output messages written to. The default is <temp dir>/installer.out . errlog=[path] : The path where you would like error messages written to. The default is <temp dir>/installer.err . target=[path] : The target directory for the installation. startmenu=[relative path] : (Windows only) The target start menu directory for shortcuts. install=[ids] : The full set of components to include in the installation, represented as a space delimited list of package ids. Those ids NOT listed, will not be installed (unless some custom logic added to the Control script forces them to be). This list takes priority over any include or exclude arguments. include=[ids] : The components to additionally include in the installation, represented as a space delimited list of package ids. Default components do NOT need to be listed here, as they are already \u201cincluded\u201d implicitly. exclude=[ids] : The components to exclude from in the installation, represented as a space delimited list of package ids. Only default components need to be listed here, those not automatically included they are already \u201cexcluded\u201d implicitly. accept=[true/false] : Enable the check box for accepting the end user license agreement (if applicable). run=[true/false] : Enable the check box for running the target program at the end of the installation (if applicable). reboot=[true/false] : Enable the check box for rebooting the system at the end of the installation (if applicable). onexist=[fail/remove/prompt] : Define the action taken when an existing (conflicting) installation is present. The default is to prompt, and allow for automatic removal if the user so chooses explicitly. mode=[addremove/update/removeall] : This option is provided for controlling how the \u201cMaintenance Tool\u201d is to be run. auto=[true/false] : Enable \u201cAuto pilot\u201d mode. This is very much akin to a running the installation like a Silent Installer , and is in fact at the heart of how that works. Unlike a silent installer, GUI suppression is involved, however, and some of the extended features are not available e.g. error return codes. dryrun=[true/false] : This performs a \u201cdry run\u201d installation, where no core installation or uninstallation operations are performed, but Control Scripts are executed. The wizard quits upon loading the ReadyForInstallation page. This allows for custom coding to detect and report error conditions to be fired off, returning their results to the client program / shell prior to attempting to use the \\ installer. Note: This feature enables \u201cAuto pilot\u201d implicitly. Example use cases for this would include having logic embedded in the Introduction page to automatically abort the installer if a required reboot where detected. Or, the TargetDirectory page could abort the installer when in dry run mode if logic were embedded to validate the target path (vs displaying a non-fatal error dialog to the user when run in the normal interactive mode). Many other examples could be cited. _keeptemp=[true/false] : DEBUGGING feature: Enable to leave scripts in a temp directory, post any dynamic modifications, allowing them to scrutinized / executed directly. This may also be enabled by setting an environmental variable as _keeptemp=true . Silent Installers \u00b6 \u201cSilent installation\u201d is the process of running a installer without any interactive prompts for the user. It simply runs without \u201ctalking\u201d to you. All options are dictated by command line arguments. This allows for scripted installs of programs, which is useful for a great many purposes, e.g. programmatic integrations of external utilities, or running the same installation on a large number of workstations. While such a feature can be desirable on any platform, not requiring a GUI interaction is, of course, outright necessary if one wishes to target an OS with no GUI support (e.g. many Linux distros). \u201cSilent installation\u201d (and/or no GUI) is not a option provided naturally by the Qt Installer Framework. This feature has been made available, however, via this library! As such, it is now easily possible to build installers for environments that would not normally be able via the otherwise excellent installation system Qt has given us. Note that in addition to those major feature additions, a distbuilder silent installer also returns an error code (1) upon failure. A natural QtIFW installer does not, returning a \u201csuccess code\u201d (0) even when the installation fails. Silent Installer Arguments \u00b6 One of the core features of Silent Installers is that they can be driven by command line arguments. The following switches have been provided for this type of distbuilder installer. Note these differ from the Standard Installer Arguments . -h / \u2013help : Display help for these arguments. -v / \u2013version : Display version information. -l / \u2013license : Display license agreement(s). -y / \u2013dryrun : Perform a \u201cdry run\u201d installation, where no core installation or uninstallation operations are performed, but Control Scripts are executed. This allows for custom coding to detect and report error conditions to be fired off, returning their results to the client program / shell prior to attempting to use the \\ installer. -u / \u2013uninstall : Uninstall an existing installation (if found) and exit. -f / \u2013force : \u201cForce\u201d installation. Uninstall an existing installation automatically, in the event that there is a conflict. Without this, the installer will abort under such conditions by default (per the natural QtIFW design). -t / \u2013target [path] : The target directory for the installation. -m / \u2013startmenu [relative path] : (Windows only) The target start menu directory for shortcuts. -c / \u2013components [ids] : The full set of components to include in the installation, represented as a space delimited list of package ids. Those ids NOT listed, will not be installed (unless they are required or some custom logic added to the Control script forces them to be). This list takes priority over any include or exclude arguments. -i / \u2013include [ids] : The components to additionally include in the installation, represented as a space delimited list of package ids. Required/Default components do NOT need to be listed here, as they are already included implicitly. -x / \u2013exclude [ids] : The components to exclude from in the installation, represented as a space delimited list of package ids. Only default components need to be listed here, as those which not automatically included are implicitly excluded by default. Attempts exclude a required package will produce an error . The component selecting arguments are only made available when more than one package is defined for the installer. If there is only a single package, there is not a needed to select/de-select it! When these arguments can be used, the --help text will list the package ids and indicate if they are required or default inclusions. As package ids are defined in the \u201cJava package\u201d format (e.g. \u201ccom.company.product\u201d), and typically installers will all have the same long form prefix for all such ids, that prefix will be truncated for the user\u2019s benefit. So, rather than \u201ccom.company.product\u201d, the id will become simply \u201cproduct\u201d. If any of the packages do not have the same prefix as the rest, they will all be be listed in the long manner. -r / \u2013run : Run the program automatically post installation. This option is only made available when the installer naturally provides the option to choose this at runtime (i.e. in non-silent mode). If the option is not exposed to the user normally, it is not exposed here. When available, this is disabled by default. You must explicitly opt to launch the program by including this switch. -b / \u2013reboot : Reboot the system automatically post installation, if the installer deems that necessary. Otherwise, a message should appear on the terminal instructing the user to do this. This option is only made available when the installer naturally provides the option to choose this at runtime (i.e. in non-silent mode). If the option is not exposed to the user normally, it is not exposed here. When available, this is disabled by default. You must explicitly opt to allow a reboot by including this switch. -o / \u2013outfile : Output messages from the installer are always returned to the client via the stdout stream. When an outfile parameter is provided, such messages will additionally be written to that path. If using this feature, it is up to the client to purge the file. Note that an \u201coutput\u201d file is only produced for \u201cnotable\u201d messages. It does not contain verbose debugging details, nor a simple success message. Most of the time, such a file will not be produced despite specifying this argument. It is only created to pass back important information such as a need to reboot your machine. -e / \u2013errfile : Error messages from the installer are always returned to the client via the stderr stream. When an errfile parameter is provided, such messages will additionally be written to that path. If using this feature, it is up to the client to purge the file. Note that the creation of this file by the installer indicates an error occurred. Conversely, if the installer completed without creating this file, it was successful. Such as also indicated via an exit code, where zero equals success, and any non-zero is an failure. -p / \u2013passthru : Pass arguments through the silent installer wrapper to the QtIFW nested installer core. To pass key/value pairs, use the following example format: MySilentSetup -p \"key1='some value' key2='/some/path'\" -a / \u2013unpassthru : Like --passthru , but for use with --uninstall . Pass direct QtIFW arguments to the nested uninstaller launched by the installer. Note, if used with --passthru , that set of arguments still applies to the installer , while --unpassthru independently applies to the uninstaller . -d / \u2013debug : Enable debugging output. _keeptemp=true : DEBUGGING feature: Leave scripts in a temp directory, post any dynamic modifications, allowing them to scrutinized / executed directly. Enabled by setting an environmental variable as _keeptemp=true . Installer Variables \u00b6 The following constants have been provided, which correspond to dynamic variables resolved at runtime by QtIFW. Note these are applicable for BOTH direct Installer Script generation, and as parameters and attributes for many higher level functions and objects in this library. QT_IFW_DYNAMIC_VARS <LIST CONTAINING ALL OF THESE> QT_IFW_TARGET_DIR QT_IFW_DEFAULT_TARGET_DIR QT_IFW_ROOT_DIR QT_IFW_HOME_DIR QT_IFW_DESKTOP_DIR QT_IFW_APPS_DIR QT_IFW_APPS_X86_DIR QT_IFW_APPS_X64_DIR QT_IFW_STARTMENU_DIR QT_IFW_USER_STARTMENU_DIR QT_IFW_ALLUSERS_STARTMENU_DIR QT_IFW_TEMP_DIR QT_IFW_SCRIPTS_DIR QT_IFW_INSTALLER_TEMP_DIR QT_IFW_MAINTENANCE_TEMP_DIR QT_IFW_INSTALLER_DIR QT_IFW_INTALLER_PATH QT_IFW_PRODUCT_NAME QT_IFW_PRODUCT_VERSION QT_IFW_TITLE QT_IFW_PUBLISHER QT_IFW_URL QT_IFW_USER QT_IFW_OS Note: use joinPathQtIfw to build paths with such constants. Installer Scripting \u00b6 While both QtIFW, and the distbuilder additions to it, provide many build-in features for customizing installers, nothing can provide more open ended flexibility than writing your own scripts. QtIFW scripts are written in Qt Script , which is essentially ECMAScript , which is also the base for JavaScript\u2026 QtIFW uses a custom QScriptEngine under the hood, which injects additional custom objects and methods for this special context. To better understand it, and learn about it\u2019s features in more detail, you should refer to the official QtIFW Manual . The classes QtIfwControlScript and QtIfwPackageScript provide abstraction layers for QtIfw script generation. With these classes you can achieve a great many custom behaviors, driven by scripts, without having to learn too much about Qt Script, and the QtIFW specifics. Python Qt Script Builders \u00b6 Both of the distbuilder script classes (QtIfwControlScript / QtIfwPackageScript) provide the following PYTHON helpers: Static Constants : TAB NEW_LINE END_LINE START_BLOCK END_BLOCK IF ELSE TRY < Note : END_BLOCK required where called for > CATCH < Note : END_BLOCK required where called for , exception called \"e\" > NULL TRUE FALSE ASSIGN NOT EQUAL_TO NOT_EQUAL_TO AND OR CONCAT EXIT_FUNCTION < I . e .: return ;> PATH_SEP MAINTENANCE_TOOL_NAME VERBOSE_CMD_SWITCH_ARG TARGET_DIR_KEY DEFAULT_TARGET_DIR_KEY PRODUCT_NAME_KEY USER_KEY ERR_LOG_PATH_CMD_ARG ERR_LOG_DEFAULT_PATH TARGET_DIR_CMD_ARG START_MENU_DIR_CMD_ARG ACCEPT_EULA_CMD_ARG INSTALL_LIST_CMD_ARG INCLUDE_LIST_CMD_ARG EXCLUDE_LIST_CMD_ARG RUN_PROGRAM_CMD_ARG AUTO_PILOT_CMD_ARG DRYRUN_CMD_ARG TARGET_EXISTS_OPT_CMD_ARG TARGET_EXISTS_OPT_FAIL TARGET_EXISTS_OPT_REMOVE TARGET_EXISTS_OPT_PROMPT MAINTAIN_MODE_CMD_ARG MAINTAIN_MODE_OPT_ADD_REMOVE MAINTAIN_MODE_OPT_UPDATE MAINTAIN_MODE_OPT_REMOVE_ALL OK YES NO CANCEL Static Functions: ifCondition ( condition , isNegated = False , isMultiLine = False ) andList ( conditions ) orList ( conditions ) quote ( value ) _autoQuote ( value , isAutoQuote ) _autoEscapeBackSlash ( value , isAutoEscape ) toNull ( v ) < convert Python None to QtScript null , else pass through > toBool ( b ) < pass Python bool or dynamic QtScript logic as Python string > boolToString ( b ) < pass Python bool or dynamic QtScript logic as Python string > stringToBool ( value , isAutoQuote = True ) setValue ( key , value , isAutoQuote = True ) setBoolValue ( key , b , isAutoQuote = True ) lookupValue ( key , default = \"\" , isAutoQuote = True ) lookupBoolValue ( key , isNegated = False , isHardFalse = False , isAutoQuote = True ) lookupValueList ( key , defaultList = [], isAutoQuote = True , delimiter = None ) ifValueDefined ( key , isNegated = False , isMultiLine = False ) ifBoolValue ( key , isNegated = False , isHardFalse = False , isMultiLine = False ) cmdLineArg ( arg , default = \"\" ) cmdLineSwitchArg ( arg , isNegated = False , isHardFalse = False ) cmdLineListArg ( arg , default = [] ) ifCmdLineArg ( arg , isNegated = False , isMultiLine = False , ) ifCmdLineSwitch ( arg , isNegated = False , isHardFalse = False , isMultiLine = False ) isInstalling ( isNegated = False , isMultiLine = False ) ifInstalling ( isMultiLine = False ) isMaintenanceTool ( isNegated = False ) ifMaintenanceTool ( isNegated = False , isMultiLine = False ) isAutoPilot ( isNegated = False ) ifAutoPilot ( isNegated = False , isMultiLine = False ) isDryRun ( isNegated = False ) ifDryRun ( isNegated = False , isMultiLine = False ) isElevated () ifElevated ( isNegated = False , isMultiLine = False ) elevate () dropElevation () getEnv ( varName , isAutoQuote = True ) pathExists ( path , isNegated = False , isAutoQuote = True ) ifPathExists ( path , isNegated = False , sAutoQuote = True , isMultiLine = False ) makeDir ( path , isAutoQuote = True ) < recursive , path can include native env vars > removeDir ( path , isAutoQuote = True ) < path can include native env vars > writeFile ( path , content , isAutoQuote = True ) < path can include native env vars > deleteFile ( path , isAutoQuote = True ) < path can include native env vars > writeOpDataFile ( fileName , content = \"\" , isAutoQuote = True ) deleteOpDataFile ( fileName ) writeDetachedOpDataFile ( fileName , content = \"\" , isAutoQuote = True ) deleteDetachedOpDataFile ( fileName ) assertInternetConnected ( isRefresh = False , errMsg = None , isAutoQuote = True ) isInternetConnected ( isRefresh = False ) ifInternetConnected ( isRefresh = False , isNegated = False , isMultiLine = False ) isPingable ( uri , pings = 3 , totalMaxSecs = 12 , isAutoQuote = True ) ifPingable ( uri , pings = 3 , totalMaxSecs = 12 , isAutoQuote = True , isNegated = False , isMultiLine = False ) killAll ( exeName , isAutoQuote = True ) targetDir () productName () resolveDynamicVars ( s , varNames = QT_IFW_DYNAMIC_VARS , < None == QT_IFW_DYNAMIC_VARS > isAutoQuote = True ) < returns string > getComponent ( name , isAutoQuote = True ) getPageOwner ( pageName , isAutoQuote = True ) < returns Component > < the following are NOT functional in an uninstaller ! package parameters here can be passed as QtIfwPackage , or the name of such as a raw string ...> isComponentInstalled ( package ) ifComponentInstalled ( package , isNegated = False , isAutoQuote = True , isMultiLine = False ) isComponentSelected ( package ) ifComponentSelected ( package , isNegated = False , isAutoQuote = True , isMultiLine = False ) isComponentEnabled ( package , isAutoQuote = True ) ifComponentEnabled ( package , isNegated = False , isAutoQuote = True , isMultiLine = False ) enableComponent ( package , enable = True , isAutoQuote = True ) debugPopup ( msg , isAutoQuote = True ) warningPopup ( msg , isAutoQuote = True ) errorPopup ( msg , isAutoQuote = True ) yesNoPopup ( msg , title = \"Question\" , resultVar = \"result\" ) yesNoCancelPopup ( msg , title = \"Question\" , resultVar = \"result\" ) switchYesNoCancelPopup ( msg , title = \"Question\" , resultVar = \"result\" , onYes = \"\" , onNo = \"\" , onCancel = \"\" ) ifYesNoPopup ( msg , title = \"Question\" , resultVar = \"result\" , isMultiLine = False ) quit ( msg , isError = True , isSilent = False , isAutoQuote = True ) < It is not possible to re - enable the user prompt after using these !> disableQuit () < negate with disableQuitPrompt > disableQuitPrompt () log ( msg , isAutoQuote = True ) < Windows Only > registryEntryValue ( key , valueName , isAutoBitContext = True , isAutoQuote = True ) assignRegistryEntryVar ( key , valueName , isAutoBitContext = True , varName = \"regValue\" , isAutoQuote = True ) setValueFromRegistryEntry ( key , regKey , valueName , isAutoBitContext = True , isAutoQuote = True ) registryEntryExists ( key , valueName , isAutoBitContext = True , isAutoQuote = True ) ifRegistryEntryExists ( key , valueName , isAutoBitContext = True , isNegated = False , isAutoQuote = True , isMultiLine = False ) registryEntryExistsLike ( key , valueNameContains , isAutoBitContext = True , isCaseSensitive = False , isRecursive = False , isAutoQuote = True ) ifRegistryEntryExistsLike ( key , valueNameContains , isAutoBitContext = True , isCaseSensitive = False , isRecursive = False , isNegated = False , isAutoQuote = True , isMultiLine = False ) registryKeyExists ( key , isAutoBitContext = True , isAutoQuote = True ): pass ifRegistryKeyExists ( key , isAutoBitContext = True , isNegated = False , isAutoQuote = True , isMultiLine = False ) registryKeyExistsLike ( parentKey , childKeyNameContains , isAutoBitContext = True , isCaseSensitive = False , isRecursive = False , isAutoQuote = True ) ifRegistryKeyExistsLike ( parentKey , childKeyNameContains , isAutoBitContext = True , isCaseSensitive = False , isRecursive = False , isNegated = False , isAutoQuote = True , isMultiLine = False ) Python QtIfwControlScript Exclusive Builders \u00b6 In addition, QtIfwControlScript provides: Static Constants : NEXT_BUTTON BACK_BUTTON CANCEL_BUTTON FINISH_BUTTON TARGET_DIR_EDITBOX START_MENU_DIR_EDITBOX ACCEPT_EULA_RADIO_BUTTON RUN_PROGRAM_CHECKBOX FINISHED_MESSAGE_LABEL < Applicable / functional on Component Selection Page ONLY! package parameters here can be passed as QtIfwPackage, or the name of such as a raw string ... > selectComponent( package, isSelect=True, isAutoQuote=True ) selectAllComponents( isSelect=True ) selectDefaultComponents() Static Functions: openViaOs ( path , isAutoQuote = True ) currentPageWidget () assignCurrentPageWidgetVar ( varName = \"page\" ) pageWidget ( pageId ) assignPageWidgetVar ( pageId , varName = \"page\" ) customPageWidget ( pageName ) assignCustomPageWidgetVar ( pageName , varName = \"page\" ) toDefaultPageId ( pageName ) hideDefaultPage ( pageName ) clickButton ( buttonName , delayMillis = None ) enable ( controlName , isEnable = True ) isEnabled ( controlName ) ifEnabled ( controlName , isNegated = False , isMultiLine = False ) setVisible ( controlName , isVisible = True ) isVisible ( controlName ) ifVisible ( controlName , isNegated = False , isMultiLine = False ) getText ( controlName ) setText ( controlName , text , varNames = None , isAutoQuote = True ) ( Note : varNames = None == QT_IFW_DYNAMIC_VARS , varNames = False == No variable resolution ) ( Note : check box controls also work on radio buttons ) isChecked ( checkboxName ) ifChecked ( checkboxName , isNegated = False , isMultiLine = False ) setChecked ( checkboxName , isCheck = True ): < pass Python bool or dynamic QtScript logic > insertCustomWidget ( widgetName , pageName , position = None ) removeCustomWidget ( widgetName ) < CUSTOM ( \"DYNAMIC\" ) PAGES ONLY > enableNextButton ( isEnable = True ) < can 't do on standard wizard pages!> insertCustomPage ( pageName , position ) removeCustomPage ( pageName ) setCustomPageTitle ( title , isAutoQuote = True , pageVar = \"page\" ) setCustomPageText ( title , description , isAutoQuote = True , pageVar = \"page\" ) enableCustom ( controlName , isEnable = True , pageVar = \"page\" ) isCustomEnabled ( controlName , pageVar = \"page\" ) ifCustomEnabled ( controlName , pageVar = \"page\" , isNegated = False , isMultiLine = False ) setCustomVisible ( controlName , isVisible = True , pageVar = \"page\" ) isCustomVisible ( controlName , pageVar = \"page\" ) ifCustomVisible ( controlName , pageVar = \"page\" , isNegated = False , isMultiLine = False ) setCustomText ( controlName , text , isAutoQuote = True , pageVar = \"page\" ) getCustomText ( controlName , pageVar = \"page\" ) isCustomChecked ( checkboxName , pageVar = \"page\" ) setCustomCheckBox ( checkboxName , isCheck = True , pageVar = \"page\" ) ifCustomChecked ( checkboxName , pageVar = \"page\" , isNegated = False , isMultiLine = False ) See QtIfwUiPage Raw Qt Script Helpers \u00b6 If writing scripts directly for distbulder integration, you may also employ the following add-on QT SCRIPT functions: isWindows () isMacOs () isLinux () isElevated () isMaintenanceTool () targetExists () removeTarget () maintenanceToolExists ( dir ) toMaintenanceToolPath ( dir ) Dir . temp () Dir . toNativeSparator ( path ) Dir . fromNativeSparator ( path ) resolveQtIfwPath ( path ) resolveNativePath ( path , isSpaceEscaped ) < isSpaceEscaped NA on Windows > getEnv ( varName ) parentDir ( path ) < null if no parent , e . g . path is root > fileName ( filePath ) rootFileName ( filePath ) dirList ( path , isSortByModTimeAsc ) < path can include native env vars , and wild cards > makeDir ( path ) < recursive > removeDir ( path ) writeFile ( path , content ) < path can include native env vars > deleteFile ( path ) < path can include native env vars > assertInternetConnected ( isRefresh [ = false ], errMsg [ = null ] ) isInternetConnected ( isRefresh [ = false ] ) isPingable ( uri , pings [ = 3 ], totalMaxSecs [ = 12 ] ) resolveDynamicVars ( s , varNames ) < returns string > replaceDynamicVarsInFile ( path , varNames , isDoubleBackslash ) clearErrorLog () writeErrorLog ( msg ) sleep ( seconds ) killAll ( progName ) quit ( msg , isError , isSilent ) abort ( msg ) silentAbort ( msg ) execute ( binPath , args ) executeDetached ( binPath , args ) executeShellCmdDetached ( cmd ) executeHidden ( binPath , args , isElevated ) < Windows Only > maintenanceToolPaths () < resolves via registry lookups > isOsRegisteredProgram () registryKeyExists ( key , isAutoBitContext ) registryKeyExistsLike ( parentKey , childKeyNameContains , isAutoBitContext , isCaseSensitive , isRecursive ) registryEntryValue ( key , valueName , isAutoBitContext ) registryEntryExists ( key , valueName , isAutoBitContext ) registryEntryExistsLike ( key , valueNameContains , isAutoBitContext , isCaseSensitive , isRecursive ) executeBatchDetached ( scriptPath , bat , args ) executeVbScript ( vbs ) executeVbScriptDetached ( scriptPath , vbs ) executePowerShell ( ps ) executePowerShellDetached ( scriptPath , ps ) < Package Context Only > addVbsOperation ( component , isElevated , vbs ) setShortcutWindowStyleVbs ( shortcutPath , styleCode ) < Mac / Linux Only > executeShellScript ( script ) isPackageInstalled ( pkg ) installPackage ( pkg ) unInstallPackage ( pkg ) isPackageManagerInstalled ( prog ) isAptInstalled () isDpkgInstalled () isYumInstalled () isRpmInstalled () < the following are NOT functional in an uninstaller !> getComponent ( name ) < throws on invalid name , or in any uninstall context > isComponentInstalled ( name ) isComponentSelected ( name ) isComponentEnabled ( name ) enableComponent ( name , enable [ = true ] ) getPageOwner ( pageName ) < throws on invalid name > insertCustomWidget ( widgetName , pageId , position ) removeCustomWidget ( widgetName ) insertCustomPage ( pageName , position ) removeCustomPage ( pageName ) setCustomPageText ( page , title , description ) QtIfwPackage list manipulation \u00b6 These functions are useful within an overridden version of onPyToBinPkgsBuilt in a RobustInstallerProcess , object findQtIfwPackage( pkgs, pkgId ) Returns : QtIfwPackage object within the pkgs argument with the id supplied by pkgId . removeQtIfwPackage( pkgs, pkgId ) Removes the QtIfwPackage within the pkgs argument with the id supplied by pkgId . mergeQtIfwPackages( pkgs, srcId, destId ) Merges the QtIfwPackage objects within the pkgs argument with the ids supplied by srcId and destId . \u201cMerging\u201d first of all entails a recursive content merge of the source into the target via mergeDirs . In addition, a number of other configuration details will be \u201cmerged\u201d as well. Examples of such include combining the lists of QtIfwShortcut objects, QtIfwExternalOp objects, QtIfwExternalResource objects, etc., drilling down in to the QtIfwPackageScript contained within the packages. The package scripts are regenerated during a subsequent build process to reflect these changes. Note that any attributes of the source package, which aren\u2019t explicitly handled by the library in this operation, will likely be lost! Some detailed inspection, and further customizations to the result, may need to be made post merge for a given use case, if the desired effect fails. Note that if the source package has a subDirName attribute, that detail will be preserved. I.e. the merge will retain the sub directory encapsulation. This function ultimately consolidates the package items in the list and returns the destination object. nestQtIfwPackage( pkgs, childId, parentId, subDirName=None ) \u201cNests\u201d the \u201cchild\u201d QtIfwPackage object within the \u201cparent\u201d, modifying the pkgs collection supplied. \u201cNesting\u201d entails moving the child content into a sub directory of the parent as well as combining the QtIfwShortcut list nested inside the QtIfwPackageScript objects, followed by script regeneration to reflect that. Note that (most) other attributes of the source package are lost! Exceptions to that would be dynamically generated content, e.g. wrapper scripts, which were already added to the content. Other customizations which need to be made must be applied post merge. If a subDirName value is provided, that will be used to name the nested directory. If omitted, the child\u2019s package name will be used (or a truncated version of that if the child and parent share a common package name \u201cprefix\u201d). If the source package has a subDirName attribute, that detail will be overridden by this nesting. I.e. this will NOT nest the content two levels deep. This function ultimately consolidates the package items in the list and returns the destination object. Code Obfuscation \u00b6 Code obfuscation is the process of rewriting normal, human readable code, into a form which is very difficult (well, ideally impossible) to read, yet still executes in exactly the same manner when run through the target translator (or compiler). The reason one would want to do this to is to protect proprietary work and/or to eliminate security holes (based upon context) while sharing source code. Opy for Distribution Builder is an obfuscation library for Python. It can be used for protecting source that will be shared directly, or as an additional layer of protection behind binaries built with PyInstaller. While Opy does not protect your code as well as real compilation does, it\u2019s far better than nothing! The obfuscation process is \u201clossy\u201d, so while the end result still functions as desired, Opy inherently destroys the clear text original names for functions, classes, objects, etc. A hacker might still figure out some \u201csecret\u201d after putting in a good deal of effort, but no one can\u2019t just walk away with your body of the work on the whole, or instantly spot your security secrets. Executable Obfuscation \u00b6 Why would you need to obfuscate when building executable binaries? Aren\u2019t they implicitly protected by virtue to being compiled? Well, the thing is you don\u2019t literally \u201ccompile\u201d when using PyInstaller (or Py2Exe, etc.)! The mechanism for creating standalone Python executables works by creating .pyc files and bundling them with a Python interpreter into a neat package. Unfortunately .pyc can be reverse engineered back into the original (or nearly original) .py source. As a quick starting point to learn about this hacking process, you can check out these Stack Overflow posts: How do you reverse engineer an EXE compiled with PyInstaller? Is it possible to decompile a compiled .pyc file into a .py file? If you don\u2019t trust posts from \u201crandom\u201d third parties, simply read this - straight from the horse\u2019s mouth: PyInstaller Docs: Hiding The Source Code One \u201csolution\u201d to this problem is to bundle .pye files instead of .pyc . PyInstaller provides built-in support for this, in fact. The alternate .pye is an encrypted equivalent to a .pyc . If your end user is in possession of the decryption key, they can run the code, because it will be unlocked for them to begin the process of running it. Unfortunately, that still ultimately exposes the code! It merely restricts access. If your goal is to distribute a program, for which you want to prevent access to the source, then you couldn\u2019t distribute the key! So, this security measure is only really pertinent when it is possible for someone to access the program independently from the key, and the target user being given the key can be trusted with the raw source. That\u2019s a fairly atypical use case\u2026 obfuscatePy \u00b6 To generate an obfuscated version of your project (without converting it to binary) invoke obfuscatePy: obfuscatePy( opyConfig ) Returns (obDir, obPath) : a tuple containing: the absolute path to the obfuscated package, the absolute path to the obfuscated entry point script (within the package). opyConfig : An OpyConfig object, which dictates the code obfuscation details using the Opy Library. Upon invoking this, you will be left with an \u201cobfuscated\u201d directory adjacent to your build script. This is a useful preliminary step to take, prior to running pyScriptToExe, so that you may inspect and test the obfuscation results before building the final distribution package. Library Obfuscation \u00b6 obfuscatePyLib \u00b6 To generate an obfuscated version of your project, which you can then distribute as an importable library, invoke obfuscatePyLib: obfuscatePyLib( opyConfig, isExposingPackageImports=True, isExposingPublic=True ) Returns (obDir, setupPath) : a tuple containing: the absolute path to the obfuscated directory, the absolute path to the (non obfuscated) setup.py script within the prepared package opyConfig : An OpyConfig object, to dictate code obfuscation details using the Opy Library. isExposingPackageImports : Option to NOT obfuscate any of the imports defined in the package entry point modules (i.e. init .py files). This is the default mode for a library. isExposingPublic : Option to NOT obfuscate anything which it is naturally granting public access (e.g. module constants, functions, classes, and class members). All locals and those identifiers prefixed with a double underscore (denoting private) will be still be obfuscated. This is the default mode for a library. Obfuscation Features \u00b6 The Opy Library contains an OpyConfig class, which has been extended by the distbuilder library (and aliased with the same name). The revised / extended class contains attributes for patching the obfuscation and for bundling the source of external libraries (so that they too maybe obfuscated). This new configuration type has the notable additions: patches bundleLibs sourceDir OpyPatch \u00b6 Opy is not perfect. It has known bugs, and can require a bit of effort in order to define a \u201cperfect\u201d configuration for it. In the event you are struggling to make it work exactly as desired, an \u201ceasy out\u201d has been provided by way of \u201cpatching\u201d the results. If you have already determined exactly which files/lines/bugs you are encountering, you may simply define a list of \u201cOpyPatch\u201d objects for the configuration. They will be applied at the end of the process (i.e. to the obfuscated code) to fix any problems. An OpyPatch is created via: OpyPatch( relPath, patches, parentDir=OBFUS_DIR_PATH ) relPath : The relative file path within the obfuscation results that you wish to change. patches : A list of tuples. 2 element tuples in the form (line number, line) will be utilized for complete line replacements. Alternatively, 3 element tuples in the form (line number, old, new) will perform a find/replace operation on that line (to just swap out an identifier typically). parentDir : An (optional) path to use a directory other than the standard obfuscation results path. LibToBundle \u00b6 When an OpyConfig object is created, the sourceDir defaults to THIS_DIR . If the bundleLibs attribute is defined, it is used in combination with sourceDir to create a \u201cstaging directory\u201d. The bundleLibs attributes may be either None or a list of \u201cLibToBundle\u201d objects, constructed via: LibToBundle( name, localDirPath=None, pipConfig=None, isObfuscated=False ) That class has attributes named likewise, which may be set after creating such an object as well. name : The name of the library, i.e. the name to be given to the bundled package. localDirPath : If this library may be simply copied from a local source, this is the path to that source. Otherwise, leave this as None. pipConfig : A PipConfig object defining how to download and install the library. The destination will be automatically set to the \u201cstaging directory\u201d for the obfuscation process. isObfuscated : A boolean indicating if the library is already obfuscated, and therefore may be bundled as is. createStageDir \u00b6 In the event that defining bundleLibs for an OpyConfig object will not suffice to setup your staging directory, you may instead call: createStageDir( bundleLibs=[], sourceDir=THIS_DIR ) Returns: the path to the newly created staging directory. After doing this, you may perform any extended operations that you require, and then set an OpyConfig object\u2019s sourceDir to that staging path while leaving bundleLibs as None in the configuration. Note that the OpyConfig external_modules list attribute must still be set in such a manner to account for the libraries which were bundled, or which remain as \u201cexternal\u201d imports. Library Installation \u00b6 updatePip \u00b6 Distbuilder installs libraries via pip. It is itself, also installed in via the same means! While no feature is provided to fully uninstall / re-install (since doing so would break core features of the library), a convenience method to update pip was provided. installLibrary \u00b6 To install a library (via pip), invoke installLibrary. Note: that installLibraries (plural) may used to install multiple libraries in a single call. installLibrary( name, opyConfig=None, pipConfig=PipConfig() ) Returns: None name : The name/source of the library. If the library is your current project itself and you are obfuscating it, be sure to supply the name you are giving it. If you are NOT obfuscating it, specify \u201c.\u201d instead. If you wish to install a remote package registered with pip (i.e. the typical way pip is used), simply supply the name. If you wish to use a local path, or a specific url (http/git), see PipConfig (and perhaps the pip documentation for details). opyConfig : An (optional) OpyConfig object, to dictate code obfuscation details using the Opy Library. If omitted, no obfuscation will be performed. If you are building an obfuscated version of your project as a importable library, this function is useful for testing the operations of your library post-obfuscation/pre-distribution. This will run obfuscatePyLib with default arguments, install the library, and remove the temporary obfuscation from the working directory. pipConfig : An (optional) PipConfig object, to dictate extended installation details. If omitted, the library is simply installed in the standard manner to your (global) Python site packages. Notable attributes include incDpndncsSwitch , destPath and asSource . These allow you to skip dependency gathering if desired, install to a specific path such as a temp build directory, and to request raw .py scripts be placed there. Note that remote raw pip packages will require an alternate \u201cvcs url\u201d be supplied to a \u201cdevelopment\u201d repository in place of the simple package name. See editable installs installLibraries \u00b6 installLibraries( *libs ) This function is a convenience wrapper over installLibrary (singular) function. One of the primary uses for this function is to ensure that the product to be created by a build script is being run in an environment which has all of its dependencies. Returns: None *libs : This function is extremely flexible in terms of how it may be invoked. The libs argument maybe a tuple, a list, or a series of arguments passed directly to the function of arbitrary length. The arguments or collection may consist of simple strings (i.e. the library names), or be tuples / dictionaries themselves. When passing tuples, or dictionaries, they will be treated as the argument list to installLibrary(). Simple example: installLibraries( 'six', 'abc' ) Simple example with a version detail: installLibraries ( 'six' , 'abc' , 'setuptools==40.6.3' ) Complex example: opyCfg = OpyConfig() ... pipCfg = PipConfig() ... myLib = {'name':'MyLib', 'opyConfig':opyCfg, 'pipConfig':pipCfg } installLibraries( 'six', myLib ) uninstallLibrary \u00b6 uninstallLibrary( name ) Returns: None Simply uninstalls a library from Python site packages in the basic/traditional pip manner. vcsUrl \u00b6 vcsUrl( name, baseUrl, vcs=\"git\", subDir=None ) Convenience function to build vcsUrls from their component parts. This is to be used in conjunction with the PipConfig attribute asSource. See https://pip.pypa.io/en/stable/reference/pip_install/#vcs-support Testing \u00b6 run \u00b6 Upon creating a binary with PyInstaller, use the following to test the success of the operation: run( binPath, args=[], wrkDir=None, isElevated=False, isDebug=False, askpassPath=None ) binPath : The path to the binary to be executed. Note that the path is returned by pyScriptToExe , which allows the results of that to flow directly into this function. args : An (optional) list of arguments, (or a flat string) to pass along to your program. wrkDir : An (optional) working directory specification. If omitted (or None), the working directory will be automatically set to that of the binary path specified. isElevated : Boolean (option) to run the binary with elevated privileges. isDebug : Boolean (option) for explicitly displaying standard output and standard error messages. Set this to True to debug a PyInstaller binary which was created with pyInstConfig.isGui set to True . On some platforms, when that configuration is used, messages sent to the console (e.g. print statements or uncaught exceptions ) are not visible even when launching the application from a terminal. Enabling this option, however, will expose those messages to you. This can be invaluable for debugging problems that are unique to a stand-alone binary, and not present when run in the original raw script form. For instance, it is common for PyInstaller binaries to be missing dependencies which must be accounted for (e.g. via \u201chidden imports\u201d). In such situations, exceptions maybe thrown when the app launches. Without this debugging feature, you may have no information regarding the fatal error. Note: When run employees the debugging feature, it will set an environmental variable named DEBUG_MODE to 1 . Some contexts require this in order to allow this mode to work correctly. You may wish to include your own custom logic within your program to pivot on this environmental condition as well. While distbuilder provides convenience constants/methods to determine if you are running in this context, to avoid any \u201ctight coupling\u201d to the build system within your program\u2019s source (which may cause build failures in addition to being a questionable design choice), you may wish to employ the following code: def isDebug (): try : return isDebug . __CACHE except : from os import environ isDebug . __CACHE = environ . get ( \"DEBUG_MODE\" ) == \"1\" return isDebug . __CACHE Note: In some contexts, you will NOT see the debugging output until the executable has terminated. On Windows, this may occur when using debug mode in combination with isElevated enabled, if you are NOT already running as an admin. On macOS, this will occur whenever using a \u201cwrapper script\u201d (see QtIfwExeWrapper ) over the binary. Note: some IDE / platform combinations may render this feature inoperable due to a conflict with output stream handling, in which case simply execute the build script, or the run function, from a terminal outside of the IDE when employing isDebug . askpassPath : This argument is only applicable on LINUX . If you needed to invoke this function from a non-tty gui context, e.g. via your IDE, while isElevated is enabled, an \u201cask password\u201d utility e.g. \u201cOpenSSH Askpass\u201d will be required in order for you to input your password to gain sudo rights. If this is required for given task under the hood within the library, but your system is not yet configured for this, this function will fail with a fatal error, and output instructions to your console or log file for how to proceed. In the event you wish to employ a specific / custom \u201cask pass\u201d program, when invoking this run function directly, you may specify the path to it via this argument. runPy \u00b6 Perhaps most notable, upon creating a Python obfuscation, you may wish the to test the success of that operation. The following was provided with that in mind specifically: runPy( pyPath, args=[], isElevated=False, askpassPath=None ) pyPath : The path to the script to be executed. Note that the path is returned by obfuscatePy , which allows the results of that to flow directly into this function. args : An (optional) list of arguments, (or a flat string) to pass along to your program. isElevated : Boolean (option) to run the binary with elevated privileges. askpassPath : This argument is only applicable on LINUX . See the description for this in the run function documentation. The working directory will be automatically set to the directory of the python script. Testing installers \u00b6 The following two options are available for a QtIFW installer: 1) Manually run the installer with the \u201c-v\u201d switch argument. Or, if running it via this library using the run(...) function, you can pass the QT_IFW_VERBOSE_SWITCH constant as an argument. 2) If the build process is failing before you can run the installer, try setting qtIfwConfig.isDebugMode to True for verbose output (note this should currently be the be the default now). Archives and Distribution \u00b6 Once you have a fully built distribution package, the following functions provide an easy means for further preparing the program for distribution: toZipFile \u00b6 toZipFile( sourceDir, zipDest=None, removeScr=True, isWrapperDirIncluded=False ) Returns : the path to the zip file created. sourceDir : the directory to convert to a zip (typically the binDir). zipDest : (optional) full path to the zip file to be created. If not specified, it will be named with same base as the source, and created adjacent to it. removeScr : Option to delete the sourceDir after creating the archive. Note this is the default behavior. isWrapperDirIncluded : Option to include the outer \u201cwrapper\u201d directory, or else put the contents on the root of the archive. toCabFile \u00b6 WINDOWS ONLY toCabFile( sourceDir, zipDest=None, removeScr=True, isWrapperDirIncluded=False ) Returns : the path to the cabinet file created. sourceDir : the directory to convert to a cab (typically the binDir). cabDest : (optional) full path to the cab file to be created. If not specified, it will be named with same base as the source, and created adjacent to it. removeScr : Option to delete the sourceDir after creating the archive. Note this is the default behavior. isWrapperDirIncluded : Option to include the outer \u201cwrapper\u201d directory, or else put the contents on the root of the archive. TODO: Add git commit/push\u2026 ExecutableScript \u00b6 Executable scripts have wide ranging potential for use with this library. They may be employed as part of the build process, deployed with a distribution, or run in an embedded process of some form. The ExecutableScript class is used to generate / bundle scripts. By default, the script is a batch file on Windows, or a shell script on Linux or Mac. The class QtIfwExternalOp ) optionally employs this class to embedded custom installer scripts into it\u2019s processes. The class QtIfwExeWrapper ) often contains a class of his type, used as a \u201cwrapper\u201d over a deployed executable. In some contexts, that wrapper mechanism is implicitly employed by deployment preparing tools the library leans on, and/or is added directly by distbuilder. Class PyInstHook ) is a derived class from ExecutableScript. Note that it is a Python script rather than the default type for a given platform. Constructor: ExecutableScript( rootName, extension=True, shebang=True, script=None, scriptPath=None, scriptDirPath=None, replacements={}, isDebug=True ) Attributes & default values: rootName <required> extension=True # i.e. True==automatic shebang=True # i.e. True==automatic script=None scriptDirPath=None replacements={} isIfwVarEscapeBackslash=False isDebug=True Functions: fileName() filePath() exists( scriptDirPath=None ) read( scriptDirPath=None ) write( scriptDirPath=None ) remove( scriptDirPath=None ) __str__ <i.e. built-in to string supported> asSnippet() toLines() fromLines( lines ) injectLine( injection, lineNo ) toBase64( toString=False ) fromBase64( data ) debug() Static Functions: typeOf( path ) strToLines( s ) linesToStr( lines ) Static Constants: SHELL_EXT BATCH_EXT VBSCRIPT_EXT JSCRIPT_EXT POWERSHELL_EXT APPLESCRIPT_EXT SUPPORTED_EXTS <list> Details: rootName : The name of script without the extension. If this is used as an \u201cexe/binary wrapper\u201d, this name should normally align with the root of that binary\u2019s name, which may be acquired with rootFileName( path ) . extension : The file extension used when creating the file. If True , the extension will be automatically assigned. This defaults to bat on Windows, sh on Mac and Linux. If set to None , there will be no extension on the file. A user supplied string will be applied if custom provided. shebang : A \u201cshebang\u201d injected into the top of the script automatically. On Windows, this attribute is not used. Else, if True , #!/bin/sh will be used. A user supplied string will be applied if custom provided. script : The content for the for script, provided as a string, or a list (representing lines). scriptPath : The content for the for script, provided to the constructor as a file path to source for where it is to be extracted. Use the filePath() function later if you need this apth again. scriptDirPath : Optional. During construction, this may be explicitly defined, or left as None to imply THIS_DIR . If a scriptPath is specified, a directory path extracted from that will be used. On subsequent calls to read( scriptDirPath ) , write( scriptDirPath ) , or remove( scriptDirPath ) , the scriptDirPath will be updated if supplied (i.e. not None ). replacements : A dictionary of \u201cplaceholder\u201d keys and \u201csubstitution\u201d values in the script. Place holders must defined in the script with the surrounding brackets, i.e in the form \u201c{placeholder}\u201d. The keys in replacements dictionary should not, however, include the brackets. This is similar to the built-in string format function, of course, but works better in scripts which use brackets for other purposes. asSnippet() : Use this function when \u201cpasting\u201d scripts together. isIfwVarEscapeBackslash : If employing this class within a QtIfwExternalOp , enabling this attribute with cause dynamically resolved installer driven paths to be injected into the script with backslashes doubled up, thereby escaping them in certain scripting languages / string literal contexts. Code Signing \u00b6 \u201cCode signing\u201d an executable file is a means to provide proof that a program was produced by a party who can be identified and trusted to not install viruses or malware on to your PC. This mechanism may be thought of as a \u201cfirst line of defense\u201d for virus checkers and security tools. Explicitly installing a \u201cTrusted Software Publisher Certificate\u201d maybe necessary for the digital signature on a file to be validated, if the file was signed by an unknown \u201cCertification Authority\u201d. All major operating systems ship with a host of standard \u201cCA certs\u201d pre-installed, but will also allow the manual addition of such to supplement those included out-of-the-box. signExe \u00b6 signExe( exePath, codeSignConfig ) Returns : exePath exePath : The path to the executable to be code signed. codeSignConfig : CodeSignConfig object generateTrustCerts \u00b6 generateTrustCerts( certConfig, keyPassword=None, isOverwrite=False ) Creates self-sign certificates and keys. Returns : (CA Cert Path, Key Path) certConfig : SelfSignedCertConfig keyPassword : Recommend using the function getPassword to set this. isOverwrite : Recommend keeping this as False in production context, and only making True is you are certain you want to regenerate existing files. TrustInstallerBuilderProcess \u00b6 A PyToBinPackageProcess derivative. Builds an installer based upon a ConfigFactory . That ConfigFactory maybe most easily generated via the convenience function: trustCertInstallerConfigFactory \u00b6 trustCertInstallerConfigFactory( companyTradeName, caCertPath, keyFilePath, keyPassword=None, companyLegalName=None, version=(1,0,0,0), iconFilePath=None, isSilent=False, script=None ) Module import utilities \u00b6 modulePath \u00b6 modulePath ( moduleName ) The absolute path to an importable module\u2019s source. (Note the moduleName argument should be a string, not an unquoted, direct module reference.) This is useful for dynamically resolving the path to external modules which you may wish to copy / \u201cbundle\u201d for obfuscation. Returns None if the name is invalid and/or the path cannot be resolved. Note that this often resolves the path to a library\u2019s package entry point (i.e. an init .py) file where the module is initially imported, rather than literal module path. Normally modulePackagePath will be more useful\u2026 modulePackagePath \u00b6 modulePackagePath ( moduleName ) Similar to modulePath, but this return the module\u2019s parent directory. More often than not, a module will have dependencies within the package / library where it resides. As such, resolving the package path can be more useful than the specific module. sitePackagePath \u00b6 sitePackagePath( packageName ) Similar to modulePackagePath, but takes the package name rather than a module within it AND is specific to the site packages collection of libraries, rather than a more universal path resolution. isImportableModule, isImportableFromModule \u00b6 isImportableModule( moduleName ) isImportableFromModule( moduleName, memberName ) Attempts the import, and returns a boolean indication of success without raising an exception upon failure. Like the related functions here, the arguments are expected to be strings (not direct references). The purpose of this to test for library installation success, or to preemptively confirm the presence of dependencies. importFromPath \u00b6 importFromPath( path, memberName=None ) Imports a module, or a select member from it, via the explicit path to that script, and returns the reference. Example: myFunc = importFromPath( \"/path/to/myscript.py\", \"myFunc\" ) myFunc( someArg ) This can be very useful for cross project integrations where you want to import modules, or members of them, which are not part of an installed system library or if they are located in a path where a standard import cannot be employed directly. Logging \u00b6 Distbuilder often produces extensive debugging output when running assorted processes. It may prove cumbersome, if not impossible, to read through such from a terminal, or from within an IDE. In which case, the built in logging mechanisms can be drawn upon to resolve this. The easiest way to log the output of distbuilder processes, is to simply call startLogging() at the top of your script. This will redirect all print statements, along with the stdout and stderr streams of sub processes, to a (default named) log file. When logging in the standard manner and an uncaught exception occurs, the stack trace for that will appear both in the log, and in the console where the script was launched. If desired, you may also explicitly create your own Logger objects and call their functions e.g. write( msg ) directly. This maybe useful if you wish to split logs across multiple files for different parts of a build process. Note that only the primary/singleton instance will have implicit stream redirections applied though. So, if there is no multi-threading / parallel processing dimension to your use case, you may alternatively wish use the pattern stopLogging \u2026 startLogging( \"MyAltLogName\" ) to achieve a \u201csplit log\u201d result. startLogging \u00b6 startLogging( name=None, isUniqueFile=False ) Start the primary/singleton logger. name : If omitted, the name is auto assigned, based on the entry point script name (e.g. \u201cbuild\u201d). The Logger name will dictate the name of the file produced. isUniqueFile : If this is enabled, the file produced will have a unique name, i.e. will have a time stamp suffix. Else, a prior/existing log (of the same name) will be overwritten. stopLogging \u00b6 stopLogging() Stop the primary/singleton logger. Typically, you may omit invoking this explicitly. When the script ends, all open Loggers will be gracefully closed automatically. Allowing that to occur \u201cnaturally\u201d will also result in a message being sent to the console indicating when a script has completed without an uncaught exception being encountered. log \u00b6 log( msg ) Log a message with the primary/singleton logger, if it is in use . isLogging \u00b6 isLogging() Check if the primary/singleton logger is in use. Logger \u00b6 Class used for logging messages to files, e.g. debugging details and process results. Constructor: Logger( name=None, isUniqueFile=False ) Attributes: name = <client supplied, or auto defined> isUniqueFile = False Object Methods: open () close () pause () resume () write ( msg ) toStdout ( msg ) toStderr ( msg ) writeLn ( msg ) toStdoutLn ( msg ) toStderrLn ( msg ) isOpen () isPaused () filePath () Static Methods: singleton( name=None, isUniqueFile=False ) isSingletonOpen() Utility Functions \u00b6 The following low level \u201cutilities\u201d are also provided for convenience, as they maybe useful in defining the build parameters, further manipulating the package, or testing the results, etc. absPath \u00b6 THIS_DIR The path to the directory which contains the build script. absPath( relativePath, basePath=None ) Convert a relative path to an absolute path. If a basePath is not specified, the path is re resolved relative to THIS_DIR (which may or MAY NOT be the current working directory ). homePath, desktopPath \u00b6 homePath( relPath=None ) desktopPath( relPath=None ) Convert a relative path to an absolute path, within the current user\u2019s home directory or desktop directory. joinPathQtIfw \u00b6 Use this function to build paths within QtScript building contexts and to supply arguments for QtIFW operations. The paths will be joined in a platform agnostic manner. Note, use joinPath to build paths in a platform specific manner, resolved at build time. qtIfwDynamicValue \u00b6 qtIfwDynamicValue( name ) Use this function to produce the resolution of dynamic substitution variables at runtime, which are utilized by QtIFW operations and scripts in all contexts (directly or indirectly) on a target machine. These values are often paths to files or directories on the target, or embedded resources in the installer, but may in fact be used for strings containing any content, which the installer knows how to resolve. qtIfwOpDataPath \u00b6 qtIfwOpDataPath( rootFileName ) qtIfwDetachedOpDataPath( rootFileName ) Use these functions, within QtScript building contexts, to resolve dynamic temp paths at runtime, which are utilized by installer operations. Only use qtIfwDetachedOpDataPath if you need the temp file to exist after the installer/uninstaller has terminated, i.e. for \u201cdetached\u201d operations. Note that such a temp path becomes the responsibility of the client operation to purge. isParentDir \u00b6 isParentDir( parent, child, basePath=None ): Returns : true/false, the parent / child paths specified, exist and have such a relationship to one another. The paths maybe relative or absolute. basePath is optionally used for relative paths. To actually get the parent directory, use dirPath . Copy or Move To Dir \u00b6 copyToDir( srcPaths, destDirPath ) Returns : the destination path(s) to the file(s) / directory(ies). Copies files OR directories to a given destination. The argument srcPaths may be a singular path (i.e. a string) or an iterable (i.e. a list or tuple). This replaces any existing copy found at the destination path. When relative paths are specified, they are resolved via absPath . moveToDir( srcPaths, destDirPath ) Moves files OR directories to a given destination. The argument srcPaths may be a singular path (i.e. a string) or an iterable (i.e. a list or tuple). (Note: it moves the path specified, it does not leave a copy of the source). This replaces any existing copy found at the destination path. When relative paths are specified, they are resolved via absPath . copyToDesktop( path ) moveToDesktop( path ) copyToHomeDir( path ) moveToHomeDir( path ) Convenience wrapper functions which directly imply the destination. removeFromDir \u00b6 removeFromDir( subPaths, parentDirPath ) Removes files OR directories from a given directory. The argument subPaths may be a singular path (i.e. a string) or an iterable (i.e. a list or tuple). A subPath argument must be relative to the parentDirPath . When relative paths are specified for parentDirPath , they are resolved via absPath . renameInDir \u00b6 renameInDir( namePairs, parentDirPath ) Renames files OR directories with a given directory. The argument namePairs may be a singular tuple (oldName, newName) or an iterable (i.e. a list or tuple) of such tuple pairs. When relative paths are specified for parentDirPath , they are resolved via absPath . collectDirs \u00b6 collectDirs( srcDirPaths, destDirPath ) Moves a list of directories into a common parent directory. That parent directory will be created is it does not exist. When relative paths are specified or parentDirPath , they are resolved via absPath . mergeDirs \u00b6 mergeDirs( srcDirPaths, destDirPath, isRecursive=True ) Move the contents of a source directory into a target directory, over writing the target contents where applicable. If performed recursively, the destination contents contained within a merged sub directory target are all preserved. Otherwise, the source sub directories replace the target sub directories as whole units. When relative paths are specified, they are resolved via absPath . normBinaryName \u00b6 normBinaryName( path, isPathPreserved=False, isGui=False ) The \u201cnormalized\u201d name of a binary, resolving such for cross platform contexts. On Windows, binaries normally end in a \u201c.exe\u201d extension, but on other platforms they normally have no extension. On macOS, binaries to be launched with a GUI, normally have a \u201c.app\u201d extension (vs none when they do not have a GUI). That additional logic is applied when isGui is True . When isPathPreserved is True , the entire path is returned rather than only the file name. When False (the default) a full path is stripped down to the base name. normIconName \u00b6 normIconName( path, isPathPreserved=False ) The \u201cnormalized\u201d name of an icon, resolving such for cross platform contexts. On Windows, icons end in a \u201c.ico\u201d extension, on macOS \u201c.icns\u201d files are used. In Linux, there is no fixed standard exactly on icons, since many distros are non-gui, and as such Linux binaries do not have icons embedded in them. For Linux desktops, however, it is common place to use external \u201c.png\u201d files to create icons which point to binaries. When isPathPreserved is True , the entire path is returned rather than only the file name. When False (the default) a full path is stripped down to the base name. normLibName \u00b6 normLibName( path, isPathPreserved=False ) The \u201cnormalized\u201d name of a library file, resolving such for cross platform contexts. On Windows, \u201clibrary\u201d files end in a \u201c.dll\u201d extension, where on macOS and Linux \u201c.so\u201d is employed. When isPathPreserved is True , the entire path is returned rather than only the file name. When False (the default) a full path is stripped down to the base name. Globing pattern builders \u00b6 The following functions provide pattern strings, containing wild cards. allPathPattern( basePath ) extPathPattern( ext, basePath=None ) startsWithPathPattern( match, basePath=None ) endsWithPathPattern( match, basePath=None ) containsPathPattern( match, basePath=None ) Note: If the primary (first) argument supplied to any of these is a list, the return value is a corresponding list. Otherwise, a single string is returned. getEnv, setEnv, delEnv \u00b6 getEnv ( varName , default = None ) setEnv ( varName , value ) delEnv ( varName ) Use these functions to retrieve or manipulate environmental variables. reserveTempFilePath \u00b6 reserveTempFilePath( suffix=\"\", isSplitRet=False ) This is light wrapper over the standard tempfile.mkstemp function, which returns a temp file path, but doesn\u2019t create it. Thus, with that standard function it is possible (in theory) for a second process to create a file at that path before such can be done by the first. This customization mitigates that possibility by creating a 0 byte file on the spot, which you may then overwrite. Returns : the file path, optionally split into (dirPath, fileName) suffix : If specified, the file name will end with that suffix, otherwise there will be no suffix. Note, if the intended suffix is a file extension, you must include the \u201c.\u201d explicitly. isSplitRet : Dictate the optional return value type / format. versionTuple, versionStr \u00b6 versionTuple( ver, parts=4 ) versionStr( ver, parts=4 ) These functions return \u201cversion representations\u201d as either tuples of integers, or as strings delimited by periods respectively (e.g. \u201c1.0.0.0\u201d). Based upon context, either format is commonly used by this library, and elsewhere. The ver argument may take many forms: a string (Unicode or bytes), an integer, a float, a tuple, a list\u2026 It must simply use digits for each \u201cpart\u201d of the version. Alpha characters are not permitted. The optional parts argument will truncate or pad the return value, so it has that many elements present in the representation. 4 \u201cparts\u201d is the standard, i.e. \u201cMajor.Minor.Micro.Build\u201d. versionNo, assertMinVer, assertBuilderVer \u00b6 versionNo( ver, parts=4, partLen=3 ) assertMinVer( ver, minVer, parts=4, partLen=3, descr=None ) assertBuilderVer( ver ) Like versionTuple and versionStr , versionNo takes \u201cany\u201d representation of a version on under the sun and returns an integer. In addition to specifying the number of parts in the version, it will be very important to use a valid and persistent partLen spec. That is the maximum number of digits to allow for use in each part. This factor exponentially changes the numeric result from this function. The function assertMinVer is provided to raise an exception in the event of a version (of whatever form and context), not meeting the requirements for the build process to continue. For convenience, assertBuilderVer is provided to confirm the minimum version of this library . It may be useful to start some build scripts in a manner resembling the following: from distbuilder assertBuilderVer assertBuilderVer( \"0.7.8.0\" ) embedExeVerInfo \u00b6 WINDOWS ONLY embedExeVerInfo( exePath, exeVerInfo ) Set the branding information (e.g. version, copyright, etc.) on an executable. These details can be seen when inspecting the properties of the file. This meta info may also be used by other mechanisms in the OS. Returns : None (Raising exception on failure) exePath : Absolute or relative path to the executable file. exeVerInfo : A WindowsExeVersionInfo object. embedExeIcon \u00b6 WINDOWS ONLY embedExeIcon( exePath, iconPath ) Returns : None (Raising exception on failure) exePath : Absolute or relative path to the executable file. iconPath : Absolute or relative path to the .ico file. extractExeIcons \u00b6 WINDOWS ONLY extractExeIcons( exePath, targetDirPath ) Extract all the icons contained within an executable. Returns : None (Raising exception on failure) srcExePath : Absolute or relative path to the executable file. destDirPath : Absolute or relative directory path where the icons will be copied. copyExeVerInfo \u00b6 WINDOWS ONLY copyExeVerInfo( srcExePath, destExePath ) Copy the version / branding information from one exe to another. Returns : None (Raising exception on failure) srcExePath : Absolute or relative path to the executable file which contains the information to be copied. destExePath : Absolute or relative path to the executable file where the information is to be transferred. Note, this file must already exist, to receive the branding info, i.e. this function doesn\u2019t create a new exe. copyExeIcon \u00b6 WINDOWS ONLY copyExeIcon( srcExePath, destExePath, iconName=None ) Copy an embedded icon from one exe to another. Returns : None (Raising exception on failure) srcExePath : Absolute or relative path to the executable file which contains the icon to be copied. destExePath : Absolute or relative path to the executable file where the icon is to be transferred. Note, this file must already exist, to receive the icon, i.e. this function doesn\u2019t create a new exe. iconName : If the source exe contains multiple icons, this argument allows the specification of which one of those is to be copied. This maybe figure out manually by first exacting the icons. If none is specified, the \u201cfirst\u201d icon in an directory listing will be automatically selected. embedManifest \u00b6 WINDOWS ONLY embedManifest( exePath, manifestPath ) Returns : None (Raising exception on failure) exePath : Absolute or relative path to the executable file. manifestPath : Absolute or relative path to a manifest file. embedAutoElevation \u00b6 WINDOWS ONLY embedAutoElevation( exePath ) Cause an executable to auto elevate (i.e. request admin priviledges) every time it is run, by embedding this requirement for the OS to enforce via a manifest. Returns : None (Raising exception on failure) exePath : Absolute or relative path to the executable file. halt \u00b6 halt() Immediately stops execution of the script. This can be useful for debugging, since it is typical to the use library for auto generating and purging files which you might want to inspect along the way. printErr, printExc \u00b6 printErr( msg, isFatal=False ) Roughly emulates the print command, but writes to stderr. Optionally, exits the script with a return code of 1 (i.e. general error). printExc( e, isDetailed=False, isFatal=False ) Analogous to printErr, but prints an exception\u2019s more detailed repr() information. Optionally, prints a stack trace as well when isDetailed=True. Note: use printErr( e ) to print just an exception \u201cmessage\u201d. download \u00b6 download ( url , saveToPath = None , preserveName = True ) Returns : the local path to the completed download. url : The url to the file that is to be downloaded. saveToPath : (Optional) The full local path where the file should be downloaded to. If omitted (or set to None ), this path will be automatically assigned to one within a temp directory. preserveName : (Optional) If saveToPath is None , this boolean dictates whether the original name of the file should be used when saving the file locally. If set to False , the name will be auto assigned to one which does not conflict with any that already exist. If set to True , and the path already exists, the new download will overwrite the prior file. getPassword \u00b6 getPassword ( isGuiPrompt = True ) Returns : the password input by the user isGuiPrompt : If enabled, uses the Tk library to drive a gui prompt. (Such requires a gui operating system / distro, of course.) If not enabled, the password input prompt will work via a terminal interface. Aliased standard python functions \u00b6 exists os . path . exists isFile os . path . isfile or os . path . islink isDir exists AND not isFile copyFile shutil . copyFile removeFile os . remove makeDir os . makedirs copyDir shutil . copytree removeDir shutil . rmtree move shutil . move rename os . rename tempDirPath tempfile . gettempdir () rootFileName < custom > head of os . path . splitext of os . path . basename baseFileName os . path . basename dirPath os . path . dirname joinPath os . path . join splitPath os . path . split splitExt os . path . splitext joinExt < custom > inverse of splitExt fileExt < note returns None , rather than \"\" , when there is no extension > General Purpose Constants \u00b6 IS_WINDOWS IS_LINUX IS_MACOS PY2 PY3 BIT_CONTEXT IS_32_BIT_CONTEXT IS_64_BIT_CONTEXT IS_ARM_CPU IS_INTEL_CPU THIS_DIR ALL <* wild card> CURRENT_USER ALL_USERS DEBUG_ENV_VAR_NAME DEBUG_ENV_VAR_VALUE","title":"Low Level Functions"},{"location":"LowLevel.html#low-level-classes-and-functions","text":"","title":"Low Level Classes And Functions"},{"location":"LowLevel.html#stand-alone-executables","text":"","title":"Stand Alone Executables"},{"location":"LowLevel.html#installers","text":"Upon creating a distribution (especially a stand-alone executable), the next logical progression is to bundle that into a full-scale installer. This library is designed to employ the open source, cross platform utility: Qt IFW (i.e. \u201cQt Installer Framework\u201d) for such purposes. While the prototypical implementation of that tool is with a Qt C++ program, it is equally usable for a Python program (especially if using \u201cQt for Python\u201d, and a QML driven interface\u2026).","title":"Installers"},{"location":"LowLevel.html#code-obfuscation","text":"Code obfuscation is the process of rewriting normal, human readable code, into a form which is very difficult (well, ideally impossible) to read, yet still executes in exactly the same manner when run through the target translator (or compiler). The reason one would want to do this to is to protect proprietary work and/or to eliminate security holes (based upon context) while sharing source code. Opy for Distribution Builder is an obfuscation library for Python. It can be used for protecting source that will be shared directly, or as an additional layer of protection behind binaries built with PyInstaller. While Opy does not protect your code as well as real compilation does, it\u2019s far better than nothing! The obfuscation process is \u201clossy\u201d, so while the end result still functions as desired, Opy inherently destroys the clear text original names for functions, classes, objects, etc. A hacker might still figure out some \u201csecret\u201d after putting in a good deal of effort, but no one can\u2019t just walk away with your body of the work on the whole, or instantly spot your security secrets.","title":"Code Obfuscation"},{"location":"LowLevel.html#library-installation","text":"","title":"Library Installation"},{"location":"LowLevel.html#testing","text":"","title":"Testing"},{"location":"LowLevel.html#archives-and-distribution","text":"Once you have a fully built distribution package, the following functions provide an easy means for further preparing the program for distribution:","title":"Archives and Distribution"},{"location":"LowLevel.html#executablescript","text":"Executable scripts have wide ranging potential for use with this library. They may be employed as part of the build process, deployed with a distribution, or run in an embedded process of some form. The ExecutableScript class is used to generate / bundle scripts. By default, the script is a batch file on Windows, or a shell script on Linux or Mac. The class QtIfwExternalOp ) optionally employs this class to embedded custom installer scripts into it\u2019s processes. The class QtIfwExeWrapper ) often contains a class of his type, used as a \u201cwrapper\u201d over a deployed executable. In some contexts, that wrapper mechanism is implicitly employed by deployment preparing tools the library leans on, and/or is added directly by distbuilder. Class PyInstHook ) is a derived class from ExecutableScript. Note that it is a Python script rather than the default type for a given platform. Constructor: ExecutableScript( rootName, extension=True, shebang=True, script=None, scriptPath=None, scriptDirPath=None, replacements={}, isDebug=True ) Attributes & default values: rootName <required> extension=True # i.e. True==automatic shebang=True # i.e. True==automatic script=None scriptDirPath=None replacements={} isIfwVarEscapeBackslash=False isDebug=True Functions: fileName() filePath() exists( scriptDirPath=None ) read( scriptDirPath=None ) write( scriptDirPath=None ) remove( scriptDirPath=None ) __str__ <i.e. built-in to string supported> asSnippet() toLines() fromLines( lines ) injectLine( injection, lineNo ) toBase64( toString=False ) fromBase64( data ) debug() Static Functions: typeOf( path ) strToLines( s ) linesToStr( lines ) Static Constants: SHELL_EXT BATCH_EXT VBSCRIPT_EXT JSCRIPT_EXT POWERSHELL_EXT APPLESCRIPT_EXT SUPPORTED_EXTS <list> Details: rootName : The name of script without the extension. If this is used as an \u201cexe/binary wrapper\u201d, this name should normally align with the root of that binary\u2019s name, which may be acquired with rootFileName( path ) . extension : The file extension used when creating the file. If True , the extension will be automatically assigned. This defaults to bat on Windows, sh on Mac and Linux. If set to None , there will be no extension on the file. A user supplied string will be applied if custom provided. shebang : A \u201cshebang\u201d injected into the top of the script automatically. On Windows, this attribute is not used. Else, if True , #!/bin/sh will be used. A user supplied string will be applied if custom provided. script : The content for the for script, provided as a string, or a list (representing lines). scriptPath : The content for the for script, provided to the constructor as a file path to source for where it is to be extracted. Use the filePath() function later if you need this apth again. scriptDirPath : Optional. During construction, this may be explicitly defined, or left as None to imply THIS_DIR . If a scriptPath is specified, a directory path extracted from that will be used. On subsequent calls to read( scriptDirPath ) , write( scriptDirPath ) , or remove( scriptDirPath ) , the scriptDirPath will be updated if supplied (i.e. not None ). replacements : A dictionary of \u201cplaceholder\u201d keys and \u201csubstitution\u201d values in the script. Place holders must defined in the script with the surrounding brackets, i.e in the form \u201c{placeholder}\u201d. The keys in replacements dictionary should not, however, include the brackets. This is similar to the built-in string format function, of course, but works better in scripts which use brackets for other purposes. asSnippet() : Use this function when \u201cpasting\u201d scripts together. isIfwVarEscapeBackslash : If employing this class within a QtIfwExternalOp , enabling this attribute with cause dynamically resolved installer driven paths to be injected into the script with backslashes doubled up, thereby escaping them in certain scripting languages / string literal contexts.","title":"ExecutableScript"},{"location":"LowLevel.html#code-signing","text":"\u201cCode signing\u201d an executable file is a means to provide proof that a program was produced by a party who can be identified and trusted to not install viruses or malware on to your PC. This mechanism may be thought of as a \u201cfirst line of defense\u201d for virus checkers and security tools. Explicitly installing a \u201cTrusted Software Publisher Certificate\u201d maybe necessary for the digital signature on a file to be validated, if the file was signed by an unknown \u201cCertification Authority\u201d. All major operating systems ship with a host of standard \u201cCA certs\u201d pre-installed, but will also allow the manual addition of such to supplement those included out-of-the-box.","title":"Code Signing"},{"location":"LowLevel.html#module-import-utilities","text":"","title":"Module import utilities"},{"location":"LowLevel.html#logging","text":"Distbuilder often produces extensive debugging output when running assorted processes. It may prove cumbersome, if not impossible, to read through such from a terminal, or from within an IDE. In which case, the built in logging mechanisms can be drawn upon to resolve this. The easiest way to log the output of distbuilder processes, is to simply call startLogging() at the top of your script. This will redirect all print statements, along with the stdout and stderr streams of sub processes, to a (default named) log file. When logging in the standard manner and an uncaught exception occurs, the stack trace for that will appear both in the log, and in the console where the script was launched. If desired, you may also explicitly create your own Logger objects and call their functions e.g. write( msg ) directly. This maybe useful if you wish to split logs across multiple files for different parts of a build process. Note that only the primary/singleton instance will have implicit stream redirections applied though. So, if there is no multi-threading / parallel processing dimension to your use case, you may alternatively wish use the pattern stopLogging \u2026 startLogging( \"MyAltLogName\" ) to achieve a \u201csplit log\u201d result.","title":"Logging"},{"location":"LowLevel.html#utility-functions","text":"The following low level \u201cutilities\u201d are also provided for convenience, as they maybe useful in defining the build parameters, further manipulating the package, or testing the results, etc.","title":"Utility Functions"},{"location":"LowLevel.html#general-purpose-constants","text":"IS_WINDOWS IS_LINUX IS_MACOS PY2 PY3 BIT_CONTEXT IS_32_BIT_CONTEXT IS_64_BIT_CONTEXT IS_ARM_CPU IS_INTEL_CPU THIS_DIR ALL <* wild card> CURRENT_USER ALL_USERS DEBUG_ENV_VAR_NAME DEBUG_ENV_VAR_VALUE","title":"General Purpose Constants"},{"location":"PyInstaller.html","text":"PyInstHook class \u00b6 Base Classes: ExecutableScript Magic Methods: __init__ Instance Methods: asSnippet debug exists fileName filePath fromBase64 fromLines injectLine read remove toBase64 toLines write Instance Attributes: isContribHook isRunTimeHook hooksDirPath Class/Static Methods: linesToStr strToLines typeOf Class/Static Attributes: APPLESCRIPT_EXT BATCH_EXT FILE_NAME_PREFIX JSCRIPT_EXT POWERSHELL_EXT SHELL_EXT SUPPORTED_EXTS VBSCRIPT_EXT PyInstHook ( name , script = None , isContribHook = True , isRunTimeHook = False ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . asSnippet ( self ) \u00b6 obj . debug ( self ) \u00b6 obj . exists ( self , scriptDirPath = None ) \u00b6 obj . fileName ( self ) \u00b6 obj . filePath ( self ) \u00b6 obj . fromBase64 ( self , data ) \u00b6 obj . fromLines ( self , lines ) \u00b6 obj . injectLine ( self , injection , lineNo ) \u00b6 obj . read ( self ) \u00b6 obj . remove ( self ) \u00b6 obj . toBase64 ( self , toString = False ) \u00b6 obj . toLines ( self ) \u00b6 obj . write ( self ) \u00b6 obj . isContribHook class \u2018NoneType\u2019 default: None \u00b6 obj . isRunTimeHook class \u2018NoneType\u2019 default: None \u00b6 obj . hooksDirPath class \u2018NoneType\u2019 default: None \u00b6 PyInstHook . linesToStr ( lines ) \u00b6 PyInstHook . strToLines ( s ) \u00b6 PyInstHook . typeOf ( path ) \u00b6 PyInstHook . APPLESCRIPT_EXT class \u2018str\u2019 default: \u201cscpt\u201d \u00b6 PyInstHook . BATCH_EXT class \u2018str\u2019 default: \u201cbat\u201d \u00b6 PyInstHook . FILE_NAME_PREFIX class \u2018str\u2019 default: \u201chook-\u201c \u00b6 PyInstHook . JSCRIPT_EXT class \u2018str\u2019 default: \u201cjs\u201d \u00b6 PyInstHook . POWERSHELL_EXT class \u2018str\u2019 default: \u201cps1\u201d \u00b6 PyInstHook . SHELL_EXT class \u2018str\u2019 default: \u201csh\u201d \u00b6 PyInstHook . SUPPORTED_EXTS class \u2018list\u2019 default: [\u2018sh\u2019, \u2018bat\u2019, \u2018vbs\u2019, \u2018js\u2019, \u2018ps1\u2019, \u2018scpt\u2019] \u00b6 PyInstHook . VBSCRIPT_EXT class \u2018str\u2019 default: \u201cvbs\u201d \u00b6 PyInstSpec class \u00b6 Base Classes: PlasticFile Magic Methods: __init__ Instance Methods: debug fromLines injectDuplicateDataPatch injectInterpreterOptions injectLine path read remove toLines write Instance Attributes: filePath pyInstConfig warningBehavior isUnBufferedStdIo isModInitDebug Class/Static Methods: cfgToPath Class/Static Attributes: WARN_ERROR WARN_IGNORE WARN_ONCE PyInstSpec ( filePath = None , pyInstConfig = None , content = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . debug ( self ) \u00b6 obj . fromLines ( self , lines ) \u00b6 obj . injectDuplicateDataPatch ( self ) \u00b6 This patches a known bug in PyInstaller on Windows. PyInstaller analysis can build a set of data file names which contain \u201cduplicates\u201d due to the Windows file system case insensitivity. This patch eliminates such duplicates, thus preventing runtime errors in the binary produced. obj . injectInterpreterOptions ( self ) \u00b6 obj . injectLine ( self , injection , lineNo ) \u00b6 obj . path ( self ) \u00b6 obj . read ( self ) \u00b6 obj . remove ( self ) \u00b6 obj . toLines ( self ) \u00b6 obj . write ( self ) \u00b6 obj . filePath class \u2018NoneType\u2019 default: None \u00b6 obj . pyInstConfig class \u2018NoneType\u2019 default: None \u00b6 obj . warningBehavior class \u2018NoneType\u2019 default: None \u00b6 obj . isUnBufferedStdIo class \u2018bool\u2019 default: False \u00b6 obj . isModInitDebug class \u2018bool\u2019 default: False \u00b6 PyInstSpec . cfgToPath ( pyInstConfig ) \u00b6 PyInstSpec . WARN_ERROR class \u2018int\u2019 default: 2 \u00b6 PyInstSpec . WARN_IGNORE class \u2018int\u2019 default: 0 \u00b6 PyInstSpec . WARN_ONCE class \u2018int\u2019 default: 1 \u00b6 PyInstallerConfig class \u00b6 See PyInstaller docs for details on these settings. Magic Methods: __init__ Instance Methods: toArgs Instance Attributes: name sourceDir entryPointPy pyInstSpec isGui iconFilePath versionInfo versionFilePath isAutoElevated isOneFile importPaths hiddenImports dataFilePaths binaryFilePaths distResources distDirs codeSignConfig codeSignTargets distDirPath otherPyInstArgs isSpecFileRemoved PyInstallerConfig () \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . toArgs ( self , isMakeSpec = False ) \u00b6 obj . name class \u2018NoneType\u2019 default: None \u00b6 obj . sourceDir class \u2018NoneType\u2019 default: None \u00b6 obj . entryPointPy class \u2018NoneType\u2019 default: None \u00b6 obj . pyInstSpec class \u2018NoneType\u2019 default: None \u00b6 obj . isGui class \u2018bool\u2019 default: False \u00b6 obj . iconFilePath class \u2018NoneType\u2019 default: None \u00b6 obj . versionInfo class \u2018NoneType\u2019 default: None \u00b6 obj . versionFilePath class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoElevated class \u2018bool\u2019 default: False \u00b6 obj . isOneFile class \u2018bool\u2019 default: True \u00b6 obj . importPaths class \u2018list\u2019 default: [] \u00b6 obj . hiddenImports class \u2018list\u2019 default: [] \u00b6 obj . dataFilePaths class \u2018list\u2019 default: [] \u00b6 obj . binaryFilePaths class \u2018list\u2019 default: [] \u00b6 obj . distResources class \u2018list\u2019 default: [] \u00b6 obj . distDirs class \u2018list\u2019 default: [] \u00b6 obj . codeSignConfig class \u2018list\u2019 default: [] \u00b6 obj . codeSignTargets class \u2018list\u2019 default: [] \u00b6 obj . distDirPath class \u2018NoneType\u2019 default: None \u00b6 obj . otherPyInstArgs class \u2018str\u2019 default: \u201c<empty string>\u201c \u00b6 obj . isSpecFileRemoved class \u2018bool\u2019 default: False \u00b6 PyToBinInstallerProcess class \u00b6 Base Classes: _DistBuildProcessBase, _BuildInstallerProcess Magic Methods: __init__ Instance Methods: onFinalize onIExpressPackagesBuilt onInitialize onMakeSpec onOpyConfig onPackagesStaged onPyInstConfig onPyPackageProcess onPyPackagesBuilt onQtIfwConfig run Class/Static Attributes: DIVIDER PyToBinInstallerProcess ( configFactory , name = 'Python to Binary Installer Process' , isDesktopTarget = False , isHomeDirTarget = False ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . onFinalize ( self ) \u00b6 VIRTUAL obj . onIExpressPackagesBuilt ( self , pkgs ) \u00b6 VIRTUAL obj . onInitialize ( self ) \u00b6 VIRTUAL obj . onMakeSpec ( self , spec ) \u00b6 VIRTUAL obj . onOpyConfig ( self , cfg ) \u00b6 VIRTUAL obj . onPackagesStaged ( self , cfg , pkgs ) \u00b6 VIRTUAL obj . onPyInstConfig ( self , cfg ) \u00b6 VIRTUAL obj . onPyPackageProcess ( self , prc ) \u00b6 VIRTUAL obj . onPyPackagesBuilt ( self , pkgs ) \u00b6 VIRTUAL obj . onQtIfwConfig ( self , cfg ) \u00b6 VIRTUAL obj . run ( self ) \u00b6 PyToBinInstallerProcess . DIVIDER class \u2018str\u2019 default: \u201d------------------------------------\u201c \u00b6 PyToBinPackageProcess class \u00b6 Base Classes: _DistBuildProcessBase, _BuildPackageProcess Magic Methods: __init__ Instance Methods: onFinalize onInitialize onMakeSpec onOpyConfig onPyInstConfig run Instance Attributes: isObfuscationTest isWarningSuppression isUnBufferedStdIo isPyInstDupDataPatched Class/Static Attributes: DIVIDER PyToBinPackageProcess ( configFactory , name = 'Python to Binary Package Process' , isZipped = False , isDesktopTarget = False , isHomeDirTarget = False ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . onFinalize ( self ) \u00b6 VIRTUAL obj . onInitialize ( self ) \u00b6 VIRTUAL obj . onMakeSpec ( self , spec ) \u00b6 VIRTUAL obj . onOpyConfig ( self , cfg ) \u00b6 VIRTUAL obj . onPyInstConfig ( self , cfg ) \u00b6 VIRTUAL obj . run ( self ) \u00b6 obj . isObfuscationTest class \u2018bool\u2019 default: False \u00b6 obj . isWarningSuppression class \u2018bool\u2019 default: True \u00b6 obj . isUnBufferedStdIo class \u2018bool\u2019 default: False \u00b6 obj . isPyInstDupDataPatched class \u2018NoneType\u2019 default: None \u00b6 PyToBinPackageProcess . DIVIDER class \u2018str\u2019 default: \u201d------------------------------------\u201c \u00b6 Functions \u00b6 PyInstallerMajorMinorVer () \u00b6 PyInstallerMajorVer () \u00b6 PyInstallerVersion () \u00b6 installPyInstaller ( version = None ) \u00b6 makePyInstSpec ( pyInstConfig , opyConfig = None ) \u00b6 pyScriptToExe ( name = None , entryPointPy = None , pyInstConfig =< py_installer . PyInstallerConfig object at 0x0496A130 > , opyConfig = None , distResources = None , distDirs = None ) \u00b6 returns: (binDir, binPath) uninstallPyInstaller () \u00b6","title":"PyInstaller"},{"location":"PyInstaller.html#PyInstHook","text":"Base Classes: ExecutableScript Magic Methods: __init__ Instance Methods: asSnippet debug exists fileName filePath fromBase64 fromLines injectLine read remove toBase64 toLines write Instance Attributes: isContribHook isRunTimeHook hooksDirPath Class/Static Methods: linesToStr strToLines typeOf Class/Static Attributes: APPLESCRIPT_EXT BATCH_EXT FILE_NAME_PREFIX JSCRIPT_EXT POWERSHELL_EXT SHELL_EXT SUPPORTED_EXTS VBSCRIPT_EXT","title":"PyInstHook"},{"location":"PyInstaller.html#PyInstSpec","text":"Base Classes: PlasticFile Magic Methods: __init__ Instance Methods: debug fromLines injectDuplicateDataPatch injectInterpreterOptions injectLine path read remove toLines write Instance Attributes: filePath pyInstConfig warningBehavior isUnBufferedStdIo isModInitDebug Class/Static Methods: cfgToPath Class/Static Attributes: WARN_ERROR WARN_IGNORE WARN_ONCE","title":"PyInstSpec"},{"location":"PyInstaller.html#PyInstallerConfig","text":"See PyInstaller docs for details on these settings. Magic Methods: __init__ Instance Methods: toArgs Instance Attributes: name sourceDir entryPointPy pyInstSpec isGui iconFilePath versionInfo versionFilePath isAutoElevated isOneFile importPaths hiddenImports dataFilePaths binaryFilePaths distResources distDirs codeSignConfig codeSignTargets distDirPath otherPyInstArgs isSpecFileRemoved","title":"PyInstallerConfig"},{"location":"PyInstaller.html#PyToBinInstallerProcess","text":"Base Classes: _DistBuildProcessBase, _BuildInstallerProcess Magic Methods: __init__ Instance Methods: onFinalize onIExpressPackagesBuilt onInitialize onMakeSpec onOpyConfig onPackagesStaged onPyInstConfig onPyPackageProcess onPyPackagesBuilt onQtIfwConfig run Class/Static Attributes: DIVIDER","title":"PyToBinInstallerProcess"},{"location":"PyInstaller.html#PyToBinPackageProcess","text":"Base Classes: _DistBuildProcessBase, _BuildPackageProcess Magic Methods: __init__ Instance Methods: onFinalize onInitialize onMakeSpec onOpyConfig onPyInstConfig run Instance Attributes: isObfuscationTest isWarningSuppression isUnBufferedStdIo isPyInstDupDataPatched Class/Static Attributes: DIVIDER","title":"PyToBinPackageProcess"},{"location":"PyInstaller.html#Functions","text":"","title":"Functions"},{"location":"Python%20Obfuscation.html","text":"LibToBundle class \u00b6 Magic Methods: __init__ Instance Methods: Instance Attributes: name localDirPath pipConfig isObfuscated LibToBundle ( name , localDirPath = None , pipConfig = None , isObfuscated = False ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . name class \u2018NoneType\u2019 default: None \u00b6 obj . localDirPath class \u2018NoneType\u2019 default: None \u00b6 obj . pipConfig class \u2018NoneType\u2019 default: None \u00b6 obj . isObfuscated class \u2018NoneType\u2019 default: None \u00b6 OpyConfig class \u00b6 See opy_config.txt for details on these settings. Magic Methods: __init__ Instance Methods: toVirtualFile Instance Attributes: obfuscate_strings obfuscated_name_tail plain_marker pep8_comments source_extensions skip_extensions skip_path_fragments apply_standard_exclusions preserve_unresolved_imports error_on_unresolved_imports external_modules replacement_modules plain_files plain_names mask_external_modules skip_public subset_files dry_run prepped_only OpyConfig () \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . toVirtualFile ( self ) \u00b6 obj . obfuscate_strings class \u2018bool\u2019 default: True \u00b6 obj . obfuscated_name_tail class \u2018str\u2019 default: \u201c opy \u201c \u00b6 obj . plain_marker class \u2018str\u2019 default: \u201c opy \u201c \u00b6 obj . pep8_comments class \u2018bool\u2019 default: False \u00b6 obj . source_extensions class \u2018list\u2019 default: [\u2018py\u2019, \u2018pyx\u2019] \u00b6 obj . skip_extensions class \u2018list\u2019 default: [\u2018pyc\u2019, \u2018txt\u2019, \u2018project\u2019, \u2018pydevproject\u2019, \u2018settings\u2019] \u00b6 obj . skip_path_fragments class \u2018list\u2019 default: [\u2018opy_config.txt\u2019, \u2018opy_config.py\u2019, \u2018standard_exclusions.txt\u2019] \u00b6 obj . apply_standard_exclusions class \u2018bool\u2019 default: True \u00b6 obj . preserve_unresolved_imports class \u2018bool\u2019 default: True \u00b6 obj . error_on_unresolved_imports class \u2018bool\u2019 default: True \u00b6 obj . external_modules class \u2018list\u2019 default: [] \u00b6 obj . replacement_modules class \u2018dict\u2019 default: {} \u00b6 obj . plain_files class \u2018list\u2019 default: [] \u00b6 obj . plain_names class \u2018list\u2019 default: [] \u00b6 obj . mask_external_modules class \u2018bool\u2019 default: True \u00b6 obj . skip_public class \u2018bool\u2019 default: False \u00b6 obj . subset_files class \u2018list\u2019 default: [] \u00b6 obj . dry_run class \u2018bool\u2019 default: False \u00b6 obj . prepped_only class \u2018bool\u2019 default: False \u00b6 OpyPatch class \u00b6 Magic Methods: __init__ Instance Methods: apply obfuscatePath Instance Attributes: relPath path patches OpyPatch ( relPath , patches , parentDir = 'C: \\\\ Python37 \\\\ Scripts \\\\ obfuscated' ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . apply ( self , opyResults ) \u00b6 obj . obfuscatePath ( self , opyResults ) \u00b6 obj . relPath class \u2018NoneType\u2019 default: None \u00b6 obj . path class \u2018NoneType\u2019 default: None \u00b6 obj . patches class \u2018NoneType\u2019 default: None \u00b6 Functions \u00b6 createStageDir ( bundleLibs = None , sourceDir = 'C: \\\\ Python37 \\\\ Scripts' ) \u00b6 returns: stageDir obfuscatePy ( opyConfig ) \u00b6 opyAnalyze ( opyConfig , filesSubset = None ) \u00b6","title":"Python Obfuscation"},{"location":"Python%20Obfuscation.html#LibToBundle","text":"Magic Methods: __init__ Instance Methods: Instance Attributes: name localDirPath pipConfig isObfuscated","title":"LibToBundle"},{"location":"Python%20Obfuscation.html#OpyConfig","text":"See opy_config.txt for details on these settings. Magic Methods: __init__ Instance Methods: toVirtualFile Instance Attributes: obfuscate_strings obfuscated_name_tail plain_marker pep8_comments source_extensions skip_extensions skip_path_fragments apply_standard_exclusions preserve_unresolved_imports error_on_unresolved_imports external_modules replacement_modules plain_files plain_names mask_external_modules skip_public subset_files dry_run prepped_only","title":"OpyConfig"},{"location":"Python%20Obfuscation.html#OpyPatch","text":"Magic Methods: __init__ Instance Methods: apply obfuscatePath Instance Attributes: relPath path patches","title":"OpyPatch"},{"location":"Python%20Obfuscation.html#Functions","text":"","title":"Functions"},{"location":"Python%20pip.html","text":"PipConfig class \u00b6 See Pip docs for details on these settings. Important Note: source maybe a: package name, git repo url, or local path Magic Methods: __init__ Instance Methods: Instance Attributes: pipCmdBase source version verEquality destPath asSource incDependencies isForced isCacheUsed isUpgrade otherPipArgs PipConfig ( source = None , version = None , verEquality = '==' , destPath = None , asSource = False , incDependencies = True , isForced = False , isCacheUsed = True , isUpgrade = False , otherPipArgs = '' ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . pipCmdBase class \u2018str\u2019 default: \u201c\u201dc:\\python37\\python3.exe\u201d -m pip\u201d \u00b6 obj . source class \u2018NoneType\u2019 default: None \u00b6 obj . version class \u2018NoneType\u2019 default: None \u00b6 obj . verEquality class \u2018NoneType\u2019 default: None \u00b6 obj . destPath class \u2018NoneType\u2019 default: None \u00b6 obj . asSource class \u2018NoneType\u2019 default: None \u00b6 obj . incDependencies class \u2018NoneType\u2019 default: None \u00b6 obj . isForced class \u2018NoneType\u2019 default: None \u00b6 obj . isCacheUsed class \u2018NoneType\u2019 default: None \u00b6 obj . isUpgrade class \u2018NoneType\u2019 default: None \u00b6 obj . otherPipArgs class \u2018NoneType\u2019 default: None \u00b6 Functions \u00b6 installLibraries ( * libs ) \u00b6 installLibrary ( name , opyConfig = None , pipConfig = None ) \u00b6 uninstallLibrary ( name ) \u00b6 updatePip () \u00b6 vcsUrl ( name , baseUrl , vcs = 'git' , subDir = None ) \u00b6","title":"Python pip"},{"location":"Python%20pip.html#PipConfig","text":"See Pip docs for details on these settings. Important Note: source maybe a: package name, git repo url, or local path Magic Methods: __init__ Instance Methods: Instance Attributes: pipCmdBase source version verEquality destPath asSource incDependencies isForced isCacheUsed isUpgrade otherPipArgs","title":"PipConfig"},{"location":"Python%20pip.html#Functions","text":"","title":"Functions"},{"location":"Qt%20CPP.html","text":"QtCppConfig class \u00b6 Magic Methods: __init__ Instance Methods: addDependencies qtDirPath toQtPath validate Instance Attributes: qtBinDirPath binCompiler qmlScrDirPath cQtDeployerConfig libDirs plugins hiddenQml hiddenDependencies ignoreLibs ignoreEnv recurseDepth deploySystem deployLibc allQml strip translations otherArgs Class/Static Methods: exeWrapper srcCompilerOptions Class/Static Attributes: CQtDeployerConfig QtCppConfig ( qtBinDirPath , binCompiler , qmlScrDirPath = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . addDependencies ( self , package ) \u00b6 obj . qtDirPath ( self ) \u00b6 obj . toQtPath ( self , relativePath ) \u00b6 obj . validate ( self ) \u00b6 obj . qtBinDirPath class \u2018NoneType\u2019 default: None \u00b6 obj . binCompiler class \u2018NoneType\u2019 default: None \u00b6 obj . qmlScrDirPath class \u2018NoneType\u2019 default: None \u00b6 obj . cQtDeployerConfig class \u2018NoneType\u2019 default: None \u00b6 obj . libDirs class \u2018NoneType\u2019 default: None \u00b6 obj . plugins class \u2018NoneType\u2019 default: None \u00b6 obj . hiddenQml class \u2018NoneType\u2019 default: None \u00b6 obj . hiddenDependencies class \u2018NoneType\u2019 default: None \u00b6 obj . ignoreLibs class \u2018NoneType\u2019 default: None \u00b6 obj . ignoreEnv class \u2018NoneType\u2019 default: None \u00b6 obj . recurseDepth class \u2018NoneType\u2019 default: None \u00b6 obj . deploySystem class \u2018NoneType\u2019 default: None \u00b6 obj . deployLibc class \u2018NoneType\u2019 default: None \u00b6 obj . allQml class \u2018NoneType\u2019 default: None \u00b6 obj . strip class \u2018NoneType\u2019 default: None \u00b6 obj . translations class \u2018NoneType\u2019 default: None \u00b6 obj . otherArgs class \u2018NoneType\u2019 default: None \u00b6 QtCppConfig . exeWrapper ( exePath , isGui ) \u00b6 QtCppConfig . srcCompilerOptions () \u00b6 QtCppConfig . CQtDeployerConfig class \u2018type\u2019 default: class \u2018qt_cpp.QtCppConfig.CQtDeployerConfig\u2019 \u00b6 QtCppConfig.CQtDeployerConfig class \u00b6 Functions \u00b6 installDeployTools ( askPassPath = None ) \u00b6 qmakeArgParser () \u00b6 qmakeArgs () \u00b6 qmakeInit () \u00b6 qmakeMasterConfigFactory ( args = None ) \u00b6 qmakePackageConfigFactory ( args = None ) \u00b6 renameExe ( args = None ) \u00b6","title":"Qt CPP"},{"location":"Qt%20CPP.html#QtCppConfig","text":"Magic Methods: __init__ Instance Methods: addDependencies qtDirPath toQtPath validate Instance Attributes: qtBinDirPath binCompiler qmlScrDirPath cQtDeployerConfig libDirs plugins hiddenQml hiddenDependencies ignoreLibs ignoreEnv recurseDepth deploySystem deployLibc allQml strip translations otherArgs Class/Static Methods: exeWrapper srcCompilerOptions Class/Static Attributes: CQtDeployerConfig","title":"QtCppConfig"},{"location":"Qt%20CPP.html#QtCppConfig.CQtDeployerConfig","text":"","title":"QtCppConfig.CQtDeployerConfig"},{"location":"Qt%20CPP.html#Functions","text":"","title":"Functions"},{"location":"Qt%20Installer%20Framework.html","text":"QtIfwConfig class \u00b6 Magic Methods: __init__ Instance Methods: addLicense addUiElements Instance Attributes: installerDefDirPath packages configXml controlScript setupExeName qtIfwDirPath isDebugMode otherQtIfwArgs QtIfwConfig ( installerDefDirPath = None , packages = None , configXml = None , controlScript = None , setupExeName = 'setup.exe' ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . addLicense ( self , licensePath , name = 'End User License Agreement' ) \u00b6 obj . addUiElements ( self , uiElements , isOverWrite = True ) \u00b6 obj . installerDefDirPath class \u2018NoneType\u2019 default: None \u00b6 obj . packages class \u2018NoneType\u2019 default: None \u00b6 obj . configXml class \u2018NoneType\u2019 default: None \u00b6 obj . controlScript class \u2018NoneType\u2019 default: None \u00b6 obj . setupExeName class \u2018NoneType\u2019 default: None \u00b6 obj . qtIfwDirPath class \u2018NoneType\u2019 default: None \u00b6 obj . isDebugMode class \u2018bool\u2019 default: True \u00b6 obj . otherQtIfwArgs class \u2018str\u2019 default: \u201c<empty string>\u201c \u00b6 QtIfwConfigXml class \u00b6 Base Classes: _QtIfwXml Magic Methods: __init__ Instance Methods: addCustomTags debug dirPath exists path setDefaultPaths setDefaultTitle setDefaultVersion setPrimaryContentExe toPrettyXml write Instance Attributes: primaryContentExe primaryExeWrapper runProgramArgList companyTradeName iconFilePath logoFilePath bannerFilePath Name Version Publisher Title TitleColor ControlScript TargetDir StartMenuDir RunProgram RunProgramDescription WizardStyle WizardDefaultWidth WizardDefaultHeight Logo Banner ProductUrl Class/Static Attributes: DEFAULT_WIZARD_STYLE WizardStyle QtIfwConfigXml ( name , version , publisher , iconFilePath = None , controlScriptName = None , primaryContentExe = None , isPrimaryExeGui = True , primaryExeWrapper = None , companyTradeName = None , wizardStyle = None , logoFilePath = None , bannerFilePath = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . addCustomTags ( self , root ) \u00b6 VIRTUAL obj . debug ( self ) \u00b6 obj . dirPath ( self ) \u00b6 PURE VIRTUAL obj . exists ( self ) \u00b6 obj . path ( self ) \u00b6 PURE VIRTUAL obj . setDefaultPaths ( self ) \u00b6 obj . setDefaultTitle ( self ) \u00b6 obj . setDefaultVersion ( self ) \u00b6 obj . setPrimaryContentExe ( self , ifwPackage ) \u00b6 obj . toPrettyXml ( self ) \u00b6 obj . write ( self ) \u00b6 obj . primaryContentExe class \u2018NoneType\u2019 default: None \u00b6 obj . primaryExeWrapper class \u2018NoneType\u2019 default: None \u00b6 obj . runProgramArgList class \u2018NoneType\u2019 default: None \u00b6 obj . companyTradeName class \u2018NoneType\u2019 default: None \u00b6 obj . iconFilePath class \u2018NoneType\u2019 default: None \u00b6 obj . logoFilePath class \u2018NoneType\u2019 default: None \u00b6 obj . bannerFilePath class \u2018NoneType\u2019 default: None \u00b6 obj . Name class \u2018NoneType\u2019 default: None \u00b6 obj . Version class \u2018NoneType\u2019 default: None \u00b6 obj . Publisher class \u2018NoneType\u2019 default: None \u00b6 obj . Title class \u2018NoneType\u2019 default: None \u00b6 obj . TitleColor class \u2018NoneType\u2019 default: None \u00b6 obj . ControlScript class \u2018NoneType\u2019 default: None \u00b6 obj . TargetDir class \u2018NoneType\u2019 default: None \u00b6 obj . StartMenuDir class \u2018NoneType\u2019 default: None \u00b6 obj . RunProgram class \u2018NoneType\u2019 default: None \u00b6 obj . RunProgramDescription class \u2018NoneType\u2019 default: None \u00b6 obj . WizardStyle class \u2018NoneType\u2019 default: None \u00b6 obj . WizardDefaultWidth class \u2018NoneType\u2019 default: None \u00b6 obj . WizardDefaultHeight class \u2018NoneType\u2019 default: None \u00b6 obj . Logo class \u2018NoneType\u2019 default: None \u00b6 obj . Banner class \u2018NoneType\u2019 default: None \u00b6 obj . ProductUrl class \u2018NoneType\u2019 default: None \u00b6 QtIfwConfigXml . DEFAULT_WIZARD_STYLE class \u2018int\u2019 default: None \u00b6 QtIfwConfigXml . WizardStyle class \u2018type\u2019 default: None \u00b6 QtIfwConfigXml.WizardStyle class \u00b6 Class/Static Attributes: AERO CLASSIC MAC MODERN QtIfwConfigXml.WizardStyle . AERO class \u2018int\u2019 default: 0 \u00b6 QtIfwConfigXml.WizardStyle . CLASSIC class \u2018int\u2019 default: 3 \u00b6 QtIfwConfigXml.WizardStyle . MAC class \u2018int\u2019 default: 2 \u00b6 QtIfwConfigXml.WizardStyle . MODERN class \u2018int\u2019 default: 1 \u00b6 QtIfwControlScript class \u00b6 Base Classes: _QtIfwScript Magic Methods: __init__ Instance Methods: debug dirPath exists path registerAutoPilotEventHandler registerGuiEventHandler registerStandardEventHandler registerWidgetEventHandler write Instance Attributes: isLimitedMaintenance virtualArgs uiPages widgets controllerGlobals isAutoGlobals controllerConstructorBody controllerConstructorInjection isAutoControllerConstructor onValueChangeCallbackBody onValueChangeCallbackInjection isAutoValueChangeCallBack onPageChangeCallbackBody onPageChangeCallbackInjection isAutoPageChangeCallBack onPageInsertRequestCallbackBody isAutoPageInsertRequestCallBack onPageRemoveRequestCallbackBody isAutoPageRemoveRequestCallBack onPageVisibilityRequestCallbackBody isAutoPageVisibilityRequestCallBack onFinishedClickedCallbackBody onFinishedClickedCallbackInjection onFinishedDetachedExecutions isAutoFinishedClickedCallbackBody isIntroductionPageVisible introductionPageCallbackBody introductionPageOnInstall introductionPageOnMaintain isAutoIntroductionPageCallback isTargetDirectoryPageVisible targetDirectoryPageCallbackBody isAutoTargetDirectoryPageCallback isComponentSelectionPageVisible componentSelectionPageCallbackBody componentSelectionPageInjection isAutoComponentSelectionPageCallback isLicenseAgreementPageVisible licenseAgreementPageCallbackBody isAutoLicenseAgreementPageCallback isStartMenuDirectoryPageVisible startMenuDirectoryPageCallbackBody isAutoStartMenuDirectoryPageCallback isReadyForInstallationPageVisible readyForInstallationPageCallbackBody readyForInstallationPageOnInstall readyForInstallationPageOnMaintain isAutoReadyForInstallationPageCallback isPerformInstallationPageVisible performInstallationPageCallbackBody isAutoPerformInstallationPageCallback isFinishedPageVisible finishedPageCallbackBody finishedPageOnInstall finishedPageOnMaintain isAutoFinishedPageCallback isRunProgVisible isRunProgEnabled isRunProgChecked Class/Static Methods: andList assertInternetConnected assignCurrentPageWidgetVar assignCustomPageWidgetVar assignPageWidgetVar assignRegistryEntryVar boolToString clickButton cmdLineArg cmdLineListArg cmdLineSwitchArg connectButtonClickHandler connectWidgetEventHandler currentPageWidget customPageWidget debugPopup deleteDetachedOpDataFile deleteFile deleteOpDataFile disableQuit disableQuitPrompt dropElevation elevate embedResources enable enableComponent enableCustom enableNextButton errorPopup genResources getComponent getCustomText getEnv getPageOwner getText hideDefaultPage ifAutoPilot ifBoolValue ifChecked ifCmdLineArg ifCmdLineSwitch ifComponentEnabled ifComponentInstalled ifComponentSelected ifCondition ifCustomChecked ifCustomEnabled ifCustomVisible ifDryRun ifElevated ifEnabled ifInstalling ifInternetConnected ifMaintenanceTool ifPathExists ifPingable ifRegistryEntryExists ifRegistryEntryExistsLike ifRegistryKeyExists ifRegistryKeyExistsLike ifValueDefined ifVisible ifYesNoPopup insertCustomPage insertCustomWidget isAutoPilot isChecked isComponentEnabled isComponentInstalled isComponentSelected isCustomChecked isCustomEnabled isCustomVisible isDryRun isElevated isEnabled isInstalling isInternetConnected isMaintenanceTool isPingable isVisible killAll log logSwitch logValue lookupBoolValue lookupValue lookupValueList makeDir openViaOs orList pageWidget pathExists productName quit quote registryEntryExists registryEntryExistsLike registryEntryValue registryKeyExists registryKeyExistsLike removeCustomPage removeCustomWidget removeDir resolveDynamTxtVarsOperations resolveDynamicVars resolveScriptVars resolveScriptVarsOperations selectAllComponents selectComponent selectDefaultComponents setBoolValue setChecked setCustomCheckBox setCustomPageText setCustomPageTitle setCustomText setCustomVisible setText setValue setValueFromRegistryEntry setVisible startMenuDir stringToBool switchYesNoCancelPopup targetDir toBool toDefaultPageId toNull warningPopup writeDetachedOpDataFile writeFile writeOpDataFile yesNoCancelPopup yesNoPopup Class/Static Attributes: ABORT ACCEPT_EULA_CMD_ARG ACCEPT_EULA_RADIO_BUTTON AND ASSIGN AUTH_ERROR_MSGBOX_ID AUTO_PILOT_CMD_ARG BACK_BUTTON CANCEL CANCEL_BUTTON CATCH COMMIT_BUTTON CONCAT CUSTOM_BUTTON_1 CUSTOM_BUTTON_2 CUSTOM_BUTTON_3 DEFAULT_FINISHED_MESSAGE DEFAULT_TARGET_DIR_KEY DRYRUN_CMD_ARG ELSE END_BLOCK END_LINE EQUAL_TO ERR_LOG_DEFAULT_PATH ERR_LOG_PATH_CMD_ARG EXCLUDE_LIST_CMD_ARG EXIT_FUNCTION FALSE FINISHED_MESSAGE_LABEL FINISH_BUTTON HELP_BUTTON IF INCLUDE_LIST_CMD_ARG INSTALL_LIST_CMD_ARG INTERUPTED_KEY IS_NET_CONNECTED_KEY MAINTAIN_MODE_CMD_ARG MAINTAIN_MODE_OPT_ADD_REMOVE MAINTAIN_MODE_OPT_REMOVE_ALL MAINTAIN_MODE_OPT_UPDATE MAINTAIN_PASSTHRU_CMD_ARG MAINTENANCE_TOOL_NAME NEW_LINE NEXT_BUTTON NO NOT NOT_EQUAL_TO NULL OK OR OUT_LOG_DEFAULT_PATH OUT_LOG_PATH_CMD_ARG PATH_SEP PRODUCT_NAME_KEY QUIT_MSGBOX_ID REBOOT_CMD_ARG RESTORE_MSGBOX_DEFAULT RUN_PROGRAM_CHECKBOX RUN_PROGRAM_CMD_ARG STARTMENU_DIR_KEY START_BLOCK START_MENU_DIR_CMD_ARG START_MENU_DIR_EDITBOX TAB TARGET_DIR_CMD_ARG TARGET_DIR_EDITBOX TARGET_DIR_KEY TARGET_EXISTS_OPT_CMD_ARG TARGET_EXISTS_OPT_FAIL TARGET_EXISTS_OPT_PROMPT TARGET_EXISTS_OPT_REMOVE TRUE TRY USER_KEY VERBOSE_CMD_SWITCH_ARG YES QtIfwControlScript ( fileName = 'installscript.qs' , script = None , scriptPath = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . debug ( self ) \u00b6 obj . dirPath ( self ) \u00b6 PURE VIRTUAL obj . exists ( self ) \u00b6 obj . path ( self ) \u00b6 PURE VIRTUAL obj . registerAutoPilotEventHandler ( self , signalName , slotName , slotBody ) \u00b6 obj . registerGuiEventHandler ( self , signalName , slotName , slotBody ) \u00b6 obj . registerStandardEventHandler ( self , signalName , slotName , slotBody ) \u00b6 obj . registerWidgetEventHandler ( self , pageId , controlName , signalName , slotName , slotBody ) \u00b6 obj . write ( self ) \u00b6 obj . isLimitedMaintenance class \u2018bool\u2019 default: True \u00b6 obj . virtualArgs class \u2018NoneType\u2019 default: None \u00b6 obj . uiPages class \u2018list\u2019 default: [] \u00b6 obj . widgets class \u2018list\u2019 default: [] \u00b6 obj . controllerGlobals class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoGlobals class \u2018bool\u2019 default: True \u00b6 obj . controllerConstructorBody class \u2018NoneType\u2019 default: None \u00b6 obj . controllerConstructorInjection class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoControllerConstructor class \u2018bool\u2019 default: True \u00b6 obj . onValueChangeCallbackBody class \u2018NoneType\u2019 default: None \u00b6 obj . onValueChangeCallbackInjection class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoValueChangeCallBack class \u2018bool\u2019 default: True \u00b6 obj . onPageChangeCallbackBody class \u2018NoneType\u2019 default: None \u00b6 obj . onPageChangeCallbackInjection class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoPageChangeCallBack class \u2018bool\u2019 default: True \u00b6 obj . onPageInsertRequestCallbackBody class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoPageInsertRequestCallBack class \u2018bool\u2019 default: True \u00b6 obj . onPageRemoveRequestCallbackBody class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoPageRemoveRequestCallBack class \u2018bool\u2019 default: True \u00b6 obj . onPageVisibilityRequestCallbackBody class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoPageVisibilityRequestCallBack class \u2018bool\u2019 default: True \u00b6 obj . onFinishedClickedCallbackBody class \u2018NoneType\u2019 default: None \u00b6 obj . onFinishedClickedCallbackInjection class \u2018NoneType\u2019 default: None \u00b6 obj . onFinishedDetachedExecutions class \u2018list\u2019 default: [] \u00b6 obj . isAutoFinishedClickedCallbackBody class \u2018bool\u2019 default: True \u00b6 obj . isIntroductionPageVisible class \u2018bool\u2019 default: True \u00b6 obj . introductionPageCallbackBody class \u2018NoneType\u2019 default: None \u00b6 obj . introductionPageOnInstall class \u2018NoneType\u2019 default: None \u00b6 obj . introductionPageOnMaintain class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoIntroductionPageCallback class \u2018bool\u2019 default: True \u00b6 obj . isTargetDirectoryPageVisible class \u2018bool\u2019 default: True \u00b6 obj . targetDirectoryPageCallbackBody class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoTargetDirectoryPageCallback class \u2018bool\u2019 default: True \u00b6 obj . isComponentSelectionPageVisible class \u2018bool\u2019 default: True \u00b6 obj . componentSelectionPageCallbackBody class \u2018NoneType\u2019 default: None \u00b6 obj . componentSelectionPageInjection class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoComponentSelectionPageCallback class \u2018bool\u2019 default: True \u00b6 obj . isLicenseAgreementPageVisible class \u2018bool\u2019 default: True \u00b6 obj . licenseAgreementPageCallbackBody class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoLicenseAgreementPageCallback class \u2018bool\u2019 default: True \u00b6 obj . isStartMenuDirectoryPageVisible class \u2018bool\u2019 default: True \u00b6 obj . startMenuDirectoryPageCallbackBody class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoStartMenuDirectoryPageCallback class \u2018bool\u2019 default: True \u00b6 obj . isReadyForInstallationPageVisible class \u2018bool\u2019 default: True \u00b6 obj . readyForInstallationPageCallbackBody class \u2018NoneType\u2019 default: None \u00b6 obj . readyForInstallationPageOnInstall class \u2018NoneType\u2019 default: None \u00b6 obj . readyForInstallationPageOnMaintain class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoReadyForInstallationPageCallback class \u2018bool\u2019 default: True \u00b6 obj . isPerformInstallationPageVisible class \u2018bool\u2019 default: True \u00b6 obj . performInstallationPageCallbackBody class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoPerformInstallationPageCallback class \u2018bool\u2019 default: True \u00b6 obj . isFinishedPageVisible class \u2018bool\u2019 default: True \u00b6 obj . finishedPageCallbackBody class \u2018NoneType\u2019 default: None \u00b6 obj . finishedPageOnInstall class \u2018NoneType\u2019 default: None \u00b6 obj . finishedPageOnMaintain class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoFinishedPageCallback class \u2018bool\u2019 default: True \u00b6 obj . isRunProgVisible class \u2018bool\u2019 default: True \u00b6 obj . isRunProgEnabled class \u2018bool\u2019 default: True \u00b6 obj . isRunProgChecked class \u2018bool\u2019 default: True \u00b6 QtIfwControlScript . andList ( conditions ) \u00b6 QtIfwControlScript . assertInternetConnected ( isRefresh = False , errMsg = None , isAutoQuote = True ) \u00b6 QtIfwControlScript . assignCurrentPageWidgetVar ( varName = 'page' ) \u00b6 QtIfwControlScript . assignCustomPageWidgetVar ( pageName , varName = 'page' ) \u00b6 QtIfwControlScript . assignPageWidgetVar ( pageId , varName = 'page' ) \u00b6 QtIfwControlScript . assignRegistryEntryVar ( key , valueName , isAutoBitContext = True , varName = 'regValue' , isAutoQuote = True ) \u00b6 QtIfwControlScript . boolToString ( b ) \u00b6 QtIfwControlScript . clickButton ( buttonName , delayMillis = None ) \u00b6 QtIfwControlScript . cmdLineArg ( arg , default = '' ) \u00b6 QtIfwControlScript . cmdLineListArg ( arg , default = None ) \u00b6 QtIfwControlScript . cmdLineSwitchArg ( arg , isNegated = False , isHardFalse = False ) \u00b6 QtIfwControlScript . connectButtonClickHandler ( buttonName , slotName ) \u00b6 QtIfwControlScript . connectWidgetEventHandler ( controlName , eventName , slotName ) \u00b6 QtIfwControlScript . currentPageWidget () \u00b6 QtIfwControlScript . customPageWidget ( name ) \u00b6 QtIfwControlScript . debugPopup ( msg , isAutoQuote = True ) \u00b6 QtIfwControlScript . deleteDetachedOpDataFile ( fileName ) \u00b6 QtIfwControlScript . deleteFile ( path , isAutoQuote = True ) \u00b6 QtIfwControlScript . deleteOpDataFile ( fileName ) \u00b6 QtIfwControlScript . disableQuit () \u00b6 QtIfwControlScript . disableQuitPrompt () \u00b6 QtIfwControlScript . dropElevation () \u00b6 QtIfwControlScript . elevate () \u00b6 QtIfwControlScript . embedResources ( embeddedResources ) \u00b6 QtIfwControlScript . enable ( controlName , isEnable = True ) \u00b6 DOES NOT WORK FOR WIZARD BUTTONS!!! QtIfwControlScript . enableComponent ( package , enable = True , isAutoQuote = True ) \u00b6 QtIfwControlScript . enableCustom ( controlName , isEnable = True , pageVar = 'page' ) \u00b6 DOES NOT WORK FOR WIZARD BUTTONS!!! QtIfwControlScript . enableNextButton ( isEnable = True ) \u00b6 ONLY WORKS ON DYNAMIC / CUSTOM PAGES! QtIfwControlScript . errorPopup ( msg , isAutoQuote = True ) \u00b6 QtIfwControlScript . genResources ( embeddedResources , isTempRootTarget = False ) \u00b6 QtIfwControlScript . getComponent ( name , isAutoQuote = True ) \u00b6 QtIfwControlScript . getCustomText ( controlName , pageVar = 'page' ) \u00b6 QtIfwControlScript . getEnv ( varName , isAutoQuote = True ) \u00b6 QtIfwControlScript . getPageOwner ( pageName , isAutoQuote = True ) \u00b6 QtIfwControlScript . getText ( controlName ) \u00b6 QtIfwControlScript . hideDefaultPage ( pageName ) \u00b6 QtIfwControlScript . ifAutoPilot ( isNegated = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifBoolValue ( key , isNegated = False , isHardFalse = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifChecked ( checkboxName , isNegated = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifCmdLineArg ( arg , isNegated = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifCmdLineSwitch ( arg , isNegated = False , isHardFalse = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifComponentEnabled ( package , isNegated = False , isAutoQuote = True , isMultiLine = False ) \u00b6 QtIfwControlScript . ifComponentInstalled ( package , isNegated = False , isAutoQuote = True , isMultiLine = False ) \u00b6 QtIfwControlScript . ifComponentSelected ( package , isNegated = False , isAutoQuote = True , isMultiLine = False ) \u00b6 QtIfwControlScript . ifCondition ( condition , isNegated = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifCustomChecked ( checkboxName , pageVar = 'page' , isNegated = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifCustomEnabled ( controlName , pageVar = 'page' , isNegated = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifCustomVisible ( controlName , pageVar = 'page' , isNegated = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifDryRun ( isNegated = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifElevated ( isNegated = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifEnabled ( controlName , isNegated = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifInstalling ( isNegated = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifInternetConnected ( isRefresh = False , isNegated = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifMaintenanceTool ( isNegated = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifPathExists ( path , isNegated = False , isAutoQuote = True , isMultiLine = False ) \u00b6 QtIfwControlScript . ifPingable ( uri , pings = 3 , totalMaxSecs = 12 , isAutoQuote = True , isNegated = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifRegistryEntryExists ( key , valueName , isAutoBitContext = True , isNegated = False , isAutoQuote = True , isMultiLine = False ) \u00b6 QtIfwControlScript . ifRegistryEntryExistsLike ( key , valueNameContains , isAutoBitContext = True , isCaseSensitive = False , isRecursive = False , isNegated = False , isAutoQuote = True , isMultiLine = False ) \u00b6 QtIfwControlScript . ifRegistryKeyExists ( key , isAutoBitContext = True , isNegated = False , isAutoQuote = True , isMultiLine = False ) \u00b6 QtIfwControlScript . ifRegistryKeyExistsLike ( parentKey , childKeyNameContains , isAutoBitContext = True , isCaseSensitive = False , isRecursive = False , isNegated = False , isAutoQuote = True , isMultiLine = False ) \u00b6 QtIfwControlScript . ifValueDefined ( key , isNegated = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifVisible ( controlName , isNegated = False , isMultiLine = False ) \u00b6 QtIfwControlScript . ifYesNoPopup ( msg , title = 'Question' , resultVar = 'result' , isMultiLine = False ) \u00b6 QtIfwControlScript . insertCustomPage ( pageName , position ) \u00b6 QtIfwControlScript . insertCustomWidget ( widgetName , pageName , position = None ) \u00b6 QtIfwControlScript . isAutoPilot ( isNegated = False ) \u00b6 QtIfwControlScript . isChecked ( checkboxName ) \u00b6 QtIfwControlScript . isComponentEnabled ( package , isAutoQuote = True ) \u00b6 QtIfwControlScript . isComponentInstalled ( package , isAutoQuote = True ) \u00b6 QtIfwControlScript . isComponentSelected ( package , isAutoQuote = True ) \u00b6 QtIfwControlScript . isCustomChecked ( checkboxName , pageVar = 'page' ) \u00b6 QtIfwControlScript . isCustomEnabled ( controlName , pageVar = 'page' ) \u00b6 QtIfwControlScript . isCustomVisible ( controlName , pageVar = 'page' ) \u00b6 QtIfwControlScript . isDryRun ( isNegated = False ) \u00b6 QtIfwControlScript . isElevated () \u00b6 QtIfwControlScript . isEnabled ( controlName ) \u00b6 QtIfwControlScript . isInstalling ( isNegated = False ) \u00b6 QtIfwControlScript . isInternetConnected ( isRefresh = False ) \u00b6 QtIfwControlScript . isMaintenanceTool ( isNegated = False ) \u00b6 QtIfwControlScript . isPingable ( uri , pings = 3 , totalMaxSecs = 12 , isAutoQuote = True ) \u00b6 QtIfwControlScript . isVisible ( controlName ) \u00b6 QtIfwControlScript . killAll ( exeName , isAutoQuote = True ) \u00b6 QtIfwControlScript . log ( msg , isAutoQuote = True ) \u00b6 QtIfwControlScript . logSwitch ( key ) \u00b6 QtIfwControlScript . logValue ( key , defaultVal = '' ) \u00b6 QtIfwControlScript . lookupBoolValue ( key , isNegated = False , isHardFalse = False , isAutoQuote = True ) \u00b6 QtIfwControlScript . lookupValue ( key , default = '' , isAutoQuote = True ) \u00b6 QtIfwControlScript . lookupValueList ( key , defaultList = None , isAutoQuote = True , delimiter = None ) \u00b6 QtIfwControlScript . makeDir ( path , isAutoQuote = True ) \u00b6 QtIfwControlScript . openViaOs ( path , isAutoQuote = True ) \u00b6 QtIfwControlScript . orList ( conditions ) \u00b6 QtIfwControlScript . pageWidget ( pageId ) \u00b6 QtIfwControlScript . pathExists ( path , isNegated = False , isAutoQuote = True ) \u00b6 QtIfwControlScript . productName () \u00b6 QtIfwControlScript . quit ( msg , isError = True , isSilent = False , isAutoQuote = True ) \u00b6 QtIfwControlScript . quote ( value ) \u00b6 QtIfwControlScript . registryEntryExists ( key , valueName , isAutoBitContext = True , isAutoQuote = True ) \u00b6 QtIfwControlScript . registryEntryExistsLike ( key , valueNameContains , isAutoBitContext = True , isCaseSensitive = False , isRecursive = False , isAutoQuote = True ) \u00b6 QtIfwControlScript . registryEntryValue ( key , valueName , isAutoBitContext = True , isAutoQuote = True ) \u00b6 QtIfwControlScript . registryKeyExists ( key , isAutoBitContext = True , isAutoQuote = True ) \u00b6 QtIfwControlScript . registryKeyExistsLike ( parentKey , childKeyNameContains , isAutoBitContext = True , isCaseSensitive = False , isRecursive = False , isAutoQuote = True ) \u00b6 QtIfwControlScript . removeCustomPage ( pageName ) \u00b6 QtIfwControlScript . removeCustomWidget ( widgetName ) \u00b6 QtIfwControlScript . removeDir ( path , isAutoQuote = True ) \u00b6 QtIfwControlScript . resolveDynamTxtVarsOperations ( plasticFile , destPath ) \u00b6 QtIfwControlScript . resolveDynamicVars ( s , varNames = None , isAutoQuote = True ) \u00b6 QtIfwControlScript . resolveScriptVars ( scripts , subDir ) \u00b6 QtIfwControlScript . resolveScriptVarsOperations ( scripts , subDir ) \u00b6 QtIfwControlScript . selectAllComponents ( isSelect = True ) \u00b6 QtIfwControlScript . selectComponent ( package , isSelect = True , isAutoQuote = True ) \u00b6 QtIfwControlScript . selectDefaultComponents () \u00b6 QtIfwControlScript . setBoolValue ( key , b , isAutoQuote = True ) \u00b6 QtIfwControlScript . setChecked ( checkboxName , isCheck = True ) \u00b6 QtIfwControlScript . setCustomCheckBox ( checkboxName , isCheck = True , pageVar = 'page' ) \u00b6 QtIfwControlScript . setCustomPageText ( title , description , isAutoQuote = True , pageVar = 'page' ) \u00b6 QtIfwControlScript . setCustomPageTitle ( title , isAutoQuote = True , pageVar = 'page' ) \u00b6 QtIfwControlScript . setCustomText ( controlName , text , isAutoQuote = True , pageVar = 'page' ) \u00b6 QtIfwControlScript . setCustomVisible ( controlName , isVisible = True , pageVar = 'page' ) \u00b6 DOES NOT WORK FOR WIZARD BUTTONS!!! QtIfwControlScript . setText ( controlName , text , varNames = None , isAutoQuote = True ) \u00b6 QtIfwControlScript . setValue ( key , value , isAutoQuote = True ) \u00b6 QtIfwControlScript . setValueFromRegistryEntry ( key , regKey , valueName , isAutoBitContext = True , isAutoQuote = True ) \u00b6 QtIfwControlScript . setVisible ( controlName , isVisible = True ) \u00b6 DOES NOT WORK FOR WIZARD BUTTONS!!! QtIfwControlScript . startMenuDir () \u00b6 QtIfwControlScript . stringToBool ( value , isAutoQuote = True ) \u00b6 QtIfwControlScript . switchYesNoCancelPopup ( msg , title = 'Question' , resultVar = 'result' , onYes = '' , onNo = '' , onCancel = '' ) \u00b6 QtIfwControlScript . targetDir () \u00b6 QtIfwControlScript . toBool ( b ) \u00b6 QtIfwControlScript . toDefaultPageId ( pageName ) \u00b6 QtIfwControlScript . toNull ( v ) \u00b6 QtIfwControlScript . warningPopup ( msg , isAutoQuote = True ) \u00b6 QtIfwControlScript . writeDetachedOpDataFile ( fileName , content = '' , isAutoQuote = True ) \u00b6 QtIfwControlScript . writeFile ( path , content , isAutoQuote = True ) \u00b6 QtIfwControlScript . writeOpDataFile ( fileName , content = '' , isAutoQuote = True ) \u00b6 QtIfwControlScript . yesNoCancelPopup ( msg , title = 'Question' , resultVar = 'result' ) \u00b6 QtIfwControlScript . yesNoPopup ( msg , title = 'Question' , resultVar = 'result' ) \u00b6 QtIfwControlScript . ABORT class \u2018str\u2019 default: \u201cQMessageBox.Abort\u201d \u00b6 QtIfwControlScript . ACCEPT_EULA_CMD_ARG class \u2018str\u2019 default: \u201caccept\u201d \u00b6 QtIfwControlScript . ACCEPT_EULA_RADIO_BUTTON class \u2018str\u2019 default: \u201cAcceptLicenseRadioButton\u201d \u00b6 QtIfwControlScript . AND class \u2018str\u2019 default: \u201d && \u201c \u00b6 QtIfwControlScript . ASSIGN class \u2018str\u2019 default: \u201d=\u201d \u00b6 QtIfwControlScript . AUTH_ERROR_MSGBOX_ID class \u2018str\u2019 default: \u201cAuthorizationError\u201d \u00b6 QtIfwControlScript . AUTO_PILOT_CMD_ARG class \u2018str\u2019 default: \u201cauto\u201d \u00b6 QtIfwControlScript . BACK_BUTTON class \u2018str\u2019 default: \u201cbuttons.BackButton\u201d \u00b6 QtIfwControlScript . CANCEL class \u2018str\u2019 default: \u201cQMessageBox.Cancel\u201d \u00b6 QtIfwControlScript . CANCEL_BUTTON class \u2018str\u2019 default: \u201cbuttons.CancelButton\u201d \u00b6 QtIfwControlScript . CATCH class \u2018str\u2019 default: \u201ccatch(e) { \u201c \u00b6 QtIfwControlScript . COMMIT_BUTTON class \u2018str\u2019 default: \u201cbuttons.CommitButton\u201d \u00b6 QtIfwControlScript . CONCAT class \u2018str\u2019 default: \u201d + \u201c \u00b6 QtIfwControlScript . CUSTOM_BUTTON_1 class \u2018str\u2019 default: \u201cbuttons.CustomButton1\u201d \u00b6 QtIfwControlScript . CUSTOM_BUTTON_2 class \u2018str\u2019 default: \u201cbuttons.CustomButton2\u201d \u00b6 QtIfwControlScript . CUSTOM_BUTTON_3 class \u2018str\u2019 default: \u201cbuttons.CustomButton3\u201d \u00b6 QtIfwControlScript . DEFAULT_FINISHED_MESSAGE class \u2018str\u2019 default: \u201cClick finish to exit the @ProductName@ Wizard.\u201d \u00b6 QtIfwControlScript . DEFAULT_TARGET_DIR_KEY class \u2018str\u2019 default: \u201cDefaultTargetDir\u201d \u00b6 QtIfwControlScript . DRYRUN_CMD_ARG class \u2018str\u2019 default: \u201cdryrun\u201d \u00b6 QtIfwControlScript . ELSE class \u2018str\u2019 default: \u201celse \u201c \u00b6 QtIfwControlScript . END_BLOCK class \u2018str\u2019 default: *\u201d} \u00b6 \u201d* { #END_BLOCK data-toc-label=END_BLOCK } QtIfwControlScript . END_LINE class \u2018str\u2019 default: *\u201d; \u00b6 \u201d* { #END_LINE data-toc-label=END_LINE } QtIfwControlScript . EQUAL_TO class \u2018str\u2019 default: \u201d == \u201c \u00b6 QtIfwControlScript . ERR_LOG_DEFAULT_PATH class \u2018str\u2019 default: \u201c%temp%\\installer.err\u201d \u00b6 QtIfwControlScript . ERR_LOG_PATH_CMD_ARG class \u2018str\u2019 default: \u201cerrlog\u201d \u00b6 QtIfwControlScript . EXCLUDE_LIST_CMD_ARG class \u2018str\u2019 default: \u201cexclude\u201d \u00b6 QtIfwControlScript . EXIT_FUNCTION class \u2018str\u2019 default: *\u201d \u00b6 return; \u201c* { #EXIT_FUNCTION data-toc-label=EXIT_FUNCTION } QtIfwControlScript . FALSE class \u2018str\u2019 default: \u201cfalse\u201d \u00b6 QtIfwControlScript . FINISHED_MESSAGE_LABEL class \u2018str\u2019 default: \u201cMessageLabel\u201d \u00b6 QtIfwControlScript . FINISH_BUTTON class \u2018str\u2019 default: \u201cbuttons.FinishButton\u201d \u00b6 QtIfwControlScript . HELP_BUTTON class \u2018str\u2019 default: \u201cbuttons.HelpButton\u201d \u00b6 QtIfwControlScript . IF class \u2018str\u2019 default: \u201cif \u201c \u00b6 QtIfwControlScript . INCLUDE_LIST_CMD_ARG class \u2018str\u2019 default: \u201cinclude\u201d \u00b6 QtIfwControlScript . INSTALL_LIST_CMD_ARG class \u2018str\u2019 default: \u201cinstall\u201d \u00b6 QtIfwControlScript . INTERUPTED_KEY class \u2018str\u2019 default: \u201cisInterupted\u201d \u00b6 QtIfwControlScript . IS_NET_CONNECTED_KEY class \u2018str\u2019 default: \u201cisNetConnected\u201d \u00b6 QtIfwControlScript . MAINTAIN_MODE_CMD_ARG class \u2018str\u2019 default: \u201cmode\u201d \u00b6 QtIfwControlScript . MAINTAIN_MODE_OPT_ADD_REMOVE class \u2018str\u2019 default: \u201caddremove\u201d \u00b6 QtIfwControlScript . MAINTAIN_MODE_OPT_REMOVE_ALL class \u2018str\u2019 default: \u201cremoveall\u201d \u00b6 QtIfwControlScript . MAINTAIN_MODE_OPT_UPDATE class \u2018str\u2019 default: \u201cupdate\u201d \u00b6 QtIfwControlScript . MAINTAIN_PASSTHRU_CMD_ARG class \u2018str\u2019 default: \u201cmaintpassthru\u201d \u00b6 QtIfwControlScript . MAINTENANCE_TOOL_NAME class \u2018str\u2019 default: \u201cmaintenancetool.exe\u201d \u00b6 QtIfwControlScript . NEW_LINE class \u2018str\u2019 default: *\u201d \u00b6 \u201d* { #NEW_LINE data-toc-label=NEW_LINE } QtIfwControlScript . NEXT_BUTTON class \u2018str\u2019 default: \u201cbuttons.NextButton\u201d \u00b6 QtIfwControlScript . NO class \u2018str\u2019 default: \u201cQMessageBox.No\u201d \u00b6 QtIfwControlScript . NOT class \u2018str\u2019 default: \u201d! \u201c \u00b6 QtIfwControlScript . NOT_EQUAL_TO class \u2018str\u2019 default: \u201d != \u201c \u00b6 QtIfwControlScript . NULL class \u2018str\u2019 default: \u201cnull\u201d \u00b6 QtIfwControlScript . OK class \u2018str\u2019 default: \u201cQMessageBox.Yes\u201d \u00b6 QtIfwControlScript . OR class \u2018str\u2019 default: \u201d || \u201c \u00b6 QtIfwControlScript . OUT_LOG_DEFAULT_PATH class \u2018str\u2019 default: \u201c%temp%\\installer.out\u201d \u00b6 QtIfwControlScript . OUT_LOG_PATH_CMD_ARG class \u2018str\u2019 default: \u201coutlog\u201d \u00b6 QtIfwControlScript . PATH_SEP class \u2018str\u2019 default: \u201d\u201c\\\u201c\u201d \u00b6 QtIfwControlScript . PRODUCT_NAME_KEY class \u2018str\u2019 default: \u201cProductName\u201d \u00b6 QtIfwControlScript . QUIT_MSGBOX_ID class \u2018str\u2019 default: \u201ccancelInstallation\u201d \u00b6 QtIfwControlScript . REBOOT_CMD_ARG class \u2018str\u2019 default: \u201creboot\u201d \u00b6 QtIfwControlScript . RESTORE_MSGBOX_DEFAULT class \u2018str\u2019 default: \u201cQMessageBox.RestoreDefaults\u201d \u00b6 QtIfwControlScript . RUN_PROGRAM_CHECKBOX class \u2018str\u2019 default: \u201cRunItCheckBox\u201d \u00b6 QtIfwControlScript . RUN_PROGRAM_CMD_ARG class \u2018str\u2019 default: \u201crun\u201d \u00b6 QtIfwControlScript . STARTMENU_DIR_KEY class \u2018str\u2019 default: \u201cStartMenuDir\u201d \u00b6 QtIfwControlScript . START_BLOCK class \u2018str\u2019 default: *\u201d{ \u00b6 \u201d* { #START_BLOCK data-toc-label=START_BLOCK } QtIfwControlScript . START_MENU_DIR_CMD_ARG class \u2018str\u2019 default: \u201cstartmenu\u201d \u00b6 QtIfwControlScript . START_MENU_DIR_EDITBOX class \u2018str\u2019 default: \u201cStartMenuPathLineEdit\u201d \u00b6 QtIfwControlScript . TAB class \u2018str\u2019 default: \u201d \u201c \u00b6 QtIfwControlScript . TARGET_DIR_CMD_ARG class \u2018str\u2019 default: \u201ctarget\u201d \u00b6 QtIfwControlScript . TARGET_DIR_EDITBOX class \u2018str\u2019 default: \u201cTargetDirectoryLineEdit\u201d \u00b6 QtIfwControlScript . TARGET_DIR_KEY class \u2018str\u2019 default: \u201cTargetDir\u201d \u00b6 QtIfwControlScript . TARGET_EXISTS_OPT_CMD_ARG class \u2018str\u2019 default: \u201conexist\u201d \u00b6 QtIfwControlScript . TARGET_EXISTS_OPT_FAIL class \u2018str\u2019 default: \u201cfail\u201d \u00b6 QtIfwControlScript . TARGET_EXISTS_OPT_PROMPT class \u2018str\u2019 default: \u201cprompt\u201d \u00b6 QtIfwControlScript . TARGET_EXISTS_OPT_REMOVE class \u2018str\u2019 default: \u201cremove\u201d \u00b6 QtIfwControlScript . TRUE class \u2018str\u2019 default: \u201ctrue\u201d \u00b6 QtIfwControlScript . TRY class \u2018str\u2019 default: \u201ctry { \u201c \u00b6 QtIfwControlScript . USER_KEY class \u2018str\u2019 default: \u201cUser\u201d \u00b6 QtIfwControlScript . VERBOSE_CMD_SWITCH_ARG class \u2018str\u2019 default: \u201c-v\u201d \u00b6 QtIfwControlScript . YES class \u2018str\u2019 default: \u201cQMessageBox.Yes\u201d \u00b6 QtIfwDynamicOperationsPage class \u00b6 Base Classes: _QtIfwInterface, QtIfwUiPage Magic Methods: __init__ Instance Methods: fileName resolve write Instance Attributes: supportScript name args body delayMillis standardPageId customPageName Class/Static Methods: onCompleted Class/Static Attributes: AsyncFunc BASE_ON_ENTER_TMPT BASE_ON_LOAD_TMPT QtIfwDynamicOperationsPage ( name , operation = '' , asyncFuncs = None , order = 0 , onCompletedDelayMillis = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . fileName ( self ) \u00b6 obj . resolve ( self , qtIfwConfig ) \u00b6 obj . write ( self , dirPath ) \u00b6 obj . supportScript class \u2018NoneType\u2019 default: None \u00b6 obj . name class \u2018NoneType\u2019 default: None \u00b6 obj . args class \u2018NoneType\u2019 default: None \u00b6 obj . body class \u2018NoneType\u2019 default: None \u00b6 obj . delayMillis class \u2018NoneType\u2019 default: None \u00b6 obj . standardPageId class \u2018NoneType\u2019 default: None \u00b6 obj . customPageName class \u2018NoneType\u2019 default: None \u00b6 QtIfwDynamicOperationsPage . onCompleted ( name ) \u00b6 QtIfwDynamicOperationsPage . AsyncFunc class \u2018type\u2019 default: None \u00b6 QtIfwDynamicOperationsPage . BASE_ON_ENTER_TMPT class \u2018str\u2019 default: None \u00b6 QtIfwDynamicOperationsPage . BASE_ON_LOAD_TMPT class \u2018str\u2019 default: None \u00b6 QtIfwDynamicOperationsPage.AsyncFunc class \u00b6 Instance Methods: invoke obj . invoke ( self , args = None , isAutoQuote = True ) \u00b6 QtIfwExeWrapper class \u00b6 Magic Methods: __init__ Instance Methods: refresh Instance Attributes: exeName isGui wrapperScript exeDir workingDir args envVars isElevated isExe wrapperExeName wrapperIconName QtIfwExeWrapper ( exeName , isGui = False , wrapperScript = None , exeDir = '@TargetDir@' , workingDir = None , args = None , envVars = None , isElevated = False , isExe = False ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . refresh ( self ) \u00b6 obj . exeName class \u2018NoneType\u2019 default: None \u00b6 obj . isGui class \u2018NoneType\u2019 default: None \u00b6 obj . wrapperScript class \u2018NoneType\u2019 default: None \u00b6 obj . exeDir class \u2018NoneType\u2019 default: None \u00b6 obj . workingDir class \u2018NoneType\u2019 default: None \u00b6 obj . args class \u2018NoneType\u2019 default: None \u00b6 obj . envVars class \u2018NoneType\u2019 default: None \u00b6 obj . isElevated class \u2018NoneType\u2019 default: None \u00b6 obj . isExe class \u2018NoneType\u2019 default: None \u00b6 obj . wrapperExeName class \u2018NoneType\u2019 default: None \u00b6 obj . wrapperIconName class \u2018NoneType\u2019 default: None \u00b6 QtIfwExternalOp class \u00b6 Magic Methods: __init__ Instance Methods: Instance Attributes: script exePath args successRetCodes uninstScript uninstExePath uninstArgs uninstRetCodes isElevated workingDir onErrorMessage resourceScripts uninstResourceScripts externalRes Class/Static Methods: CopyExeVerInfoScript CopyExternalResource CopyFile CopyFileScript CreateExeFromScript CreateOpFlagFile CreateOpFlagFileScript CreateRegistryEntry CreateRegistryEntryScript CreateRegistryKey CreateRegistryKeyScript CreateStartupEntry CreateWindowsAppFoundFlagFile CreateWindowsAppFoundFlagFileScript EmbedExeVerInfoScript ExtractIconsFromExeScript MakeDir MakeDirScript RemoveDir RemoveDirScript RemoveFile RemoveFileScript RemoveRegistryEntry RemoveRegistryEntryScript RemoveRegistryKey RemoveRegistryKeyScript ReplacePrimaryIconInExeScript RunProgram RunProgramScript Script2Exe Script2ExeScript UninstallWindowsApp UninstallWindowsAppScript WaitForProcess WaitForProcessScript WrapperScript2Exe WriteFile WriteFileScript WriteOpDataFile WriteOpDataFileScript appleScriptSelfDestructSnippet batchSelfDestructSnippet opDataPath powerShellSelfDestructSnippet shellScriptSelfDestructSnippet vbScriptSelfDestructSnippet Class/Static Attributes: AUTO_UNDO ON_BOTH ON_INSTALL ON_UNINSTALL QtIfwExternalOp ( script = None , exePath = None , args = None , successRetCodes = None , uninstScript = None , uninstExePath = None , uninstArgs = None , uninstRetCodes = None , isElevated = False , workingDir = '@TargetDir@' , onErrorMessage = None , resourceScripts = None , uninstResourceScripts = None , externalRes = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . script class \u2018NoneType\u2019 default: None \u00b6 obj . exePath class \u2018NoneType\u2019 default: None \u00b6 obj . args class \u2018list\u2019 default: [] \u00b6 obj . successRetCodes class \u2018list\u2019 default: [0] \u00b6 obj . uninstScript class \u2018NoneType\u2019 default: None \u00b6 obj . uninstExePath class \u2018NoneType\u2019 default: None \u00b6 obj . uninstArgs class \u2018list\u2019 default: [] \u00b6 obj . uninstRetCodes class \u2018list\u2019 default: [0] \u00b6 obj . isElevated class \u2018NoneType\u2019 default: None \u00b6 obj . workingDir class \u2018NoneType\u2019 default: None \u00b6 obj . onErrorMessage class \u2018NoneType\u2019 default: None \u00b6 obj . resourceScripts class \u2018list\u2019 default: [] \u00b6 obj . uninstResourceScripts class \u2018list\u2019 default: [] \u00b6 obj . externalRes class \u2018list\u2019 default: [] \u00b6 QtIfwExternalOp . CopyExeVerInfoScript ( srcExePath , destExePath ) \u00b6 QtIfwExternalOp . CopyExternalResource ( event , externRes , destPath , contentKey = None , owner = '@User@' , group = '@User@' , access = '644' , isElevated = True ) \u00b6 QtIfwExternalOp . CopyFile ( event , scrPath , destPath , owner = '@User@' , group = '@User@' , access = '644' , isElevated = True ) \u00b6 QtIfwExternalOp . CopyFileScript ( srcPath , destPath , owner = '@User@' , group = '@User@' , access = '644' ) \u00b6 QtIfwExternalOp . CreateExeFromScript ( script , exeVerInfo , srcIconPath , targetDir = '@TargetDir@' ) \u00b6 QtIfwExternalOp . CreateOpFlagFile ( event , fileName , dynamicVar = None , isElevated = True ) \u00b6 QtIfwExternalOp . CreateOpFlagFileScript ( fileName , dynamicVar = None ) \u00b6 QtIfwExternalOp . CreateRegistryEntry ( event , key , valueName = None , value = '' , valueType = 'String' , isAutoBitContext = True ) \u00b6 QtIfwExternalOp . CreateRegistryEntryScript ( key , valueName = None , value = '' , valueType = 'String' , isAutoBitContext = True , replacements = None ) \u00b6 QtIfwExternalOp . CreateRegistryKey ( event , key , isAutoBitContext = True ) \u00b6 QtIfwExternalOp . CreateRegistryKeyScript ( key , isAutoBitContext = True , replacements = None ) \u00b6 QtIfwExternalOp . CreateStartupEntry ( pkg = None , exePath = None , displayName = None , isAllUsers = False ) \u00b6 QtIfwExternalOp . CreateWindowsAppFoundFlagFile ( event , appName , fileName , isAutoBitContext = True ) \u00b6 QtIfwExternalOp . CreateWindowsAppFoundFlagFileScript ( appName , fileName , isAutoBitContext = True , isSelfDestruct = False ) \u00b6 QtIfwExternalOp . EmbedExeVerInfoScript ( exePath , exeVerInfo ) \u00b6 QtIfwExternalOp . ExtractIconsFromExeScript ( exePath , targetDirPath ) \u00b6 QtIfwExternalOp . MakeDir ( event , dirPath , owner = '@User@' , group = '@User@' , access = '755' , isElevated = True ) \u00b6 QtIfwExternalOp . MakeDirScript ( dirPath , owner = '@User@' , group = '@User@' , access = '755' ) \u00b6 QtIfwExternalOp . RemoveDir ( event , dirPath , isElevated = True ) \u00b6 QtIfwExternalOp . RemoveDirScript ( dirPath ) \u00b6 QtIfwExternalOp . RemoveFile ( event , filePath , isElevated = True ) \u00b6 QtIfwExternalOp . RemoveFileScript ( filePath ) \u00b6 QtIfwExternalOp . RemoveRegistryEntry ( event , key , valueName = None , isAutoBitContext = True ) \u00b6 QtIfwExternalOp . RemoveRegistryEntryScript ( key , valueName = None , isAutoBitContext = True , replacements = None ) \u00b6 QtIfwExternalOp . RemoveRegistryKey ( event , key , isAutoBitContext = True ) \u00b6 QtIfwExternalOp . RemoveRegistryKeyScript ( key , isAutoBitContext = True , replacements = None ) \u00b6 QtIfwExternalOp . ReplacePrimaryIconInExeScript ( exePath , iconDirPath , iconName = None , isIconDirRemoved = False ) \u00b6 Note the use of if %PROCESSOR_ARCHITECTURE%==x86 ( \u201c%windir%\\sysnative\\cmd\u201d \u2026 That is extremely important here, as \u201cie4uinit\u201d is a 64 bit program, and the installer runs in 32 bit context. The use %windir%\\sysnative\\cmd allows this 32 bit program to \u201csee\u201d and execute a 64 bit sub process. Without that, you get mind blowing errors thrown back at you saying the the file does not even exist (including when you specify an absolute path to the file you know for a fact is found there)! QtIfwExternalOp . RunProgram ( event , path , arguments = None , isAutoQuote = True , isHidden = False , isSynchronous = True , isElevated = True , runConditionFileName = None , isRunConditionNegated = False , isAutoBitContext = True ) \u00b6 QtIfwExternalOp . RunProgramScript ( path , arguments = None , isAutoQuote = True , isHidden = False , isSynchronous = True , runConditionFileName = None , isRunConditionNegated = False , isAutoBitContext = True , replacements = None ) \u00b6 QtIfwExternalOp . Script2Exe ( scriptPath , exePath , exeVerInfo , iconDirPath , iconName , isScriptRemoved = False , isIconDirRemoved = False ) \u00b6 QtIfwExternalOp . Script2ExeScript ( srcPath , destPath , isSrcRemoved = False ) \u00b6 QtIfwExternalOp . UninstallWindowsApp ( event , appName , arguments = None , isSynchronous = True , isHidden = True , isAutoBitContext = True , isSuccessOnNotFound = True ) \u00b6 QtIfwExternalOp . UninstallWindowsAppScript ( appName , arguments = None , isSynchronous = True , isHidden = True , isAutoBitContext = True , isSelfDestruct = False ) \u00b6 QtIfwExternalOp . WaitForProcess ( event , exeName = None , pidFileName = None , timeOutSeconds = 30 , isWaitForStart = False , isSuccessNoWait = True , isAutoBitContext = True ) \u00b6 QtIfwExternalOp . WaitForProcessScript ( exeName = None , pidFileName = None , timeOutSeconds = 30 , onTimeout = None , isWaitForStart = False , isDeletePidFile = False , isExitOnSuccess = True , isExitOnNoWait = True , isExitOnTimeout = True , isSelfDestruct = False , isAutoBitContext = True ) \u00b6 QtIfwExternalOp . WrapperScript2Exe ( scriptPath , exePath , targetPath , iconName = None ) \u00b6 QtIfwExternalOp . WriteFile ( event , filePath , data , isOverwrite = True , owner = '@User@' , group = '@User@' , access = '644' , isElevated = True ) \u00b6 QtIfwExternalOp . WriteFileScript ( filePath , data = None , isOverwrite = True , owner = '@User@' , group = '@User@' , access = '644' ) \u00b6 QtIfwExternalOp . WriteOpDataFile ( event , fileName , data , isElevated = True ) \u00b6 QtIfwExternalOp . WriteOpDataFileScript ( fileName , data = None ) \u00b6 QtIfwExternalOp . appleScriptSelfDestructSnippet () \u00b6 QtIfwExternalOp . batchSelfDestructSnippet () \u00b6 QtIfwExternalOp . opDataPath ( rootFileName , isDetached = False , isNative = True , quotes = None , isDoubleBackslash = False ) \u00b6 QtIfwExternalOp . powerShellSelfDestructSnippet () \u00b6 QtIfwExternalOp . shellScriptSelfDestructSnippet () \u00b6 QtIfwExternalOp . vbScriptSelfDestructSnippet () \u00b6 QtIfwExternalOp . AUTO_UNDO class \u2018int\u2019 default: 3 \u00b6 QtIfwExternalOp . ON_BOTH class \u2018int\u2019 default: 2 \u00b6 QtIfwExternalOp . ON_INSTALL class \u2018int\u2019 default: 0 \u00b6 QtIfwExternalOp . ON_UNINSTALL class \u2018int\u2019 default: 1 \u00b6 QtIfwExternalResource class \u00b6 Magic Methods: __init__ Instance Methods: targetDirPath targetDirPathVar targetPath targetPathVar Instance Attributes: name srcPath destPath isMaintenanceNeed contentKeys Class/Static Methods: BuiltIn Class/Static Attributes: RESOURCE_HACKER QtIfwExternalResource ( name , srcPath , srcBasePath = None , destPath = None , isMaintenanceNeed = False , contentKeys = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . targetDirPath ( self ) \u00b6 obj . targetDirPathVar ( self ) \u00b6 obj . targetPath ( self , key = None ) \u00b6 obj . targetPathVar ( self , key = None ) \u00b6 obj . name class \u2018NoneType\u2019 default: None \u00b6 obj . srcPath class \u2018NoneType\u2019 default: None \u00b6 obj . destPath class \u2018NoneType\u2019 default: None \u00b6 obj . isMaintenanceNeed class \u2018NoneType\u2019 default: None \u00b6 obj . contentKeys class \u2018NoneType\u2019 default: None \u00b6 QtIfwExternalResource . BuiltIn ( name , isMaintenanceNeed = False ) \u00b6 QtIfwExternalResource . RESOURCE_HACKER class \u2018str\u2019 default: None \u00b6 QtIfwKillOp class \u00b6 Magic Methods: __init__ Instance Methods: Instance Attributes: processName onInstall onUninstall isElevated QtIfwKillOp ( processName , onInstall = True , onUninstall = True ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . processName class \u2018NoneType\u2019 default: None \u00b6 obj . onInstall class \u2018NoneType\u2019 default: None \u00b6 obj . onUninstall class \u2018NoneType\u2019 default: None \u00b6 obj . isElevated class \u2018bool\u2019 default: True \u00b6 QtIfwOnFinishedCheckbox class \u00b6 Base Classes: QtIfwOnFinishedDetachedExec, _QtIfwInterface, QtIfwWidget Magic Methods: __init__ Instance Methods: enable fileName isChecked resolve setChecked setVisible write Instance Attributes: checkboxName text Class/Static Attributes: BASE_ON_LOAD_TMPT ON_BOTH ON_INSTALL ON_UNINSTALL QtIfwOnFinishedCheckbox ( name , text = None , position = None , ifwPackage = None , runProgram = None , argList = None , shellCmd = None , script = None , openViaOsPath = None , isReboot = False , rebootDelaySecs = 2 , isVisible = True , isEnabled = True , isChecked = True ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . enable ( self , isEnable = True ) \u00b6 obj . fileName ( self ) \u00b6 obj . isChecked ( self ) \u00b6 obj . resolve ( self , qtIfwConfig ) \u00b6 obj . setChecked ( self , isChecked = True ) \u00b6 obj . setVisible ( self , isVisible = True ) \u00b6 obj . write ( self , dirPath ) \u00b6 obj . checkboxName class \u2018NoneType\u2019 default: None \u00b6 obj . text class \u2018NoneType\u2019 default: None \u00b6 QtIfwOnFinishedCheckbox . BASE_ON_LOAD_TMPT class \u2018str\u2019 default: None \u00b6 QtIfwOnFinishedCheckbox . ON_BOTH class \u2018int\u2019 default: None \u00b6 QtIfwOnFinishedCheckbox . ON_INSTALL class \u2018int\u2019 default: None \u00b6 QtIfwOnFinishedCheckbox . ON_UNINSTALL class \u2018int\u2019 default: None \u00b6 QtIfwOnFinishedDetachedExec class \u00b6 Magic Methods: __init__ Instance Methods: Instance Attributes: name event runProgram argList script isReboot ifCondition Class/Static Attributes: ON_BOTH ON_INSTALL ON_UNINSTALL QtIfwOnFinishedDetachedExec ( name , event = None , ifwPackage = None , runProgram = None , argList = None , shellCmd = None , script = None , openViaOsPath = None , isReboot = False , rebootDelaySecs = 2 , ifCondition = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . name class \u2018NoneType\u2019 default: None \u00b6 obj . event class \u2018int\u2019 default: 0 \u00b6 obj . runProgram class \u2018NoneType\u2019 default: None \u00b6 obj . argList class \u2018NoneType\u2019 default: None \u00b6 obj . script class \u2018NoneType\u2019 default: None \u00b6 obj . isReboot class \u2018NoneType\u2019 default: None \u00b6 obj . ifCondition class \u2018NoneType\u2019 default: None \u00b6 QtIfwOnFinishedDetachedExec . ON_BOTH class \u2018int\u2019 default: 2 \u00b6 QtIfwOnFinishedDetachedExec . ON_INSTALL class \u2018int\u2019 default: 0 \u00b6 QtIfwOnFinishedDetachedExec . ON_UNINSTALL class \u2018int\u2019 default: 1 \u00b6 QtIfwPackage class \u00b6 Magic Methods: __init__ Instance Methods: contentDirPath contentTopDirPath dirPath metaDirPath Instance Attributes: pkgId pkgType name pkgXml pkgScript uiPages widgets licenses isLicenseFormatPreserved srcDirPath srcExePath resBasePath distResources isTempSrc subDirName exeName isGui exeWrapper codeSignTargets qtCppConfig Class/Static Methods: topDirPath Class/Static Attributes: Type QtIfwPackage ( pkgId = None , pkgType = None , name = None , subDirName = None , srcDirPath = None , srcExePath = None , resBasePath = None , isTempSrc = False , pkgXml = None , pkgScript = None , licenses = None , uiPages = None , widgets = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . contentDirPath ( self ) \u00b6 obj . contentTopDirPath ( self ) \u00b6 obj . dirPath ( self ) \u00b6 obj . metaDirPath ( self ) \u00b6 obj . pkgId class \u2018NoneType\u2019 default: None \u00b6 obj . pkgType class \u2018NoneType\u2019 default: None \u00b6 obj . name class \u2018NoneType\u2019 default: None \u00b6 obj . pkgXml class \u2018NoneType\u2019 default: None \u00b6 obj . pkgScript class \u2018NoneType\u2019 default: None \u00b6 obj . uiPages class \u2018list\u2019 default: [] \u00b6 obj . widgets class \u2018list\u2019 default: [] \u00b6 obj . licenses class \u2018dict\u2019 default: {} \u00b6 obj . isLicenseFormatPreserved class \u2018bool\u2019 default: False \u00b6 obj . srcDirPath class \u2018NoneType\u2019 default: None \u00b6 obj . srcExePath class \u2018NoneType\u2019 default: None \u00b6 obj . resBasePath class \u2018NoneType\u2019 default: None \u00b6 obj . distResources class \u2018NoneType\u2019 default: None \u00b6 obj . isTempSrc class \u2018NoneType\u2019 default: None \u00b6 obj . subDirName class \u2018NoneType\u2019 default: None \u00b6 obj . exeName class \u2018NoneType\u2019 default: None \u00b6 obj . isGui class \u2018bool\u2019 default: False \u00b6 obj . exeWrapper class \u2018NoneType\u2019 default: None \u00b6 obj . codeSignTargets class \u2018NoneType\u2019 default: None \u00b6 obj . qtCppConfig class \u2018NoneType\u2019 default: None \u00b6 QtIfwPackage . topDirPath () \u00b6 QtIfwPackage . Type class \u2018type\u2019 default: class \u2018qt_installer.QtIfwPackage.Type\u2019 \u00b6 QtIfwPackage.Type class \u00b6 Class/Static Attributes: DATA IEXPRESS PY_INSTALLER QT_CPP RAW RESOURCE QtIfwPackage.Type . DATA class \u2018int\u2019 default: 1 \u00b6 QtIfwPackage.Type . IEXPRESS class \u2018int\u2019 default: 4 \u00b6 QtIfwPackage.Type . PY_INSTALLER class \u2018int\u2019 default: 3 \u00b6 QtIfwPackage.Type . QT_CPP class \u2018int\u2019 default: 5 \u00b6 QtIfwPackage.Type . RAW class \u2018int\u2019 default: 0 \u00b6 QtIfwPackage.Type . RESOURCE class \u2018int\u2019 default: 2 \u00b6 QtIfwPackageScript class \u00b6 Base Classes: _QtIfwScript Magic Methods: __init__ Instance Methods: addSimpleOperation debug dirPath exists path write Instance Attributes: pkgName pkgVersion pkgSubDirName shortcuts externalOps killOps preOpSupport customOperations bundledScripts dynamicTexts installResources externalDependencies areDependenciesPreserved uiPages widgets packageGlobals isAutoGlobals componentConstructorBody isAutoComponentConstructor componentLoadedCallbackBody isAutoComponentLoadedCallback componentEnteredCallbackBody isAutoComponentEnteredCallback componentCreateOperationsBody isAutoComponentCreateOperations componentCreateOperationsForArchiveBody isAutoComponentCreateOperationsForArchive Class/Static Methods: andList assertInternetConnected assignRegistryEntryVar boolToString cmdLineArg cmdLineListArg cmdLineSwitchArg debugPopup deleteDetachedOpDataFile deleteFile deleteOpDataFile disableQuit disableQuitPrompt dropElevation elevate embedResources enableComponent errorPopup genResources getComponent getEnv getPageOwner ifAutoPilot ifBoolValue ifCmdLineArg ifCmdLineSwitch ifComponentEnabled ifComponentInstalled ifComponentSelected ifCondition ifDryRun ifElevated ifInstalling ifInternetConnected ifMaintenanceTool ifPathExists ifPingable ifRegistryEntryExists ifRegistryEntryExistsLike ifRegistryKeyExists ifRegistryKeyExistsLike ifValueDefined ifYesNoPopup isAutoPilot isComponentEnabled isComponentInstalled isComponentSelected isDryRun isElevated isInstalling isInternetConnected isMaintenanceTool isPingable killAll log logSwitch logValue lookupBoolValue lookupValue lookupValueList makeDir orList pathExists productName quit quote registryEntryExists registryEntryExistsLike registryEntryValue registryKeyExists registryKeyExistsLike removeDir resolveDynamTxtVarsOperations resolveDynamicVars resolveScriptVars resolveScriptVarsOperations setBoolValue setValue setValueFromRegistryEntry startMenuDir stringToBool switchYesNoCancelPopup targetDir toBool toNull warningPopup writeDetachedOpDataFile writeFile writeOpDataFile yesNoCancelPopup yesNoPopup Class/Static Attributes: ABORT ACCEPT_EULA_CMD_ARG AND ASSIGN AUTH_ERROR_MSGBOX_ID AUTO_PILOT_CMD_ARG CANCEL CATCH CONCAT DEFAULT_TARGET_DIR_KEY DRYRUN_CMD_ARG ELSE END_BLOCK END_LINE EQUAL_TO ERR_LOG_DEFAULT_PATH ERR_LOG_PATH_CMD_ARG EXCLUDE_LIST_CMD_ARG EXIT_FUNCTION FALSE IF INCLUDE_LIST_CMD_ARG INSTALL_LIST_CMD_ARG INTERUPTED_KEY IS_NET_CONNECTED_KEY MAINTAIN_MODE_CMD_ARG MAINTAIN_MODE_OPT_ADD_REMOVE MAINTAIN_MODE_OPT_REMOVE_ALL MAINTAIN_MODE_OPT_UPDATE MAINTAIN_PASSTHRU_CMD_ARG MAINTENANCE_TOOL_NAME NEW_LINE NO NOT NOT_EQUAL_TO NULL OK OR OUT_LOG_DEFAULT_PATH OUT_LOG_PATH_CMD_ARG PATH_SEP PRODUCT_NAME_KEY QUIT_MSGBOX_ID REBOOT_CMD_ARG RESTORE_MSGBOX_DEFAULT RUN_PROGRAM_CMD_ARG STARTMENU_DIR_KEY START_BLOCK START_MENU_DIR_CMD_ARG TAB TARGET_DIR_CMD_ARG TARGET_DIR_KEY TARGET_EXISTS_OPT_CMD_ARG TARGET_EXISTS_OPT_FAIL TARGET_EXISTS_OPT_PROMPT TARGET_EXISTS_OPT_REMOVE TRUE TRY USER_KEY VERBOSE_CMD_SWITCH_ARG YES QtIfwPackageScript ( pkgName , pkgVersion , pkgSubDirName = None , shortcuts = None , bundledScripts = None , dynamicTexts = None , externalOps = None , installResources = None , uiPages = None , widgets = None , fileName = 'installscript.qs' , script = None , scriptPath = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . addSimpleOperation ( self , name , parms = None , isElevated = False , isAutoQuote = True ) \u00b6 obj . debug ( self ) \u00b6 obj . dirPath ( self ) \u00b6 PURE VIRTUAL obj . exists ( self ) \u00b6 obj . path ( self ) \u00b6 PURE VIRTUAL obj . write ( self ) \u00b6 obj . pkgName class \u2018NoneType\u2019 default: None \u00b6 obj . pkgVersion class \u2018NoneType\u2019 default: None \u00b6 obj . pkgSubDirName class \u2018NoneType\u2019 default: None \u00b6 obj . shortcuts class \u2018list\u2019 default: [] \u00b6 obj . externalOps class \u2018list\u2019 default: [] \u00b6 obj . killOps class \u2018list\u2019 default: [] \u00b6 obj . preOpSupport class \u2018NoneType\u2019 default: None \u00b6 obj . customOperations class \u2018NoneType\u2019 default: None \u00b6 obj . bundledScripts class \u2018list\u2019 default: [] \u00b6 obj . dynamicTexts class \u2018dict\u2019 default: {} \u00b6 obj . installResources class \u2018list\u2019 default: [] \u00b6 obj . externalDependencies class \u2018list\u2019 default: [] \u00b6 obj . areDependenciesPreserved class \u2018bool\u2019 default: True \u00b6 obj . uiPages class \u2018list\u2019 default: [] \u00b6 obj . widgets class \u2018list\u2019 default: [] \u00b6 obj . packageGlobals class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoGlobals class \u2018bool\u2019 default: True \u00b6 obj . componentConstructorBody class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoComponentConstructor class \u2018bool\u2019 default: True \u00b6 obj . componentLoadedCallbackBody class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoComponentLoadedCallback class \u2018bool\u2019 default: True \u00b6 obj . componentEnteredCallbackBody class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoComponentEnteredCallback class \u2018bool\u2019 default: True \u00b6 obj . componentCreateOperationsBody class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoComponentCreateOperations class \u2018bool\u2019 default: True \u00b6 obj . componentCreateOperationsForArchiveBody class \u2018NoneType\u2019 default: None \u00b6 obj . isAutoComponentCreateOperationsForArchive class \u2018bool\u2019 default: True \u00b6 QtIfwPackageScript . andList ( conditions ) \u00b6 QtIfwPackageScript . assertInternetConnected ( isRefresh = False , errMsg = None , isAutoQuote = True ) \u00b6 QtIfwPackageScript . assignRegistryEntryVar ( key , valueName , isAutoBitContext = True , varName = 'regValue' , isAutoQuote = True ) \u00b6 QtIfwPackageScript . boolToString ( b ) \u00b6 QtIfwPackageScript . cmdLineArg ( arg , default = '' ) \u00b6 QtIfwPackageScript . cmdLineListArg ( arg , default = None ) \u00b6 QtIfwPackageScript . cmdLineSwitchArg ( arg , isNegated = False , isHardFalse = False ) \u00b6 QtIfwPackageScript . debugPopup ( msg , isAutoQuote = True ) \u00b6 QtIfwPackageScript . deleteDetachedOpDataFile ( fileName ) \u00b6 QtIfwPackageScript . deleteFile ( path , isAutoQuote = True ) \u00b6 QtIfwPackageScript . deleteOpDataFile ( fileName ) \u00b6 QtIfwPackageScript . disableQuit () \u00b6 QtIfwPackageScript . disableQuitPrompt () \u00b6 QtIfwPackageScript . dropElevation () \u00b6 QtIfwPackageScript . elevate () \u00b6 QtIfwPackageScript . embedResources ( embeddedResources ) \u00b6 QtIfwPackageScript . enableComponent ( package , enable = True , isAutoQuote = True ) \u00b6 QtIfwPackageScript . errorPopup ( msg , isAutoQuote = True ) \u00b6 QtIfwPackageScript . genResources ( embeddedResources , isTempRootTarget = False ) \u00b6 QtIfwPackageScript . getComponent ( name , isAutoQuote = True ) \u00b6 QtIfwPackageScript . getEnv ( varName , isAutoQuote = True ) \u00b6 QtIfwPackageScript . getPageOwner ( pageName , isAutoQuote = True ) \u00b6 QtIfwPackageScript . ifAutoPilot ( isNegated = False , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifBoolValue ( key , isNegated = False , isHardFalse = False , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifCmdLineArg ( arg , isNegated = False , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifCmdLineSwitch ( arg , isNegated = False , isHardFalse = False , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifComponentEnabled ( package , isNegated = False , isAutoQuote = True , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifComponentInstalled ( package , isNegated = False , isAutoQuote = True , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifComponentSelected ( package , isNegated = False , isAutoQuote = True , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifCondition ( condition , isNegated = False , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifDryRun ( isNegated = False , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifElevated ( isNegated = False , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifInstalling ( isNegated = False , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifInternetConnected ( isRefresh = False , isNegated = False , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifMaintenanceTool ( isNegated = False , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifPathExists ( path , isNegated = False , isAutoQuote = True , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifPingable ( uri , pings = 3 , totalMaxSecs = 12 , isAutoQuote = True , isNegated = False , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifRegistryEntryExists ( key , valueName , isAutoBitContext = True , isNegated = False , isAutoQuote = True , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifRegistryEntryExistsLike ( key , valueNameContains , isAutoBitContext = True , isCaseSensitive = False , isRecursive = False , isNegated = False , isAutoQuote = True , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifRegistryKeyExists ( key , isAutoBitContext = True , isNegated = False , isAutoQuote = True , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifRegistryKeyExistsLike ( parentKey , childKeyNameContains , isAutoBitContext = True , isCaseSensitive = False , isRecursive = False , isNegated = False , isAutoQuote = True , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifValueDefined ( key , isNegated = False , isMultiLine = False ) \u00b6 QtIfwPackageScript . ifYesNoPopup ( msg , title = 'Question' , resultVar = 'result' , isMultiLine = False ) \u00b6 QtIfwPackageScript . isAutoPilot ( isNegated = False ) \u00b6 QtIfwPackageScript . isComponentEnabled ( package , isAutoQuote = True ) \u00b6 QtIfwPackageScript . isComponentInstalled ( package , isAutoQuote = True ) \u00b6 QtIfwPackageScript . isComponentSelected ( package , isAutoQuote = True ) \u00b6 QtIfwPackageScript . isDryRun ( isNegated = False ) \u00b6 QtIfwPackageScript . isElevated () \u00b6 QtIfwPackageScript . isInstalling ( isNegated = False ) \u00b6 QtIfwPackageScript . isInternetConnected ( isRefresh = False ) \u00b6 QtIfwPackageScript . isMaintenanceTool ( isNegated = False ) \u00b6 QtIfwPackageScript . isPingable ( uri , pings = 3 , totalMaxSecs = 12 , isAutoQuote = True ) \u00b6 QtIfwPackageScript . killAll ( exeName , isAutoQuote = True ) \u00b6 QtIfwPackageScript . log ( msg , isAutoQuote = True ) \u00b6 QtIfwPackageScript . logSwitch ( key ) \u00b6 QtIfwPackageScript . logValue ( key , defaultVal = '' ) \u00b6 QtIfwPackageScript . lookupBoolValue ( key , isNegated = False , isHardFalse = False , isAutoQuote = True ) \u00b6 QtIfwPackageScript . lookupValue ( key , default = '' , isAutoQuote = True ) \u00b6 QtIfwPackageScript . lookupValueList ( key , defaultList = None , isAutoQuote = True , delimiter = None ) \u00b6 QtIfwPackageScript . makeDir ( path , isAutoQuote = True ) \u00b6 QtIfwPackageScript . orList ( conditions ) \u00b6 QtIfwPackageScript . pathExists ( path , isNegated = False , isAutoQuote = True ) \u00b6 QtIfwPackageScript . productName () \u00b6 QtIfwPackageScript . quit ( msg , isError = True , isSilent = False , isAutoQuote = True ) \u00b6 QtIfwPackageScript . quote ( value ) \u00b6 QtIfwPackageScript . registryEntryExists ( key , valueName , isAutoBitContext = True , isAutoQuote = True ) \u00b6 QtIfwPackageScript . registryEntryExistsLike ( key , valueNameContains , isAutoBitContext = True , isCaseSensitive = False , isRecursive = False , isAutoQuote = True ) \u00b6 QtIfwPackageScript . registryEntryValue ( key , valueName , isAutoBitContext = True , isAutoQuote = True ) \u00b6 QtIfwPackageScript . registryKeyExists ( key , isAutoBitContext = True , isAutoQuote = True ) \u00b6 QtIfwPackageScript . registryKeyExistsLike ( parentKey , childKeyNameContains , isAutoBitContext = True , isCaseSensitive = False , isRecursive = False , isAutoQuote = True ) \u00b6 QtIfwPackageScript . removeDir ( path , isAutoQuote = True ) \u00b6 QtIfwPackageScript . resolveDynamTxtVarsOperations ( plasticFile , destPath ) \u00b6 QtIfwPackageScript . resolveDynamicVars ( s , varNames = None , isAutoQuote = True ) \u00b6 QtIfwPackageScript . resolveScriptVars ( scripts , subDir ) \u00b6 QtIfwPackageScript . resolveScriptVarsOperations ( scripts , subDir ) \u00b6 QtIfwPackageScript . setBoolValue ( key , b , isAutoQuote = True ) \u00b6 QtIfwPackageScript . setValue ( key , value , isAutoQuote = True ) \u00b6 QtIfwPackageScript . setValueFromRegistryEntry ( key , regKey , valueName , isAutoBitContext = True , isAutoQuote = True ) \u00b6 QtIfwPackageScript . startMenuDir () \u00b6 QtIfwPackageScript . stringToBool ( value , isAutoQuote = True ) \u00b6 QtIfwPackageScript . switchYesNoCancelPopup ( msg , title = 'Question' , resultVar = 'result' , onYes = '' , onNo = '' , onCancel = '' ) \u00b6 QtIfwPackageScript . targetDir () \u00b6 QtIfwPackageScript . toBool ( b ) \u00b6 QtIfwPackageScript . toNull ( v ) \u00b6 QtIfwPackageScript . warningPopup ( msg , isAutoQuote = True ) \u00b6 QtIfwPackageScript . writeDetachedOpDataFile ( fileName , content = '' , isAutoQuote = True ) \u00b6 QtIfwPackageScript . writeFile ( path , content , isAutoQuote = True ) \u00b6 QtIfwPackageScript . writeOpDataFile ( fileName , content = '' , isAutoQuote = True ) \u00b6 QtIfwPackageScript . yesNoCancelPopup ( msg , title = 'Question' , resultVar = 'result' ) \u00b6 QtIfwPackageScript . yesNoPopup ( msg , title = 'Question' , resultVar = 'result' ) \u00b6 QtIfwPackageScript . ABORT class \u2018str\u2019 default: \u201cQMessageBox.Abort\u201d \u00b6 QtIfwPackageScript . ACCEPT_EULA_CMD_ARG class \u2018str\u2019 default: \u201caccept\u201d \u00b6 QtIfwPackageScript . AND class \u2018str\u2019 default: \u201d && \u201c \u00b6 QtIfwPackageScript . ASSIGN class \u2018str\u2019 default: \u201d=\u201d \u00b6 QtIfwPackageScript . AUTH_ERROR_MSGBOX_ID class \u2018str\u2019 default: \u201cAuthorizationError\u201d \u00b6 QtIfwPackageScript . AUTO_PILOT_CMD_ARG class \u2018str\u2019 default: \u201cauto\u201d \u00b6 QtIfwPackageScript . CANCEL class \u2018str\u2019 default: \u201cQMessageBox.Cancel\u201d \u00b6 QtIfwPackageScript . CATCH class \u2018str\u2019 default: \u201ccatch(e) { \u201c \u00b6 QtIfwPackageScript . CONCAT class \u2018str\u2019 default: \u201d + \u201c \u00b6 QtIfwPackageScript . DEFAULT_TARGET_DIR_KEY class \u2018str\u2019 default: \u201cDefaultTargetDir\u201d \u00b6 QtIfwPackageScript . DRYRUN_CMD_ARG class \u2018str\u2019 default: \u201cdryrun\u201d \u00b6 QtIfwPackageScript . ELSE class \u2018str\u2019 default: \u201celse \u201c \u00b6 QtIfwPackageScript . END_BLOCK class \u2018str\u2019 default: *\u201d} \u00b6 \u201d* { #END_BLOCK data-toc-label=END_BLOCK } QtIfwPackageScript . END_LINE class \u2018str\u2019 default: *\u201d; \u00b6 \u201d* { #END_LINE data-toc-label=END_LINE } QtIfwPackageScript . EQUAL_TO class \u2018str\u2019 default: \u201d == \u201c \u00b6 QtIfwPackageScript . ERR_LOG_DEFAULT_PATH class \u2018str\u2019 default: \u201c%temp%\\installer.err\u201d \u00b6 QtIfwPackageScript . ERR_LOG_PATH_CMD_ARG class \u2018str\u2019 default: \u201cerrlog\u201d \u00b6 QtIfwPackageScript . EXCLUDE_LIST_CMD_ARG class \u2018str\u2019 default: \u201cexclude\u201d \u00b6 QtIfwPackageScript . EXIT_FUNCTION class \u2018str\u2019 default: *\u201d \u00b6 return; \u201c* { #EXIT_FUNCTION data-toc-label=EXIT_FUNCTION } QtIfwPackageScript . FALSE class \u2018str\u2019 default: \u201cfalse\u201d \u00b6 QtIfwPackageScript . IF class \u2018str\u2019 default: \u201cif \u201c \u00b6 QtIfwPackageScript . INCLUDE_LIST_CMD_ARG class \u2018str\u2019 default: \u201cinclude\u201d \u00b6 QtIfwPackageScript . INSTALL_LIST_CMD_ARG class \u2018str\u2019 default: \u201cinstall\u201d \u00b6 QtIfwPackageScript . INTERUPTED_KEY class \u2018str\u2019 default: \u201cisInterupted\u201d \u00b6 QtIfwPackageScript . IS_NET_CONNECTED_KEY class \u2018str\u2019 default: \u201cisNetConnected\u201d \u00b6 QtIfwPackageScript . MAINTAIN_MODE_CMD_ARG class \u2018str\u2019 default: \u201cmode\u201d \u00b6 QtIfwPackageScript . MAINTAIN_MODE_OPT_ADD_REMOVE class \u2018str\u2019 default: \u201caddremove\u201d \u00b6 QtIfwPackageScript . MAINTAIN_MODE_OPT_REMOVE_ALL class \u2018str\u2019 default: \u201cremoveall\u201d \u00b6 QtIfwPackageScript . MAINTAIN_MODE_OPT_UPDATE class \u2018str\u2019 default: \u201cupdate\u201d \u00b6 QtIfwPackageScript . MAINTAIN_PASSTHRU_CMD_ARG class \u2018str\u2019 default: \u201cmaintpassthru\u201d \u00b6 QtIfwPackageScript . MAINTENANCE_TOOL_NAME class \u2018str\u2019 default: \u201cmaintenancetool.exe\u201d \u00b6 QtIfwPackageScript . NEW_LINE class \u2018str\u2019 default: *\u201d \u00b6 \u201d* { #NEW_LINE data-toc-label=NEW_LINE } QtIfwPackageScript . NO class \u2018str\u2019 default: \u201cQMessageBox.No\u201d \u00b6 QtIfwPackageScript . NOT class \u2018str\u2019 default: \u201d! \u201c \u00b6 QtIfwPackageScript . NOT_EQUAL_TO class \u2018str\u2019 default: \u201d != \u201c \u00b6 QtIfwPackageScript . NULL class \u2018str\u2019 default: \u201cnull\u201d \u00b6 QtIfwPackageScript . OK class \u2018str\u2019 default: \u201cQMessageBox.Yes\u201d \u00b6 QtIfwPackageScript . OR class \u2018str\u2019 default: \u201d || \u201c \u00b6 QtIfwPackageScript . OUT_LOG_DEFAULT_PATH class \u2018str\u2019 default: \u201c%temp%\\installer.out\u201d \u00b6 QtIfwPackageScript . OUT_LOG_PATH_CMD_ARG class \u2018str\u2019 default: \u201coutlog\u201d \u00b6 QtIfwPackageScript . PATH_SEP class \u2018str\u2019 default: \u201d\u201c\\\u201c\u201d \u00b6 QtIfwPackageScript . PRODUCT_NAME_KEY class \u2018str\u2019 default: \u201cProductName\u201d \u00b6 QtIfwPackageScript . QUIT_MSGBOX_ID class \u2018str\u2019 default: \u201ccancelInstallation\u201d \u00b6 QtIfwPackageScript . REBOOT_CMD_ARG class \u2018str\u2019 default: \u201creboot\u201d \u00b6 QtIfwPackageScript . RESTORE_MSGBOX_DEFAULT class \u2018str\u2019 default: \u201cQMessageBox.RestoreDefaults\u201d \u00b6 QtIfwPackageScript . RUN_PROGRAM_CMD_ARG class \u2018str\u2019 default: \u201crun\u201d \u00b6 QtIfwPackageScript . STARTMENU_DIR_KEY class \u2018str\u2019 default: \u201cStartMenuDir\u201d \u00b6 QtIfwPackageScript . START_BLOCK class \u2018str\u2019 default: *\u201d{ \u00b6 \u201d* { #START_BLOCK data-toc-label=START_BLOCK } QtIfwPackageScript . START_MENU_DIR_CMD_ARG class \u2018str\u2019 default: \u201cstartmenu\u201d \u00b6 QtIfwPackageScript . TAB class \u2018str\u2019 default: \u201d \u201c \u00b6 QtIfwPackageScript . TARGET_DIR_CMD_ARG class \u2018str\u2019 default: \u201ctarget\u201d \u00b6 QtIfwPackageScript . TARGET_DIR_KEY class \u2018str\u2019 default: \u201cTargetDir\u201d \u00b6 QtIfwPackageScript . TARGET_EXISTS_OPT_CMD_ARG class \u2018str\u2019 default: \u201conexist\u201d \u00b6 QtIfwPackageScript . TARGET_EXISTS_OPT_FAIL class \u2018str\u2019 default: \u201cfail\u201d \u00b6 QtIfwPackageScript . TARGET_EXISTS_OPT_PROMPT class \u2018str\u2019 default: \u201cprompt\u201d \u00b6 QtIfwPackageScript . TARGET_EXISTS_OPT_REMOVE class \u2018str\u2019 default: \u201cremove\u201d \u00b6 QtIfwPackageScript . TRUE class \u2018str\u2019 default: \u201ctrue\u201d \u00b6 QtIfwPackageScript . TRY class \u2018str\u2019 default: \u201ctry { \u201c \u00b6 QtIfwPackageScript . USER_KEY class \u2018str\u2019 default: \u201cUser\u201d \u00b6 QtIfwPackageScript . VERBOSE_CMD_SWITCH_ARG class \u2018str\u2019 default: \u201c-v\u201d \u00b6 QtIfwPackageScript . YES class \u2018str\u2019 default: \u201cQMessageBox.Yes\u201d \u00b6 QtIfwPackageXml class \u00b6 Base Classes: _QtIfwXml Magic Methods: __init__ Instance Methods: addCustomTags debug dirPath exists path toPrettyXml write Instance Attributes: pkgName SortingPriority DisplayName Description Version Script ReleaseDate Virtual Default ForcedInstallation Checkable Dependencies AutoDependOn UserInterfaces Licenses QtIfwPackageXml ( pkgName , displayName , description , version , scriptName = None , isDefault = True , isRequired = False , isHidden = False , isCheckable = True ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . addCustomTags ( self , root ) \u00b6 VIRTUAL obj . debug ( self ) \u00b6 obj . dirPath ( self ) \u00b6 PURE VIRTUAL obj . exists ( self ) \u00b6 obj . path ( self ) \u00b6 PURE VIRTUAL obj . toPrettyXml ( self ) \u00b6 obj . write ( self ) \u00b6 obj . pkgName class \u2018NoneType\u2019 default: None \u00b6 obj . SortingPriority class \u2018NoneType\u2019 default: None \u00b6 obj . DisplayName class \u2018NoneType\u2019 default: None \u00b6 obj . Description class \u2018NoneType\u2019 default: None \u00b6 obj . Version class \u2018NoneType\u2019 default: None \u00b6 obj . Script class \u2018NoneType\u2019 default: None \u00b6 obj . ReleaseDate class \u2018datetime.date\u2019 default: 2023-03-10 \u00b6 obj . Virtual class \u2018NoneType\u2019 default: None \u00b6 obj . Default class \u2018NoneType\u2019 default: None \u00b6 obj . ForcedInstallation class \u2018NoneType\u2019 default: None \u00b6 obj . Checkable class \u2018bool\u2019 default: False \u00b6 obj . Dependencies class \u2018NoneType\u2019 default: None \u00b6 obj . AutoDependOn class \u2018NoneType\u2019 default: None \u00b6 obj . UserInterfaces class \u2018list\u2019 default: [] \u00b6 obj . Licenses class \u2018dict\u2019 default: {} \u00b6 QtIfwShortcut class \u00b6 Magic Methods: __init__ Instance Methods: Instance Attributes: productName command args exeDir exeName isGui windowStyle isUserStartUpShortcut isAllUsersStartUpShortcut exeVersion pngIconResPath isAppShortcut isDesktopShortcut isAdjancentShortcut QtIfwShortcut ( productName = '@ProductName@' , command = None , args = None , exeDir = '@TargetDir@' , exeName = None , exeVersion = '0.0.0.0' , isGui = True , pngIconResPath = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . productName class \u2018NoneType\u2019 default: None \u00b6 obj . command class \u2018NoneType\u2019 default: None \u00b6 obj . args class \u2018list\u2019 default: [] \u00b6 obj . exeDir class \u2018NoneType\u2019 default: None \u00b6 obj . exeName class \u2018NoneType\u2019 default: None \u00b6 obj . isGui class \u2018NoneType\u2019 default: None \u00b6 obj . windowStyle class \u2018NoneType\u2019 default: None \u00b6 obj . isUserStartUpShortcut class \u2018bool\u2019 default: False \u00b6 obj . isAllUsersStartUpShortcut class \u2018bool\u2019 default: False \u00b6 obj . exeVersion class \u2018NoneType\u2019 default: None \u00b6 obj . pngIconResPath class \u2018NoneType\u2019 default: None \u00b6 obj . isAppShortcut class \u2018bool\u2019 default: True \u00b6 obj . isDesktopShortcut class \u2018bool\u2019 default: False \u00b6 obj . isAdjancentShortcut class \u2018bool\u2019 default: False \u00b6 QtIfwSimpleTextPage class \u00b6 Base Classes: _QtIfwInterface, QtIfwUiPage Magic Methods: __init__ Instance Methods: fileName resolve write Class/Static Attributes: BASE_ON_ENTER_TMPT BASE_ON_LOAD_TMPT QtIfwSimpleTextPage ( name , pageOrder = None , title = '' , text = '' , onLoad = None , onEnter = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . fileName ( self ) \u00b6 obj . resolve ( self , qtIfwConfig ) \u00b6 obj . write ( self , dirPath ) \u00b6 QtIfwSimpleTextPage . BASE_ON_ENTER_TMPT class \u2018str\u2019 default: *\u201d \u00b6 var page = gui.pageWidgetByObjectName(\u201cDynamic%s\u201d); if( installer.value( \u201cauto\u201d, \u201c\u201d )==\u201dtrue\u201d ) gui.clickButton(buttons.NextButton); else { %s } \u201c* { #BASE_ON_ENTER_TMPT data-toc-label=BASE_ON_ENTER_TMPT } QtIfwSimpleTextPage . BASE_ON_LOAD_TMPT class \u2018str\u2019 default: *\u201d \u00b6 var page = gui.pageWidgetByObjectName( \u201cDynamic%s\u201d ); var wizardStyle = installer.value( \u201c__wizardStyle\u201d, \u201cAero\u201d ); switch( wizardStyle ){ case \u201cMac\u201d: page.minimumSize.width=300; break; case \u201cClassic\u201d: page.minimumSize.width=475; break; case \u201cModern\u201d: page.minimumSize.width=480; break; default: // \u201cAero\u201d - This is the hard coded width of QtIfw example .ui\u2019s page.minimumSize.width=491; } \u201c* { #BASE_ON_LOAD_TMPT data-toc-label=BASE_ON_LOAD_TMPT } QtIfwTargetDirPage class \u00b6 Base Classes: _QtIfwInterface, QtIfwUiPage Magic Methods: __init__ Instance Methods: fileName resolve write Class/Static Attributes: BASE_ON_ENTER_TMPT BASE_ON_LOAD_TMPT NAME QtIfwTargetDirPage () \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . fileName ( self ) \u00b6 obj . resolve ( self , qtIfwConfig ) \u00b6 obj . write ( self , dirPath ) \u00b6 QtIfwTargetDirPage . BASE_ON_ENTER_TMPT class \u2018str\u2019 default: *\u201d \u00b6 var page = gui.pageWidgetByObjectName(\u201cDynamic%s\u201d); if( installer.value( \u201cauto\u201d, \u201c\u201d )==\u201dtrue\u201d ) gui.clickButton(buttons.NextButton); else { %s } \u201c* { #BASE_ON_ENTER_TMPT data-toc-label=BASE_ON_ENTER_TMPT } QtIfwTargetDirPage . BASE_ON_LOAD_TMPT class \u2018str\u2019 default: *\u201d \u00b6 var page = gui.pageWidgetByObjectName( \u201cDynamic%s\u201d ); var wizardStyle = installer.value( \u201c__wizardStyle\u201d, \u201cAero\u201d ); switch( wizardStyle ){ case \u201cMac\u201d: page.minimumSize.width=300; break; case \u201cClassic\u201d: page.minimumSize.width=475; break; case \u201cModern\u201d: page.minimumSize.width=480; break; default: // \u201cAero\u201d - This is the hard coded width of QtIfw example .ui\u2019s page.minimumSize.width=491; } \u201c* { #BASE_ON_LOAD_TMPT data-toc-label=BASE_ON_LOAD_TMPT } QtIfwTargetDirPage . NAME class \u2018str\u2019 default: \u201cReplaceTargetDirectory\u201d \u00b6 QtIfwUiPage class \u00b6 Base Classes: _QtIfwInterface Magic Methods: __init__ Instance Methods: fileName resolve write Instance Attributes: pageOrder isIncInAutoPilot Class/Static Attributes: BASE_ON_ENTER_TMPT BASE_ON_LOAD_TMPT QtIfwUiPage ( name , pageOrder = None , sourcePath = None , content = None , onLoad = None , onEnter = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . fileName ( self ) \u00b6 obj . resolve ( self , qtIfwConfig ) \u00b6 obj . write ( self , dirPath ) \u00b6 obj . pageOrder class \u2018NoneType\u2019 default: None \u00b6 obj . isIncInAutoPilot class \u2018bool\u2019 default: False \u00b6 QtIfwUiPage . BASE_ON_ENTER_TMPT class \u2018str\u2019 default: *\u201d \u00b6 var page = gui.pageWidgetByObjectName(\u201cDynamic%s\u201d); if( installer.value( \u201cauto\u201d, \u201c\u201d )==\u201dtrue\u201d ) gui.clickButton(buttons.NextButton); else { %s } \u201c* { #BASE_ON_ENTER_TMPT data-toc-label=BASE_ON_ENTER_TMPT } QtIfwUiPage . BASE_ON_LOAD_TMPT class \u2018str\u2019 default: *\u201d \u00b6 var page = gui.pageWidgetByObjectName( \u201cDynamic%s\u201d ); var wizardStyle = installer.value( \u201c__wizardStyle\u201d, \u201cAero\u201d ); switch( wizardStyle ){ case \u201cMac\u201d: page.minimumSize.width=300; break; case \u201cClassic\u201d: page.minimumSize.width=475; break; case \u201cModern\u201d: page.minimumSize.width=480; break; default: // \u201cAero\u201d - This is the hard coded width of QtIfw example .ui\u2019s page.minimumSize.width=491; } \u201c* { #BASE_ON_LOAD_TMPT data-toc-label=BASE_ON_LOAD_TMPT } QtIfwWidget class \u00b6 Base Classes: _QtIfwInterface Magic Methods: __init__ Instance Methods: fileName resolve write Instance Attributes: pageName position QtIfwWidget ( name , pageName , position = None , sourcePath = None , content = None , onLoad = None , onEnter = None ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . fileName ( self ) \u00b6 obj . resolve ( self , qtIfwConfig ) \u00b6 obj . write ( self , dirPath ) \u00b6 obj . pageName class \u2018NoneType\u2019 default: None \u00b6 obj . position class \u2018NoneType\u2019 default: None \u00b6 RobustInstallerProcess class \u00b6 Base Classes: _DistBuildProcessBase, _BuildInstallerProcess Magic Methods: __init__ Instance Methods: onConfigFactory onFinalize onIExpressConfig onIExpressPackageFinalize onIExpressPackageInitialize onIExpressPackageProcess onIExpressPackagesBuilt onInitialize onMakeSpec onOpyConfig onPackagesStaged onPyInstConfig onPyPackageFinalize onPyPackageInitialize onPyPackageProcess onPyPackagesBuilt onQtIfwConfig run Class/Static Attributes: DIVIDER RobustInstallerProcess ( masterConfigFactory , name = 'Robust Installer Process' , pyPkgConfigFactoryDict = None , iExpressPkgConfigFactoryDict = None , ifwPackages = None , isDesktopTarget = False , isHomeDirTarget = False ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . onConfigFactory ( self , key , factory ) \u00b6 VIRTUAL obj . onFinalize ( self ) \u00b6 VIRTUAL obj . onIExpressConfig ( self , key , cfg ) \u00b6 VIRTUAL obj . onIExpressPackageFinalize ( self , key ) \u00b6 VIRTUAL obj . onIExpressPackageInitialize ( self , key ) \u00b6 VIRTUAL obj . onIExpressPackageProcess ( self , key , prc ) \u00b6 VIRTUAL obj . onIExpressPackagesBuilt ( self , pkgs ) \u00b6 VIRTUAL obj . onInitialize ( self ) \u00b6 VIRTUAL obj . onMakeSpec ( self , key , spec ) \u00b6 VIRTUAL obj . onOpyConfig ( self , key , cfg ) \u00b6 VIRTUAL obj . onPackagesStaged ( self , cfg , pkgs ) \u00b6 VIRTUAL obj . onPyInstConfig ( self , key , cfg ) \u00b6 VIRTUAL obj . onPyPackageFinalize ( self , key ) \u00b6 VIRTUAL obj . onPyPackageInitialize ( self , key ) \u00b6 VIRTUAL obj . onPyPackageProcess ( self , key , prc ) \u00b6 VIRTUAL obj . onPyPackagesBuilt ( self , pkgs ) \u00b6 VIRTUAL obj . onQtIfwConfig ( self , cfg ) \u00b6 VIRTUAL obj . run ( self ) \u00b6 RobustInstallerProcess . DIVIDER class \u2018str\u2019 default: \u201d------------------------------------\u201c \u00b6 Functions \u00b6 buildInstaller ( qtIfwConfig , isSilent ) \u00b6 returns setupExePath findQtIfwPackage ( pkgs , pkgId ) \u00b6 installQtIfw ( installerPath = None , version = None , targetPath = None ) \u00b6 joinPathQtIfw ( head , * tail ) \u00b6 mergeQtIfwPackages ( pkgs , srcId , destId ) \u00b6 nestQtIfwPackage ( pkgs , childId , parentId , subDirName = None ) \u00b6 qtIfwDetachedOpDataPath ( rootFileName ) \u00b6 qtIfwDynamicValue ( name ) \u00b6 qtIfwOpDataPath ( rootFileName ) \u00b6 removeQtIfwPackage ( pkgs , pkgId ) \u00b6 unInstallQtIfw ( qtIfwDirPath = None , version = None ) \u00b6 Constants and Globals \u00b6 QT_IFW_ALLUSERS_STARTMENU_DIR class \u2018str\u2019 default: \u201c@AllUsersStartMenuProgramsPath@\u201d \u00b6 QT_IFW_APPS_DIR class \u2018str\u2019 default: \u201c@ApplicationsDir@\u201d \u00b6 QT_IFW_APPS_X64_DIR class \u2018str\u2019 default: \u201c@ApplicationsDirX64@\u201d \u00b6 QT_IFW_APPS_X86_DIR class \u2018str\u2019 default: \u201c@ApplicationsDirX86@\u201d \u00b6 QT_IFW_COMPONENTS_PAGE class \u2018str\u2019 default: \u201cComponentSelection\u201d \u00b6 QT_IFW_DEFAULT_TARGET_DIR class \u2018str\u2019 default: \u201c@DefaultTargetDir@\u201d \u00b6 QT_IFW_DESKTOP_DIR class \u2018str\u2019 default: \u201c@DesktopDir@\u201d \u00b6 QT_IFW_DYNAMIC_VARS class \u2018list\u2019 default: [\u2018TargetDir\u2019, \u2018DefaultTargetDir\u2019, \u2018RootDir\u2019, \u2018HomeDir\u2019, \u2018DesktopDir\u2019, \u2018ApplicationsDir\u2019, \u2018StartMenuDir\u2019, \u2018UserStartMenuProgramsPath\u2019, \u2018AllUsersStartMenuProgramsPath\u2019, \u2018ApplicationsDirX86\u2019, \u2018ApplicationsDirX64\u2019, \u2018TempDir\u2019, \u2018InstallerTempDir\u2019, \u2018MaintenanceTempDir\u2019, \u2018ScriptsDir\u2019, \u2018InstallerDirPath\u2019, \u2018InstallerFilePath\u2019, \u2018User\u2019, \u2018ProductName\u2019, \u2018ProductVersion\u2019, \u2018Title\u2019, \u2018Publisher\u2019, \u2018Url\u2019, \u2018os\u2019] \u00b6 QT_IFW_FINISHED_PAGE class \u2018str\u2019 default: \u201cInstallationFinished\u201d \u00b6 QT_IFW_HOME_DIR class \u2018str\u2019 default: \u201c@HomeDir@\u201d \u00b6 QT_IFW_INSTALLER_DIR class \u2018str\u2019 default: \u201c@InstallerDirPath@\u201d \u00b6 QT_IFW_INSTALLER_TEMP_DIR class \u2018str\u2019 default: \u201c@InstallerTempDir@\u201d \u00b6 QT_IFW_INSTALL_PAGE class \u2018str\u2019 default: \u201cPerformInstallation\u201d \u00b6 QT_IFW_INTALLER_PATH class \u2018str\u2019 default: \u201c@InstallerFilePath@\u201d \u00b6 QT_IFW_INTRO_PAGE class \u2018str\u2019 default: \u201cIntroduction\u201d \u00b6 QT_IFW_LICENSE_PAGE class \u2018str\u2019 default: \u201cLicenseCheck\u201d \u00b6 QT_IFW_MAINTENANCE_TEMP_DIR class \u2018str\u2019 default: \u201c@MaintenanceTempDir@\u201d \u00b6 QT_IFW_OS class \u2018str\u2019 default: \u201c@os@\u201d \u00b6 QT_IFW_POST_INSTALL class \u2018int\u2019 default: 1 \u00b6 QT_IFW_PRE_INSTALL class \u2018int\u2019 default: 0 \u00b6 QT_IFW_PRODUCT_NAME class \u2018str\u2019 default: \u201c@ProductName@\u201d \u00b6 QT_IFW_PRODUCT_VERSION class \u2018str\u2019 default: \u201c@ProductVersion@\u201d \u00b6 QT_IFW_PUBLISHER class \u2018str\u2019 default: \u201c@Publisher@\u201d \u00b6 QT_IFW_READY_PAGE class \u2018str\u2019 default: \u201cReadyForInstallation\u201d \u00b6 QT_IFW_REPLACE_PAGE_PREFIX class \u2018str\u2019 default: \u201cReplace\u201d \u00b6 QT_IFW_ROOT_DIR class \u2018str\u2019 default: \u201c@RootDir@\u201d \u00b6 QT_IFW_SCRIPTS_DIR class \u2018str\u2019 default: \u201c@ScriptsDir@\u201d \u00b6 QT_IFW_STARTMENU_DIR class \u2018str\u2019 default: \u201c@StartMenuDir@\u201d \u00b6 QT_IFW_START_MENU_PAGE class \u2018str\u2019 default: \u201cStartMenuSelection\u201d \u00b6 QT_IFW_TARGET_DIR class \u2018str\u2019 default: \u201c@TargetDir@\u201d \u00b6 QT_IFW_TARGET_DIR_PAGE class \u2018str\u2019 default: \u201cTargetDirectory\u201d \u00b6 QT_IFW_TEMP_DIR class \u2018str\u2019 default: \u201c@TempDir@\u201d \u00b6 QT_IFW_TITLE class \u2018str\u2019 default: \u201c@Title@\u201d \u00b6 QT_IFW_URL class \u2018str\u2019 default: \u201c@Url@\u201d \u00b6 QT_IFW_USER class \u2018str\u2019 default: \u201c@User@\u201d \u00b6 QT_IFW_USER_STARTMENU_DIR class \u2018str\u2019 default: \u201c@UserStartMenuProgramsPath@\u201d \u00b6 QT_IFW_VERBOSE_SWITCH class \u2018str\u2019 default: \u201c-v\u201d \u00b6","title":"Qt Installer Framework"},{"location":"Qt%20Installer%20Framework.html#QtIfwConfig","text":"Magic Methods: __init__ Instance Methods: addLicense addUiElements Instance Attributes: installerDefDirPath packages configXml controlScript setupExeName qtIfwDirPath isDebugMode otherQtIfwArgs","title":"QtIfwConfig"},{"location":"Qt%20Installer%20Framework.html#QtIfwConfigXml","text":"Base Classes: _QtIfwXml Magic Methods: __init__ Instance Methods: addCustomTags debug dirPath exists path setDefaultPaths setDefaultTitle setDefaultVersion setPrimaryContentExe toPrettyXml write Instance Attributes: primaryContentExe primaryExeWrapper runProgramArgList companyTradeName iconFilePath logoFilePath bannerFilePath Name Version Publisher Title TitleColor ControlScript TargetDir StartMenuDir RunProgram RunProgramDescription WizardStyle WizardDefaultWidth WizardDefaultHeight Logo Banner ProductUrl Class/Static Attributes: DEFAULT_WIZARD_STYLE WizardStyle","title":"QtIfwConfigXml"},{"location":"Qt%20Installer%20Framework.html#QtIfwConfigXml.WizardStyle","text":"Class/Static Attributes: AERO CLASSIC MAC MODERN","title":"QtIfwConfigXml.WizardStyle"},{"location":"Qt%20Installer%20Framework.html#QtIfwControlScript","text":"Base Classes: _QtIfwScript Magic Methods: __init__ Instance Methods: debug dirPath exists path registerAutoPilotEventHandler registerGuiEventHandler registerStandardEventHandler registerWidgetEventHandler write Instance Attributes: isLimitedMaintenance virtualArgs uiPages widgets controllerGlobals isAutoGlobals controllerConstructorBody controllerConstructorInjection isAutoControllerConstructor onValueChangeCallbackBody onValueChangeCallbackInjection isAutoValueChangeCallBack onPageChangeCallbackBody onPageChangeCallbackInjection isAutoPageChangeCallBack onPageInsertRequestCallbackBody isAutoPageInsertRequestCallBack onPageRemoveRequestCallbackBody isAutoPageRemoveRequestCallBack onPageVisibilityRequestCallbackBody isAutoPageVisibilityRequestCallBack onFinishedClickedCallbackBody onFinishedClickedCallbackInjection onFinishedDetachedExecutions isAutoFinishedClickedCallbackBody isIntroductionPageVisible introductionPageCallbackBody introductionPageOnInstall introductionPageOnMaintain isAutoIntroductionPageCallback isTargetDirectoryPageVisible targetDirectoryPageCallbackBody isAutoTargetDirectoryPageCallback isComponentSelectionPageVisible componentSelectionPageCallbackBody componentSelectionPageInjection isAutoComponentSelectionPageCallback isLicenseAgreementPageVisible licenseAgreementPageCallbackBody isAutoLicenseAgreementPageCallback isStartMenuDirectoryPageVisible startMenuDirectoryPageCallbackBody isAutoStartMenuDirectoryPageCallback isReadyForInstallationPageVisible readyForInstallationPageCallbackBody readyForInstallationPageOnInstall readyForInstallationPageOnMaintain isAutoReadyForInstallationPageCallback isPerformInstallationPageVisible performInstallationPageCallbackBody isAutoPerformInstallationPageCallback isFinishedPageVisible finishedPageCallbackBody finishedPageOnInstall finishedPageOnMaintain isAutoFinishedPageCallback isRunProgVisible isRunProgEnabled isRunProgChecked Class/Static Methods: andList assertInternetConnected assignCurrentPageWidgetVar assignCustomPageWidgetVar assignPageWidgetVar assignRegistryEntryVar boolToString clickButton cmdLineArg cmdLineListArg cmdLineSwitchArg connectButtonClickHandler connectWidgetEventHandler currentPageWidget customPageWidget debugPopup deleteDetachedOpDataFile deleteFile deleteOpDataFile disableQuit disableQuitPrompt dropElevation elevate embedResources enable enableComponent enableCustom enableNextButton errorPopup genResources getComponent getCustomText getEnv getPageOwner getText hideDefaultPage ifAutoPilot ifBoolValue ifChecked ifCmdLineArg ifCmdLineSwitch ifComponentEnabled ifComponentInstalled ifComponentSelected ifCondition ifCustomChecked ifCustomEnabled ifCustomVisible ifDryRun ifElevated ifEnabled ifInstalling ifInternetConnected ifMaintenanceTool ifPathExists ifPingable ifRegistryEntryExists ifRegistryEntryExistsLike ifRegistryKeyExists ifRegistryKeyExistsLike ifValueDefined ifVisible ifYesNoPopup insertCustomPage insertCustomWidget isAutoPilot isChecked isComponentEnabled isComponentInstalled isComponentSelected isCustomChecked isCustomEnabled isCustomVisible isDryRun isElevated isEnabled isInstalling isInternetConnected isMaintenanceTool isPingable isVisible killAll log logSwitch logValue lookupBoolValue lookupValue lookupValueList makeDir openViaOs orList pageWidget pathExists productName quit quote registryEntryExists registryEntryExistsLike registryEntryValue registryKeyExists registryKeyExistsLike removeCustomPage removeCustomWidget removeDir resolveDynamTxtVarsOperations resolveDynamicVars resolveScriptVars resolveScriptVarsOperations selectAllComponents selectComponent selectDefaultComponents setBoolValue setChecked setCustomCheckBox setCustomPageText setCustomPageTitle setCustomText setCustomVisible setText setValue setValueFromRegistryEntry setVisible startMenuDir stringToBool switchYesNoCancelPopup targetDir toBool toDefaultPageId toNull warningPopup writeDetachedOpDataFile writeFile writeOpDataFile yesNoCancelPopup yesNoPopup Class/Static Attributes: ABORT ACCEPT_EULA_CMD_ARG ACCEPT_EULA_RADIO_BUTTON AND ASSIGN AUTH_ERROR_MSGBOX_ID AUTO_PILOT_CMD_ARG BACK_BUTTON CANCEL CANCEL_BUTTON CATCH COMMIT_BUTTON CONCAT CUSTOM_BUTTON_1 CUSTOM_BUTTON_2 CUSTOM_BUTTON_3 DEFAULT_FINISHED_MESSAGE DEFAULT_TARGET_DIR_KEY DRYRUN_CMD_ARG ELSE END_BLOCK END_LINE EQUAL_TO ERR_LOG_DEFAULT_PATH ERR_LOG_PATH_CMD_ARG EXCLUDE_LIST_CMD_ARG EXIT_FUNCTION FALSE FINISHED_MESSAGE_LABEL FINISH_BUTTON HELP_BUTTON IF INCLUDE_LIST_CMD_ARG INSTALL_LIST_CMD_ARG INTERUPTED_KEY IS_NET_CONNECTED_KEY MAINTAIN_MODE_CMD_ARG MAINTAIN_MODE_OPT_ADD_REMOVE MAINTAIN_MODE_OPT_REMOVE_ALL MAINTAIN_MODE_OPT_UPDATE MAINTAIN_PASSTHRU_CMD_ARG MAINTENANCE_TOOL_NAME NEW_LINE NEXT_BUTTON NO NOT NOT_EQUAL_TO NULL OK OR OUT_LOG_DEFAULT_PATH OUT_LOG_PATH_CMD_ARG PATH_SEP PRODUCT_NAME_KEY QUIT_MSGBOX_ID REBOOT_CMD_ARG RESTORE_MSGBOX_DEFAULT RUN_PROGRAM_CHECKBOX RUN_PROGRAM_CMD_ARG STARTMENU_DIR_KEY START_BLOCK START_MENU_DIR_CMD_ARG START_MENU_DIR_EDITBOX TAB TARGET_DIR_CMD_ARG TARGET_DIR_EDITBOX TARGET_DIR_KEY TARGET_EXISTS_OPT_CMD_ARG TARGET_EXISTS_OPT_FAIL TARGET_EXISTS_OPT_PROMPT TARGET_EXISTS_OPT_REMOVE TRUE TRY USER_KEY VERBOSE_CMD_SWITCH_ARG YES","title":"QtIfwControlScript"},{"location":"Qt%20Installer%20Framework.html#QtIfwDynamicOperationsPage","text":"Base Classes: _QtIfwInterface, QtIfwUiPage Magic Methods: __init__ Instance Methods: fileName resolve write Instance Attributes: supportScript name args body delayMillis standardPageId customPageName Class/Static Methods: onCompleted Class/Static Attributes: AsyncFunc BASE_ON_ENTER_TMPT BASE_ON_LOAD_TMPT","title":"QtIfwDynamicOperationsPage"},{"location":"Qt%20Installer%20Framework.html#QtIfwDynamicOperationsPage.AsyncFunc","text":"Instance Methods: invoke","title":"QtIfwDynamicOperationsPage.AsyncFunc"},{"location":"Qt%20Installer%20Framework.html#QtIfwExeWrapper","text":"Magic Methods: __init__ Instance Methods: refresh Instance Attributes: exeName isGui wrapperScript exeDir workingDir args envVars isElevated isExe wrapperExeName wrapperIconName","title":"QtIfwExeWrapper"},{"location":"Qt%20Installer%20Framework.html#QtIfwExternalOp","text":"Magic Methods: __init__ Instance Methods: Instance Attributes: script exePath args successRetCodes uninstScript uninstExePath uninstArgs uninstRetCodes isElevated workingDir onErrorMessage resourceScripts uninstResourceScripts externalRes Class/Static Methods: CopyExeVerInfoScript CopyExternalResource CopyFile CopyFileScript CreateExeFromScript CreateOpFlagFile CreateOpFlagFileScript CreateRegistryEntry CreateRegistryEntryScript CreateRegistryKey CreateRegistryKeyScript CreateStartupEntry CreateWindowsAppFoundFlagFile CreateWindowsAppFoundFlagFileScript EmbedExeVerInfoScript ExtractIconsFromExeScript MakeDir MakeDirScript RemoveDir RemoveDirScript RemoveFile RemoveFileScript RemoveRegistryEntry RemoveRegistryEntryScript RemoveRegistryKey RemoveRegistryKeyScript ReplacePrimaryIconInExeScript RunProgram RunProgramScript Script2Exe Script2ExeScript UninstallWindowsApp UninstallWindowsAppScript WaitForProcess WaitForProcessScript WrapperScript2Exe WriteFile WriteFileScript WriteOpDataFile WriteOpDataFileScript appleScriptSelfDestructSnippet batchSelfDestructSnippet opDataPath powerShellSelfDestructSnippet shellScriptSelfDestructSnippet vbScriptSelfDestructSnippet Class/Static Attributes: AUTO_UNDO ON_BOTH ON_INSTALL ON_UNINSTALL","title":"QtIfwExternalOp"},{"location":"Qt%20Installer%20Framework.html#QtIfwExternalResource","text":"Magic Methods: __init__ Instance Methods: targetDirPath targetDirPathVar targetPath targetPathVar Instance Attributes: name srcPath destPath isMaintenanceNeed contentKeys Class/Static Methods: BuiltIn Class/Static Attributes: RESOURCE_HACKER","title":"QtIfwExternalResource"},{"location":"Qt%20Installer%20Framework.html#QtIfwKillOp","text":"Magic Methods: __init__ Instance Methods: Instance Attributes: processName onInstall onUninstall isElevated","title":"QtIfwKillOp"},{"location":"Qt%20Installer%20Framework.html#QtIfwOnFinishedCheckbox","text":"Base Classes: QtIfwOnFinishedDetachedExec, _QtIfwInterface, QtIfwWidget Magic Methods: __init__ Instance Methods: enable fileName isChecked resolve setChecked setVisible write Instance Attributes: checkboxName text Class/Static Attributes: BASE_ON_LOAD_TMPT ON_BOTH ON_INSTALL ON_UNINSTALL","title":"QtIfwOnFinishedCheckbox"},{"location":"Qt%20Installer%20Framework.html#QtIfwOnFinishedDetachedExec","text":"Magic Methods: __init__ Instance Methods: Instance Attributes: name event runProgram argList script isReboot ifCondition Class/Static Attributes: ON_BOTH ON_INSTALL ON_UNINSTALL","title":"QtIfwOnFinishedDetachedExec"},{"location":"Qt%20Installer%20Framework.html#QtIfwPackage","text":"Magic Methods: __init__ Instance Methods: contentDirPath contentTopDirPath dirPath metaDirPath Instance Attributes: pkgId pkgType name pkgXml pkgScript uiPages widgets licenses isLicenseFormatPreserved srcDirPath srcExePath resBasePath distResources isTempSrc subDirName exeName isGui exeWrapper codeSignTargets qtCppConfig Class/Static Methods: topDirPath Class/Static Attributes: Type","title":"QtIfwPackage"},{"location":"Qt%20Installer%20Framework.html#QtIfwPackage.Type","text":"Class/Static Attributes: DATA IEXPRESS PY_INSTALLER QT_CPP RAW RESOURCE","title":"QtIfwPackage.Type"},{"location":"Qt%20Installer%20Framework.html#QtIfwPackageScript","text":"Base Classes: _QtIfwScript Magic Methods: __init__ Instance Methods: addSimpleOperation debug dirPath exists path write Instance Attributes: pkgName pkgVersion pkgSubDirName shortcuts externalOps killOps preOpSupport customOperations bundledScripts dynamicTexts installResources externalDependencies areDependenciesPreserved uiPages widgets packageGlobals isAutoGlobals componentConstructorBody isAutoComponentConstructor componentLoadedCallbackBody isAutoComponentLoadedCallback componentEnteredCallbackBody isAutoComponentEnteredCallback componentCreateOperationsBody isAutoComponentCreateOperations componentCreateOperationsForArchiveBody isAutoComponentCreateOperationsForArchive Class/Static Methods: andList assertInternetConnected assignRegistryEntryVar boolToString cmdLineArg cmdLineListArg cmdLineSwitchArg debugPopup deleteDetachedOpDataFile deleteFile deleteOpDataFile disableQuit disableQuitPrompt dropElevation elevate embedResources enableComponent errorPopup genResources getComponent getEnv getPageOwner ifAutoPilot ifBoolValue ifCmdLineArg ifCmdLineSwitch ifComponentEnabled ifComponentInstalled ifComponentSelected ifCondition ifDryRun ifElevated ifInstalling ifInternetConnected ifMaintenanceTool ifPathExists ifPingable ifRegistryEntryExists ifRegistryEntryExistsLike ifRegistryKeyExists ifRegistryKeyExistsLike ifValueDefined ifYesNoPopup isAutoPilot isComponentEnabled isComponentInstalled isComponentSelected isDryRun isElevated isInstalling isInternetConnected isMaintenanceTool isPingable killAll log logSwitch logValue lookupBoolValue lookupValue lookupValueList makeDir orList pathExists productName quit quote registryEntryExists registryEntryExistsLike registryEntryValue registryKeyExists registryKeyExistsLike removeDir resolveDynamTxtVarsOperations resolveDynamicVars resolveScriptVars resolveScriptVarsOperations setBoolValue setValue setValueFromRegistryEntry startMenuDir stringToBool switchYesNoCancelPopup targetDir toBool toNull warningPopup writeDetachedOpDataFile writeFile writeOpDataFile yesNoCancelPopup yesNoPopup Class/Static Attributes: ABORT ACCEPT_EULA_CMD_ARG AND ASSIGN AUTH_ERROR_MSGBOX_ID AUTO_PILOT_CMD_ARG CANCEL CATCH CONCAT DEFAULT_TARGET_DIR_KEY DRYRUN_CMD_ARG ELSE END_BLOCK END_LINE EQUAL_TO ERR_LOG_DEFAULT_PATH ERR_LOG_PATH_CMD_ARG EXCLUDE_LIST_CMD_ARG EXIT_FUNCTION FALSE IF INCLUDE_LIST_CMD_ARG INSTALL_LIST_CMD_ARG INTERUPTED_KEY IS_NET_CONNECTED_KEY MAINTAIN_MODE_CMD_ARG MAINTAIN_MODE_OPT_ADD_REMOVE MAINTAIN_MODE_OPT_REMOVE_ALL MAINTAIN_MODE_OPT_UPDATE MAINTAIN_PASSTHRU_CMD_ARG MAINTENANCE_TOOL_NAME NEW_LINE NO NOT NOT_EQUAL_TO NULL OK OR OUT_LOG_DEFAULT_PATH OUT_LOG_PATH_CMD_ARG PATH_SEP PRODUCT_NAME_KEY QUIT_MSGBOX_ID REBOOT_CMD_ARG RESTORE_MSGBOX_DEFAULT RUN_PROGRAM_CMD_ARG STARTMENU_DIR_KEY START_BLOCK START_MENU_DIR_CMD_ARG TAB TARGET_DIR_CMD_ARG TARGET_DIR_KEY TARGET_EXISTS_OPT_CMD_ARG TARGET_EXISTS_OPT_FAIL TARGET_EXISTS_OPT_PROMPT TARGET_EXISTS_OPT_REMOVE TRUE TRY USER_KEY VERBOSE_CMD_SWITCH_ARG YES","title":"QtIfwPackageScript"},{"location":"Qt%20Installer%20Framework.html#QtIfwPackageXml","text":"Base Classes: _QtIfwXml Magic Methods: __init__ Instance Methods: addCustomTags debug dirPath exists path toPrettyXml write Instance Attributes: pkgName SortingPriority DisplayName Description Version Script ReleaseDate Virtual Default ForcedInstallation Checkable Dependencies AutoDependOn UserInterfaces Licenses","title":"QtIfwPackageXml"},{"location":"Qt%20Installer%20Framework.html#QtIfwShortcut","text":"Magic Methods: __init__ Instance Methods: Instance Attributes: productName command args exeDir exeName isGui windowStyle isUserStartUpShortcut isAllUsersStartUpShortcut exeVersion pngIconResPath isAppShortcut isDesktopShortcut isAdjancentShortcut","title":"QtIfwShortcut"},{"location":"Qt%20Installer%20Framework.html#QtIfwSimpleTextPage","text":"Base Classes: _QtIfwInterface, QtIfwUiPage Magic Methods: __init__ Instance Methods: fileName resolve write Class/Static Attributes: BASE_ON_ENTER_TMPT BASE_ON_LOAD_TMPT","title":"QtIfwSimpleTextPage"},{"location":"Qt%20Installer%20Framework.html#QtIfwTargetDirPage","text":"Base Classes: _QtIfwInterface, QtIfwUiPage Magic Methods: __init__ Instance Methods: fileName resolve write Class/Static Attributes: BASE_ON_ENTER_TMPT BASE_ON_LOAD_TMPT NAME","title":"QtIfwTargetDirPage"},{"location":"Qt%20Installer%20Framework.html#QtIfwUiPage","text":"Base Classes: _QtIfwInterface Magic Methods: __init__ Instance Methods: fileName resolve write Instance Attributes: pageOrder isIncInAutoPilot Class/Static Attributes: BASE_ON_ENTER_TMPT BASE_ON_LOAD_TMPT","title":"QtIfwUiPage"},{"location":"Qt%20Installer%20Framework.html#QtIfwWidget","text":"Base Classes: _QtIfwInterface Magic Methods: __init__ Instance Methods: fileName resolve write Instance Attributes: pageName position","title":"QtIfwWidget"},{"location":"Qt%20Installer%20Framework.html#RobustInstallerProcess","text":"Base Classes: _DistBuildProcessBase, _BuildInstallerProcess Magic Methods: __init__ Instance Methods: onConfigFactory onFinalize onIExpressConfig onIExpressPackageFinalize onIExpressPackageInitialize onIExpressPackageProcess onIExpressPackagesBuilt onInitialize onMakeSpec onOpyConfig onPackagesStaged onPyInstConfig onPyPackageFinalize onPyPackageInitialize onPyPackageProcess onPyPackagesBuilt onQtIfwConfig run Class/Static Attributes: DIVIDER","title":"RobustInstallerProcess"},{"location":"Qt%20Installer%20Framework.html#Functions","text":"","title":"Functions"},{"location":"Qt%20Installer%20Framework.html#Constants-and-Globals","text":"","title":"Constants and Globals"},{"location":"QtCpp.html","text":"Qt C++ Integration \u00b6 Overview \u00b6 The developers of Distribution Builder work in many languages and frameworks extending beyond Python. Ultimately, we hope to provide a collection of rapid integration modules for this library for other modes of software development. The first of these integrations we are rolling out is a ready means to allow your Qt C++ programs to flow directly into this tool. The library can then be used as a middleman between Qt Creator and the Qt Installer Framework . This mechanism provides far more flexibility than simply bridging those tools, however. Other packages, notably Python based programs, can be built and bundled together simultaneously. This design pattern gives you the full power of Distribution Builder (and Python on the whole) by which to extend your Qt build process. If you have not done so yet, it is strongly recommended that you you get your feet wet with this library by at least reviewing Getting Started prior to diving into this extended feature set. Also, you will need to be versed in using Qt Creator and writing code with the Qt Library in order to make use of this, or follow the examples / documentation. Qt C++ Module \u00b6 A module has been provided in distbuilder which is specifically dedicated to Qt C++ integration, i.e. distbuilder.qt_cpp . The following functions / classes can be imported from that: qmakeInit() qmakeArgParser() qmakeArgs() installDeployTools( askPassPath=None ) renameExe( args ) qmakeMasterConfigFactory( args=None ) qmakePackageConfigFactory( args=None ) QtCppConfig( qtBinDirPath, exeCompiler, qmlScrDirPath=None ) <Linux Only> QtCppConfig.CQtDeployerConfig Under most circumstances, you will only need to call qmakeInit . If you wish to customize that process or receive additional specifications from an external source (e.g. QMake), you may use the other functions to emulate and custom define what the vanilla qmakeInit does for you. qmakeInit \u00b6 This function provides the standard way to set up an integration which allows QMake to drive the build process in distbuilder. The function receives parameters passed to the script externally (normally via a system call from QMake), and returns a tuple of ConfigFactory objects. The first factory in the tuple is intended for use as a \u201cmaster\u201d from which to build robust multi-package distributions. The other, is to build the C++ program package. Since you may wish to roll your own equivalent of this, here is the entire source for this function: def qmakeInit () : args = qmakeArgs () installDeployTools ( args . askPass ) if args . exeName : renameExe ( args ) return qmakeMasterConfigFactory ( args ) , qmakePackageConfigFactory ( args ) Note: to modify a \u201cproduct\u201d of the library, it is strongly advised that you modify the factory used to produce it, when possible, rather than creating an object with it first and then altering that. Changing the factory attributes can prevent the need to also regenerate nested components, which may not align as desired otherwise and could lead to subtle problems. While this practice is applicable to distbuilder in general, it is pointed out here because this standard Qt integration pattern directly involves the creation of factories for the client to implement, as opposed to Qt C++ \u201cconfiguration objects\u201d or \u201cprocess objects\u201d. qmakeArgParser, qmakeArgs \u00b6 If overwriting the standard qmakeInit function, you may call either of these functions directly, in order to subsequently call qmakeMasterConfigFactory and/or qmakePackageConfigFactory . qmakeArgs() directly collects the required parameters from the script arguments. In contrast, qmakeArgParser returns a raw ArgParse object, which may be customized to collect additional / alternate script arguments. installDeployTools \u00b6 Normally, you would not have to call this directly, as qmakeInit will for you. This function will install any tools required to produce distributions for Qt C++ based programs. On Linux, you may wish to pass a value for the askPassPath argument. That is needed to invoke the function from a non-tty gui context. The value should define the path to an \u201cask password\u201d utility e.g. \u201cOpenSSH Askpass\u201d renameExe \u00b6 In some contexts, it is desirable to rename the exe which was built by QMake, when it comes time to package and distribute it. This is a primitive convenience function for that purpose. Using the args object, i.e. qmakeArgs , passed to it to determine the old and new path, the original executable will simply be renamed (i.e. literally - on the file system) and the exePath attribute of args will be revised to reflect the change. This takes place within qmakeInit , allowing the rest of the subsequent configurations and processes to remain oblivious to this initialization task. qmakeMasterConfigFactory, qmakePackageConfigFactory \u00b6 You may bypass the qmakeInit function, and call either of these functions directly to generate the corresponding ConfigFactory. Both of the functions take an optional argument called args , which is the product of a call to parse_args() from an ArgParse object. If that is not provided, those values will be collected via the default command line mechanism. QtCppConfig \u00b6 This class is used for low level Qt C++ packaging configurations. You will NOT likely need to manipulate this type of class directly, but it is included in this documentation for the sake of completeness. This type of object is owned by a ConfigFactory , and (as a product of that) by a QtIfwPackage object. It is ultimately employed by the buildInstaller function, normally invoked via a Process Class . Constructor: QtCppConfig( qtBinDirPath, exeCompiler, qmlScrDirPath=None ) Attributes: qtBinDirPath exeCompiler qmlScrDirPath cQtDeployerConfig Object Functions: qtDirPath() toQtPath( relativePath ) validate() addDependencies( package ) Static Functions: srcCompilerOptions() exeWrapper( exePath, isGui ) QtCppConfig.CQtDeployerConfig \u00b6 On Linux, distbuilder uses a tool called CQtDeployer to assist with the build process for Qt C++ deployments. This class allows you to customize how that utility is employed. Please refer to that documentation for help. Constructor: CQtDeployerConfig() Attributes: libDirs = [] plugins = [] <custom addition, use package names> hiddenQml = [] <custom addition, open ended - works like distResources...> hiddenDependencies = [] ignoreLibs = [] ignoreEnv = [] recurseDepth = 0 deploySystem = False deployLibc = False allQml = False strip = True translations = True <open ended string to append> otherArgs = None QMake Integration \u00b6 To produce an executable binary from Qt C++ source, a developer normally defines a (scripted) build configuration in the form of a \u201cproject file\u201d ( .pro ). That .pro file is processed by QMake to produce the program. Typically, the .pro file initially originates from some basic template, and QMake is simply run automatically from Qt Creator upon selecting a \u201cbuild\u201d action from the menu. QMake is a very powerful mechanism, and these .pro files can be customized extensively to setup complex build processes. In addition to .pro files, Qt uses more dynamic, user specific .pro.user files. These are normally managed via Qt Creator tools, and not directly edited (though they may be). For extended information about such, you may wish to refer to any/all of the following links: Opening Projects Configuring Projects . Editing Build Configurations As illustrated in the Qt demos here, you can setup an easy work flow to allow use of this Python library from Qt Creator. The demos include custom QMake scripting which you may copy into your own projects. Using these demo templates, the setup procedures are short and sweet, but they do span both .pro and .pro.user files. Since .pro.user files are specific to a user\u2019s environment, there is no way to distribute those in a manner which would work anything close to universally. As such, to run the demos, you must first manually perform the following tasks when you open one of these .pro files (which can be distributed) for the first time on a given machine: From the \u201cProjects\u201d screen, clone a \u201cRelease\u201d build configuration. Name the new configuration \u201cPackage\u201d (or a similiar name of your choice). For this configuration, find the Build steps\u2026 qmake\u2026 Additional arguments input field and add CONFIG+=package . CONDITIONALLY : within the Build Environment, add an environmental variable named PYTHON_PATH and define its value to be the path to the specific interpreter you wish to use. If you skip this, the build process will attempt to use python from the system path. To then use the new build option, choose the configuration (found along with Debug, Release, etc.) from the menu in the bottom left corner of Creator (above the big green \u201cplay\u201d button). Then, select Build\u2026 REBUILD Project from the menu. Do NOT chose \u201cdeploy\u201d or \u201crun\u201d for this configuration, as they are not applicable. Upon selecting this build option, a key portion of the custom QMake logic should be executed. When it is, you will find important debugging information in the \u201cGeneral Messages\u201d output pane of Creator. If this library can\u2019t be reached, you will see critical error messages there, indicating what has gone wrong. If everything is in order, however, you should see your Python version displayed, the version of distbuilder being used, and the command which will be executed to run the build script . Note that you may wish to copy that command and execute it directly from the command prompt / terminal in the event you want to run the build script again without having to recompile the C++ project. When you run the REBUILD operation, you will find important debugging information in the \u201cCompile Output\u201d pane of Creator. All messages produced by the Python script will appear at the end of that build log. For more details regarding the QMake script involved, and for ways to modify (or fix) your integration, please continue on to the Hello World Qt Example . Hello World Qt Example \u00b6 This example Qt project was initially created from a simple built-in template, i.e. what is given to you upon selecting a new \u201cQt Widgets Application\u201d project in Creator. It was then modified slightly for this demo. This illustrates how you can rapidly package a Widgets based program for distribution via this Python library. All of the examples discussed here are included in the \u201csource distribution\u201d of the library. The PyPi downloads page for this project is arguably the fastest route to acquire the examples. Unlike many of the other examples stepped through in this documentation, not every file will be explicitly listed and discussed here. Once you have the examples source, launch Qt Creator. Then select File... Open File Or Project... , browse to the examples sub directory named hello_qt , and select hello.pro . Upon opening the project, follow the instructions in the above QMake Integration section. Test your new \u201cPackage\u201d build configuration. If anything fails, you might well spot your incompatibility by stepping through the QMake. The place to begin this code review is in the hello.pro file. It starts with pure boiler plate QMake, and then ends with the following: # DISTRIBUTION BUILDER INTEGRATION # ============================================================================== include ( package / package . pri ) !isEmpty(QMAKE_POST_LINK){ message ( Commands to execute upon rebuild :) message ( $$ { QMAKE_POST_LINK }) } What this accomplishes is the inclusion of a \u201csub project\u201d within the main one called \u201cpackage\u201d. That sub project has a corresponding sub directory, and .pri file of the same the name. This sub project include the resources for packaging the application, and all of that has been encapsulated rather then blending it with the rest of the work. This template gives you an easy means to copy and paste this feature into your own existing work. If you expand the \u201cpackage\u201d sub project in the side bar, you\u2019ll find the pri , and \u201cOther Files\u201d, which contains package.py . The Python script is the distbuilder \u201cbuild\u201d script. We elected the name that script \u201cpackage\u201d (along with rest of the sub project), so as to not conflate the meaning of \u201cbuild\u201d in C++ with this additional step. Next, let\u2019s look over package.pri . At the top of that, you\u2019ll find: # Get the python interpreter path from an environmental variable, if possible. # Note, that may be assigned in a .pro.user. If that is not defined, fall-back to # a hard-coded value which assumes you want to use \"python\" from the system path. PY_PATH =$$ getenv ( PYTHON_PATH ) isEmpty ( PY_PATH ){ PY_PATH = python } As denoted by the comment, this is how Python is integrated in the most elementary aspect of the mechanism. If an environmental variable called PYTHON_PATH is defined, that is how the interpreter will be called upon. Note that may be either universally set on your system, or added to your \u201cPackage\u201d build configuration\u2019s \u201crun settings\u201d (i.e. in pro.user ). Alternatively, a hard-coded fall back to python on the system path is used. If desired, you might change that to another fall-back e.g. python3 . Note that finding the interpreter will also dictate the availability of the library. If you have multiple instances of Python installed, make sure you use the same one where you ran the pip installation for this library. The next portion of package.pri is comprised of assorted support functions. Scroll down a bit, and you\u2019ll find the following: # Global application info shared across the C++ layer, # the binary branding, and the Python installation builder! DEFINES += $$globalStrDef( APP_VERSION, 1.0.0.0 ) DEFINES += $$globalStrDef( COMPANY_TRADE_NAME, Some Company ) DEFINES += $$globalStrDef( COMPANY_LEGAL_NAME, Some Company Inc. ) DEFINES += $$globalStrDef( COPYRIGHT_YEAR, $${currentYear} ) DEFINES += $$globalStrDef( PRODUCT_TITLE, Hello World QML Example ) DEFINES += $$globalStrDef( PRODUCT_DESCRIPTION, A Distribution Builder Example ) In this section, the custom details are defined for the name of the product, and company, etc. Note, these values cascade down in the C++ in addition to being passed around the QMake build process and finally onto distbuilder. This provides the means to define such info in a single \u201cmaster\u201d location. If you check out the mainwindow.cpp C++ implementation file, you will see this in action on that side of the equation. Just below, the .pri contains: SETUP_NAME=HelloQtSetup win32: ICON_PATH=$${_PRO_FILE_PWD_}/icons/demo.ico macx: ICON_PATH=$${_PRO_FILE_PWD_}/icons/demo.icns linux: ICON_PATH=$${_PRO_FILE_PWD_}/icons/demo.png This section let\u2019s you define the name of setup file to be ultimately produced, along with relative paths to icons. As you continue on, the script effectively builds a command to append onto QMAKE_POST_LINK . That is way in which the Python script is executed upon rebuilding the project using the \u201cPackage\u201d build configuration. Now, onto the Python script package.py . It simply contains: from distbuilder import RobustInstallerProcess from distbuilder.qt_cpp import qmakeInit masterFactory , packageFactory = qmakeInit () helloQtPkg = packageFactory . qtIfwPackage () p = RobustInstallerProcess ( masterFactory , ifwPackages = [ helloQtPkg ], isDesktopTarget = True ) p . isTestingInstall = True p . run () Most of this has been explained the Qt C++ Module section and / or the basic examples . The key points to to focus upon are: masterFactory, packageFactory = qmakeInit() Creates ConfigFactory objects, using the QMake passed values. helloQtPkg = packageFactory.qtIfwPackage() Creates a QtIfwPackage object. p = RobustInstallerProcess ( masterFactory , ifwPackages =[ helloQtPkg ] , isDesktopTarget = True ) Creates a RobustInstallerProcess , which will employ the masterFactory and include the package containing the C++ program. Hello World QML Example \u00b6 This example was initially created from what is given to you upon selecting a new \u201cQt Quick Application - Canvas 3D\u201d (including three.js) project in Creator. It was then modified for this demo. Notably, some refactoring was done to shuffle select components into a \u201cux\u201d sub project. This illustrates how you can rapidly package a QML based program, (with some dependencies and resources) for distribution via this Python library. NOTE: Please refer to Hello World QML New Example if you are using a recent version of the Qt Library, as the Canvas3D module was deprecated in Qt 5.12. and entirely removed from later versions! Assuming you already have the examples source, launch Qt Creator. Then select File... Open File Or Project... , browse to the examples sub directory named hello_qml , and select hello.pro . Upon opening the project, follow the instructions in the above QMake Integration section. Test your new \u201cPackage\u201d build configuration. Other than the C++ side of this, this example is nearly identical to the more primitive Hello World Qt Example . There is one key difference. In package.pri , near the end you find this line: qmlSourcePath = $${_PRO_FILE_PWD_}/ux Then, as packageCmd is being built, you\u2019ll find qmlSourcePath used: -q $$quot( $$clean_path( $${qmlSourcePath} ) ) This was the reason why the basic template was revised, to create a ux sub project / sub directory. The tools used in distbuilder to find and collect the dependencies for QML components require a directory path to where the QML source resides for the project. The process works ideally if it scans a directory (recursively) which is reserved primarily for these specific files. It is a good practice to keep your C++ and QML split apart anyway, so this is a logical design either way. Hello World QML New Example \u00b6 This example was added to replace the original QML example, for use with newer versions of Qt. This was based on the standard \u201cQt 3D: Scene3dView QML Example\u201d, which can be readily found from within the Creator. Aside from the Qt specific / UX changes, it is nearly identical to the original Hello World QML Example . One notable difference from the original example, is that one demonstrates the use of the hiddenQml attribute of class QtCppConfig.CQtDeployerConfig . It would seem that the CQtDeployer tool used on Linux, is not able to bundle those resources automatically because Qt did not follow the path conventions for this QML module and/or do not reference it in the example code in a manner which aligns with that. This example, therefore, shows how to solve that problem! Additional Options \u00b6 In addition to the options for the QMake integration demoed and discussed, there are a handful more worth noting. These are all optional command line switches provided by the default qmakeInit mechanism. srcDir \u00b6 While this parameter is optional, it\u2019s generally a good idea to specify it. The packageConfigFactory object returned by qmakeInit() will have the sourceDir attribute set to this. That attribute is used to resolve relative paths to resources. If omitted, the \u201csource directory\u201d will become the parent directory to the requisite exePath value (i.e. the dynamic build directory ) where QMake produced the C++ binary. In the examples provided, as is more then likely desirable, the root directory to the project\u2019s source has been explicitly passed. If you wish to point this base path for resources to some other location (e.g. a sub directory within your project), you may do so with this option. resource \u00b6 The --resource switch (or -r for short) maybe passed repeatedly. Use this to bundle additional files or directories into the package. Note that relative paths will be resolved against the --srcDir switch. If you need to place the resource within a nested subdirectory in the target package (or simply rename the resource in the product), you may pass a semicolon ; delimited pair of paths. The first value in the pair is the source, and the second is the target path relative to the target package root. Example: -r \"readme.txt;docs/help.txt\" This would bundle the readme.txt (on the --srcDir root) into the package within a sub directory called \u201cdocs\u201d and would rename the file \u201chelp.txt\u201d. You may, of course, add resources to the package from within the Python build script, rather than passing that in from an external source in this manner. exeName \u00b6 In some contexts, it is desirable to rename the exe which was built by QMake, when it comes time to package and distribute it. This switch is employed by the simple renameExe function via the the default qmakeInit mechanism. askPass \u00b6 This option is only pertinent for Linux users. In the examples, you\u2019ll find this near the end of the package QMake script: # On Linux , you may optionally provide a custom \" AskPass \" program to handle # password input for root / sudo privileges if required # linux : packageCmd += -- askPass $$ quot ( $ $c lean_path ( / usr / share / git - cola / bin / ssh - askpass ) ) In order to run the integration from a non-tty gui context (e.g. Qt Creator), you will need to lean on an \u201cask password\u201d utility. When you attempt to use the package script for the first time, it may fail because no such tool is found on the system. It will suggest you install \u201cOpenSSH Askpass\u201d. If you prefer something else, or have that installed in a path the script can\u2019t locate, uncomment this QMake directive and provide that detail (e.g. the git-cola path demoed).","title":"Qt C++ Integration"},{"location":"QtCpp.html#qt-c-integration","text":"","title":"Qt C++ Integration"},{"location":"QtCpp.html#overview","text":"The developers of Distribution Builder work in many languages and frameworks extending beyond Python. Ultimately, we hope to provide a collection of rapid integration modules for this library for other modes of software development. The first of these integrations we are rolling out is a ready means to allow your Qt C++ programs to flow directly into this tool. The library can then be used as a middleman between Qt Creator and the Qt Installer Framework . This mechanism provides far more flexibility than simply bridging those tools, however. Other packages, notably Python based programs, can be built and bundled together simultaneously. This design pattern gives you the full power of Distribution Builder (and Python on the whole) by which to extend your Qt build process. If you have not done so yet, it is strongly recommended that you you get your feet wet with this library by at least reviewing Getting Started prior to diving into this extended feature set. Also, you will need to be versed in using Qt Creator and writing code with the Qt Library in order to make use of this, or follow the examples / documentation.","title":"Overview"},{"location":"QtCpp.html#qt-c-module","text":"A module has been provided in distbuilder which is specifically dedicated to Qt C++ integration, i.e. distbuilder.qt_cpp . The following functions / classes can be imported from that: qmakeInit() qmakeArgParser() qmakeArgs() installDeployTools( askPassPath=None ) renameExe( args ) qmakeMasterConfigFactory( args=None ) qmakePackageConfigFactory( args=None ) QtCppConfig( qtBinDirPath, exeCompiler, qmlScrDirPath=None ) <Linux Only> QtCppConfig.CQtDeployerConfig Under most circumstances, you will only need to call qmakeInit . If you wish to customize that process or receive additional specifications from an external source (e.g. QMake), you may use the other functions to emulate and custom define what the vanilla qmakeInit does for you.","title":"Qt C++ Module"},{"location":"QtCpp.html#qmake-integration","text":"To produce an executable binary from Qt C++ source, a developer normally defines a (scripted) build configuration in the form of a \u201cproject file\u201d ( .pro ). That .pro file is processed by QMake to produce the program. Typically, the .pro file initially originates from some basic template, and QMake is simply run automatically from Qt Creator upon selecting a \u201cbuild\u201d action from the menu. QMake is a very powerful mechanism, and these .pro files can be customized extensively to setup complex build processes. In addition to .pro files, Qt uses more dynamic, user specific .pro.user files. These are normally managed via Qt Creator tools, and not directly edited (though they may be). For extended information about such, you may wish to refer to any/all of the following links: Opening Projects Configuring Projects . Editing Build Configurations As illustrated in the Qt demos here, you can setup an easy work flow to allow use of this Python library from Qt Creator. The demos include custom QMake scripting which you may copy into your own projects. Using these demo templates, the setup procedures are short and sweet, but they do span both .pro and .pro.user files. Since .pro.user files are specific to a user\u2019s environment, there is no way to distribute those in a manner which would work anything close to universally. As such, to run the demos, you must first manually perform the following tasks when you open one of these .pro files (which can be distributed) for the first time on a given machine: From the \u201cProjects\u201d screen, clone a \u201cRelease\u201d build configuration. Name the new configuration \u201cPackage\u201d (or a similiar name of your choice). For this configuration, find the Build steps\u2026 qmake\u2026 Additional arguments input field and add CONFIG+=package . CONDITIONALLY : within the Build Environment, add an environmental variable named PYTHON_PATH and define its value to be the path to the specific interpreter you wish to use. If you skip this, the build process will attempt to use python from the system path. To then use the new build option, choose the configuration (found along with Debug, Release, etc.) from the menu in the bottom left corner of Creator (above the big green \u201cplay\u201d button). Then, select Build\u2026 REBUILD Project from the menu. Do NOT chose \u201cdeploy\u201d or \u201crun\u201d for this configuration, as they are not applicable. Upon selecting this build option, a key portion of the custom QMake logic should be executed. When it is, you will find important debugging information in the \u201cGeneral Messages\u201d output pane of Creator. If this library can\u2019t be reached, you will see critical error messages there, indicating what has gone wrong. If everything is in order, however, you should see your Python version displayed, the version of distbuilder being used, and the command which will be executed to run the build script . Note that you may wish to copy that command and execute it directly from the command prompt / terminal in the event you want to run the build script again without having to recompile the C++ project. When you run the REBUILD operation, you will find important debugging information in the \u201cCompile Output\u201d pane of Creator. All messages produced by the Python script will appear at the end of that build log. For more details regarding the QMake script involved, and for ways to modify (or fix) your integration, please continue on to the Hello World Qt Example .","title":"QMake Integration"},{"location":"QtCpp.html#hello-world-qt-example","text":"This example Qt project was initially created from a simple built-in template, i.e. what is given to you upon selecting a new \u201cQt Widgets Application\u201d project in Creator. It was then modified slightly for this demo. This illustrates how you can rapidly package a Widgets based program for distribution via this Python library. All of the examples discussed here are included in the \u201csource distribution\u201d of the library. The PyPi downloads page for this project is arguably the fastest route to acquire the examples. Unlike many of the other examples stepped through in this documentation, not every file will be explicitly listed and discussed here. Once you have the examples source, launch Qt Creator. Then select File... Open File Or Project... , browse to the examples sub directory named hello_qt , and select hello.pro . Upon opening the project, follow the instructions in the above QMake Integration section. Test your new \u201cPackage\u201d build configuration. If anything fails, you might well spot your incompatibility by stepping through the QMake. The place to begin this code review is in the hello.pro file. It starts with pure boiler plate QMake, and then ends with the following: # DISTRIBUTION BUILDER INTEGRATION # ============================================================================== include ( package / package . pri ) !isEmpty(QMAKE_POST_LINK){ message ( Commands to execute upon rebuild :) message ( $$ { QMAKE_POST_LINK }) } What this accomplishes is the inclusion of a \u201csub project\u201d within the main one called \u201cpackage\u201d. That sub project has a corresponding sub directory, and .pri file of the same the name. This sub project include the resources for packaging the application, and all of that has been encapsulated rather then blending it with the rest of the work. This template gives you an easy means to copy and paste this feature into your own existing work. If you expand the \u201cpackage\u201d sub project in the side bar, you\u2019ll find the pri , and \u201cOther Files\u201d, which contains package.py . The Python script is the distbuilder \u201cbuild\u201d script. We elected the name that script \u201cpackage\u201d (along with rest of the sub project), so as to not conflate the meaning of \u201cbuild\u201d in C++ with this additional step. Next, let\u2019s look over package.pri . At the top of that, you\u2019ll find: # Get the python interpreter path from an environmental variable, if possible. # Note, that may be assigned in a .pro.user. If that is not defined, fall-back to # a hard-coded value which assumes you want to use \"python\" from the system path. PY_PATH =$$ getenv ( PYTHON_PATH ) isEmpty ( PY_PATH ){ PY_PATH = python } As denoted by the comment, this is how Python is integrated in the most elementary aspect of the mechanism. If an environmental variable called PYTHON_PATH is defined, that is how the interpreter will be called upon. Note that may be either universally set on your system, or added to your \u201cPackage\u201d build configuration\u2019s \u201crun settings\u201d (i.e. in pro.user ). Alternatively, a hard-coded fall back to python on the system path is used. If desired, you might change that to another fall-back e.g. python3 . Note that finding the interpreter will also dictate the availability of the library. If you have multiple instances of Python installed, make sure you use the same one where you ran the pip installation for this library. The next portion of package.pri is comprised of assorted support functions. Scroll down a bit, and you\u2019ll find the following: # Global application info shared across the C++ layer, # the binary branding, and the Python installation builder! DEFINES += $$globalStrDef( APP_VERSION, 1.0.0.0 ) DEFINES += $$globalStrDef( COMPANY_TRADE_NAME, Some Company ) DEFINES += $$globalStrDef( COMPANY_LEGAL_NAME, Some Company Inc. ) DEFINES += $$globalStrDef( COPYRIGHT_YEAR, $${currentYear} ) DEFINES += $$globalStrDef( PRODUCT_TITLE, Hello World QML Example ) DEFINES += $$globalStrDef( PRODUCT_DESCRIPTION, A Distribution Builder Example ) In this section, the custom details are defined for the name of the product, and company, etc. Note, these values cascade down in the C++ in addition to being passed around the QMake build process and finally onto distbuilder. This provides the means to define such info in a single \u201cmaster\u201d location. If you check out the mainwindow.cpp C++ implementation file, you will see this in action on that side of the equation. Just below, the .pri contains: SETUP_NAME=HelloQtSetup win32: ICON_PATH=$${_PRO_FILE_PWD_}/icons/demo.ico macx: ICON_PATH=$${_PRO_FILE_PWD_}/icons/demo.icns linux: ICON_PATH=$${_PRO_FILE_PWD_}/icons/demo.png This section let\u2019s you define the name of setup file to be ultimately produced, along with relative paths to icons. As you continue on, the script effectively builds a command to append onto QMAKE_POST_LINK . That is way in which the Python script is executed upon rebuilding the project using the \u201cPackage\u201d build configuration. Now, onto the Python script package.py . It simply contains: from distbuilder import RobustInstallerProcess from distbuilder.qt_cpp import qmakeInit masterFactory , packageFactory = qmakeInit () helloQtPkg = packageFactory . qtIfwPackage () p = RobustInstallerProcess ( masterFactory , ifwPackages = [ helloQtPkg ], isDesktopTarget = True ) p . isTestingInstall = True p . run () Most of this has been explained the Qt C++ Module section and / or the basic examples . The key points to to focus upon are: masterFactory, packageFactory = qmakeInit() Creates ConfigFactory objects, using the QMake passed values. helloQtPkg = packageFactory.qtIfwPackage() Creates a QtIfwPackage object. p = RobustInstallerProcess ( masterFactory , ifwPackages =[ helloQtPkg ] , isDesktopTarget = True ) Creates a RobustInstallerProcess , which will employ the masterFactory and include the package containing the C++ program.","title":"Hello World Qt Example"},{"location":"QtCpp.html#hello-world-qml-example","text":"This example was initially created from what is given to you upon selecting a new \u201cQt Quick Application - Canvas 3D\u201d (including three.js) project in Creator. It was then modified for this demo. Notably, some refactoring was done to shuffle select components into a \u201cux\u201d sub project. This illustrates how you can rapidly package a QML based program, (with some dependencies and resources) for distribution via this Python library. NOTE: Please refer to Hello World QML New Example if you are using a recent version of the Qt Library, as the Canvas3D module was deprecated in Qt 5.12. and entirely removed from later versions! Assuming you already have the examples source, launch Qt Creator. Then select File... Open File Or Project... , browse to the examples sub directory named hello_qml , and select hello.pro . Upon opening the project, follow the instructions in the above QMake Integration section. Test your new \u201cPackage\u201d build configuration. Other than the C++ side of this, this example is nearly identical to the more primitive Hello World Qt Example . There is one key difference. In package.pri , near the end you find this line: qmlSourcePath = $${_PRO_FILE_PWD_}/ux Then, as packageCmd is being built, you\u2019ll find qmlSourcePath used: -q $$quot( $$clean_path( $${qmlSourcePath} ) ) This was the reason why the basic template was revised, to create a ux sub project / sub directory. The tools used in distbuilder to find and collect the dependencies for QML components require a directory path to where the QML source resides for the project. The process works ideally if it scans a directory (recursively) which is reserved primarily for these specific files. It is a good practice to keep your C++ and QML split apart anyway, so this is a logical design either way.","title":"Hello World QML Example"},{"location":"QtCpp.html#hello-world-qml-new-example","text":"This example was added to replace the original QML example, for use with newer versions of Qt. This was based on the standard \u201cQt 3D: Scene3dView QML Example\u201d, which can be readily found from within the Creator. Aside from the Qt specific / UX changes, it is nearly identical to the original Hello World QML Example . One notable difference from the original example, is that one demonstrates the use of the hiddenQml attribute of class QtCppConfig.CQtDeployerConfig . It would seem that the CQtDeployer tool used on Linux, is not able to bundle those resources automatically because Qt did not follow the path conventions for this QML module and/or do not reference it in the example code in a manner which aligns with that. This example, therefore, shows how to solve that problem!","title":"Hello World QML New Example"},{"location":"QtCpp.html#additional-options","text":"In addition to the options for the QMake integration demoed and discussed, there are a handful more worth noting. These are all optional command line switches provided by the default qmakeInit mechanism.","title":"Additional Options"},{"location":"QuickStart.html","text":"Quick Start Guide \u00b6 Installation \u00b6 Easy installation (via pip) \u00b6 Depending upon your computer\u2019s configuration, installation may be as simple as executing the following on your terminal / command prompt: pip install distbuilder Alternatively, you might need to use the \u201clong version\u201d of that: python -m pip install distbuilder Within some environments, it may necessary to run pip installations with elevated privileges, e.g. by prefixing the command with sudo . From source installation \u00b6 To install from the raw source instead (useful if you want a \u201ccutting edge\u201d alpha release), you may perform a Git clone from https://github.com/BuvinJT/distbuilder.git , or otherwise download the repository in a \u201cflat\u201d manner from the GitHub Page . You may also visit the PyPi downloads page for this project to instantly acquire an official release in the form of a tarball. With a local copy of the full source, on Windows you may be able to simply run install.bat (or install3.bat ). On Mac or Linux, you may use the counterpart install.sh (or install3.sh ) instead. Those scripts are found in the repo\u2019s root. If you encounter failures with those scripts, you probably need to tweak them slightly for your environment. Before attempting that, however, try this \u201cmanual\u201d approach. From a command line interface, change to the directory containing the source, then execute: python - m pip install . ( Don ' t miss the period at the end!) Pre-Requisites \u00b6 Python 2.7 or Newer \u00b6 If you don\u2019t have Python installed, you\u2019ll need to start there! While it may be possible to run distbuilder on versions of Python predating v.2.7, this is not a supported condition. It recommended that you use v.3.x if possible, since Python 2 is now officially \u201cdead\u201d to begin with\u2026 Pip \u00b6 Both the distbuilder installation, and the use of some features within it , require pip . More than likely, you already have that installed. If not, note that the installation process may be slightly different based on your platform or environmental details (e.g. having multiple Python installations). The scope of such matters is beyond what can be addressed here. Refer to these links as a starting point: Pip on Windows Pip on Mac Pip on Linux Opy \u00b6 The distbuilder library requires a fork from the open source project \u201cOpy\u201d, dubbed \u201c Opy for Distribution Builder \u201d. When installing distbuilder, this dependency should be automatically installed for you. To acquire the source for that directly, and manually install it instead, you may use the links/urls below: Opy for Distribution Builder Or, via the direct git clone url: https://github.com/QQuick/Opy.git BRANCH: opy_distbuilder The most recent (development) commits, however, are accessible from the development GitHub Page or directly via git using: https://github.com/BuvinJT/Opy.git Qt Installer Framework (optional / recommended) \u00b6 Additionally, the \u201cQt Installer Framework\u201d is a conditional dependency. This component is not a hard requirement, but is strongly recommended , so that you may employ the installer creating features offered by distbuilder. When you use the library\u2019s features which require this external utility, it will be automatically installed for you, if it is not already present on the system (or cannot be found). If desired, you may also manually install it. Installation and uninstallation can, in fact, be accomplished with functions provided by distbuilder. (Refer to installQtIfw / unInstallQtIfw for details.) Alternatively, QtIFW can be directly acquired from: QtIFW downloads If manually installed, the \u201cbest\u201d way to integrate it with distbuilder is to define an environmental variable named QT_IFW_DIR and the set value for that equal to the directory where you installed the utility. See QtIFW issues if you require help with that. Note, it also possible to supply the path within your implementation script. Refer to QtIfwConfig or buildInstaller for more details. Implementation Overview \u00b6 The \u201cstandard\u201d way distbuilder is intended to be used is by adding a build.py script to the root directory of the project you wish to distribute. (Note: the file may have any name of your choice - \u201cbuild.py\u201d is merely a recommended naming convention). After defining that script, you simply run it to build your distribution package. In build.py , you may wish to import everything from this library via import distbuilder * . If your build script will use a large collection of the \u201clow level functions\u201d offered by the library, starting it in that manner is often a convenient choice. If you will only be employing the high level classes and functions, you may be better off to selectively import them. The first example project Hello World Example , for instance, only needs two specific imports, and so it starts out from distbuilder import PyToBinPackageProcess, ConfigFactory . Additionally, distbuilder may serve you well as a setup.py script, which you run within a given development environment to install dependencies and/or perform other initialization tasks for working on the project. For more on this usage, refer to: Library Installation Module import utilities download run Getting Started \u00b6 The easiest way for most people to learn how to use distbuilder is to step through some examples . Unfortunately, it is not practical to provide, and describe, demonstrations of all of the library\u2019s features (and no reader would likely wish to invest the time required for such an endeavor!) If you spend just 10 minutes reviewing a handful of the ones provided, however, you should come away with a solid base from which start employing this tool. Learn More \u00b6 For a more thorough explanation of how to use the library, continue on to High Level Classes next. Then, review Configuration Classes and/or Low Level Functions for even more details.","title":"Quick Start"},{"location":"QuickStart.html#quick-start-guide","text":"","title":"Quick Start Guide"},{"location":"QuickStart.html#installation","text":"","title":"Installation"},{"location":"QuickStart.html#pre-requisites","text":"","title":"Pre-Requisites"},{"location":"QuickStart.html#implementation-overview","text":"The \u201cstandard\u201d way distbuilder is intended to be used is by adding a build.py script to the root directory of the project you wish to distribute. (Note: the file may have any name of your choice - \u201cbuild.py\u201d is merely a recommended naming convention). After defining that script, you simply run it to build your distribution package. In build.py , you may wish to import everything from this library via import distbuilder * . If your build script will use a large collection of the \u201clow level functions\u201d offered by the library, starting it in that manner is often a convenient choice. If you will only be employing the high level classes and functions, you may be better off to selectively import them. The first example project Hello World Example , for instance, only needs two specific imports, and so it starts out from distbuilder import PyToBinPackageProcess, ConfigFactory . Additionally, distbuilder may serve you well as a setup.py script, which you run within a given development environment to install dependencies and/or perform other initialization tasks for working on the project. For more on this usage, refer to: Library Installation Module import utilities download run","title":"Implementation Overview"},{"location":"QuickStart.html#getting-started","text":"The easiest way for most people to learn how to use distbuilder is to step through some examples . Unfortunately, it is not practical to provide, and describe, demonstrations of all of the library\u2019s features (and no reader would likely wish to invest the time required for such an endeavor!) If you spend just 10 minutes reviewing a handful of the ones provided, however, you should come away with a solid base from which start employing this tool.","title":"Getting Started"},{"location":"QuickStart.html#learn-more","text":"For a more thorough explanation of how to use the library, continue on to High Level Classes next. Then, review Configuration Classes and/or Low Level Functions for even more details.","title":"Learn More"},{"location":"ToDo.html","text":"To-Do List \u00b6 The following is a loose, ever evolving \u201croad map\u201d for planned releases of the library, grouped / ordered by release number: v.0.7.8.x (WIP) \u00b6 Code signing for Windows Provide a \u201cnatural\u201d silent uninstall / wrapper to run the Maintenance Tool. Directory creation on target (e.g. user data directories) Resource installation outside of the target directory QtIFW graphic features v.0.7.9.x \u00b6 RESTORE Linux / Mac QtIFW integration (broken during Windows development of 0.7.8.x) Dependency installation for QtIFW via Linux package managers (partially developed already), and Homebrew on Mac Add she bang respect / a Windows equivalent to ExecutableScript / QtIwfExternalOp embedded scripting mechanism, allowing interpreter paths / options to be defined. Thus allowing options for embedding Python, Java, ect. Code signing for Mac / Linux Direct Bat/Vbs/Ps to Exe high level process class v.0.8.0 \u00b6 Add \u201cversion control\u201d / \u201cupdate control\u201d for installers. Auto launch maintainencetool when trying to install the same version. Have prompts questioning if the using wants to update or revert to a prior version. TEST (and develop as needed) QtIFW packages which: contain only \u201cdata\u201d (no exe) are not enabled for install by default do not install shortcuts More Windows registry functions, and analogous settings on other platforms (e.g. plist on Mac) Add \u201cpure\u201d QScript (custom operations) examples / features for QtIFW. Determine if custom UI elements can be used in an uninstaller context? How about an update? The ui forms are contained in packages, per QtIFW design. But packages are not loaded during uninstallation, so it seems an uninstaller couldn\u2019t support such ui customization\u2026 v.0.8.1 \u00b6 Revisit \u201cQtIfwExeWrapper\u201d details. Specifically: NON gui on Windows? Used with QtIfwOnFinishedCheckbox? Revisit QtIfwOnFinishedCheckbox. It has several TODOs documented in the code. Add option for appending platform suffix onto installer file names. Add tarball alternative to zip packaging. v.0.8.2 \u00b6 Add all yet to be provided parameters for PyInstaller. Add all yet to be provided elements for the various Qt IFW XML config classes. v.0.8.3 \u00b6 Large scale refactoring, to simplify the library and make it more user friendly. Rename high level process classes and functions. Consider dialing back the volume of published low level functions? v.0.9.x \u00b6 Improve and stabilize Opy to the point it can handle most scripts without any manual intervention. \u201cPerfect\u201d Opy \u201clibrary bundling\u201d (for both private and PyPi libraries). v.1.0 \u00b6 Extended QA\u2026 TBD TEST on more Windows versions (Servers?, 8.1?) TEST on more Linux distros (Debian, Fedora, Arch\u2026?) TEST on OSes with alternate language settings? (Hunting for path names or unicode glitches, etc.?) Continue to expand upon / clean up the documentation. v.1.1.x \u00b6 Add QtIFW \u201conline\u201d installer features. v.1.2.x \u00b6 Add git integration: Clone/pull to build project from multiple remote sources Add Anaconda integration v.1.3.x \u00b6 Add more git integration: auto commit / push / tag\u2026 Add auto conversion of alternate icon formats, so a project only needs one file for such. Further develop QtIfwUiPage derived classes and resources. v.2.x \u00b6 Provide PyInstaller forward/backward compatibility across OS versions. Currently, (depending upon the platform) building with PyInstaller (and/or QtIFW?) on an older or newer version of an OS can result in the product NOT being forwards or backwards compatible! Notably, there are known complications e.g. GCC .so dynamic linkage: Refer to: https://pythonhosted.org/PyInstaller/usage.html#making-linux-apps-forward-compatible Automate builds for multiple environments / platforms: Pyinstaller reference: https://pythonhosted.org/PyInstaller/usage.html#supporting-multiple-python-environments https://pythonhosted.org/PyInstaller/usage.html#supporting-multiple-operating-systems QtIFW cross platform single run master script (several binaries produced of course) Spit balls\u2026 \u00b6 Add a Py2Exe wrapper as alternative to PyInstaller. Add Py2Exe driven functions for Windows specific features which PyInstaller simply lacks (e.g. COM server dll creation). Add an NSIS wrapper as alternative to Qt IFW. Add setuptools / distutil wrappers an as alternative to pip. Add the option to build projects outside of the build script directory e.g. in temp. Add PyPi integration to publish open source releases. Add (configurable) interactive ui feature, to select various operations at runtime (cli or gui). Use the selected options to define the attributes of a process class, which is subsequently executed. The purpose of such is to allow the developer to select the options needed at the moment e.g. build exe, run exe, build installer, include obfuscation\u2026","title":"To-Do List"},{"location":"ToDo.html#to-do-list","text":"The following is a loose, ever evolving \u201croad map\u201d for planned releases of the library, grouped / ordered by release number:","title":"To-Do List"},{"location":"ToDo.html#v078x-wip","text":"Code signing for Windows Provide a \u201cnatural\u201d silent uninstall / wrapper to run the Maintenance Tool. Directory creation on target (e.g. user data directories) Resource installation outside of the target directory QtIFW graphic features","title":"v.0.7.8.x (WIP)"},{"location":"ToDo.html#v079x","text":"RESTORE Linux / Mac QtIFW integration (broken during Windows development of 0.7.8.x) Dependency installation for QtIFW via Linux package managers (partially developed already), and Homebrew on Mac Add she bang respect / a Windows equivalent to ExecutableScript / QtIwfExternalOp embedded scripting mechanism, allowing interpreter paths / options to be defined. Thus allowing options for embedding Python, Java, ect. Code signing for Mac / Linux Direct Bat/Vbs/Ps to Exe high level process class","title":"v.0.7.9.x"},{"location":"ToDo.html#v080","text":"Add \u201cversion control\u201d / \u201cupdate control\u201d for installers. Auto launch maintainencetool when trying to install the same version. Have prompts questioning if the using wants to update or revert to a prior version. TEST (and develop as needed) QtIFW packages which: contain only \u201cdata\u201d (no exe) are not enabled for install by default do not install shortcuts More Windows registry functions, and analogous settings on other platforms (e.g. plist on Mac) Add \u201cpure\u201d QScript (custom operations) examples / features for QtIFW. Determine if custom UI elements can be used in an uninstaller context? How about an update? The ui forms are contained in packages, per QtIFW design. But packages are not loaded during uninstallation, so it seems an uninstaller couldn\u2019t support such ui customization\u2026","title":"v.0.8.0"},{"location":"ToDo.html#v081","text":"Revisit \u201cQtIfwExeWrapper\u201d details. Specifically: NON gui on Windows? Used with QtIfwOnFinishedCheckbox? Revisit QtIfwOnFinishedCheckbox. It has several TODOs documented in the code. Add option for appending platform suffix onto installer file names. Add tarball alternative to zip packaging.","title":"v.0.8.1"},{"location":"ToDo.html#v082","text":"Add all yet to be provided parameters for PyInstaller. Add all yet to be provided elements for the various Qt IFW XML config classes.","title":"v.0.8.2"},{"location":"ToDo.html#v083","text":"Large scale refactoring, to simplify the library and make it more user friendly. Rename high level process classes and functions. Consider dialing back the volume of published low level functions?","title":"v.0.8.3"},{"location":"ToDo.html#v09x","text":"Improve and stabilize Opy to the point it can handle most scripts without any manual intervention. \u201cPerfect\u201d Opy \u201clibrary bundling\u201d (for both private and PyPi libraries).","title":"v.0.9.x"},{"location":"ToDo.html#v10","text":"Extended QA\u2026 TBD TEST on more Windows versions (Servers?, 8.1?) TEST on more Linux distros (Debian, Fedora, Arch\u2026?) TEST on OSes with alternate language settings? (Hunting for path names or unicode glitches, etc.?) Continue to expand upon / clean up the documentation.","title":"v.1.0"},{"location":"ToDo.html#v11x","text":"Add QtIFW \u201conline\u201d installer features.","title":"v.1.1.x"},{"location":"ToDo.html#v12x","text":"Add git integration: Clone/pull to build project from multiple remote sources Add Anaconda integration","title":"v.1.2.x"},{"location":"ToDo.html#v13x","text":"Add more git integration: auto commit / push / tag\u2026 Add auto conversion of alternate icon formats, so a project only needs one file for such. Further develop QtIfwUiPage derived classes and resources.","title":"v.1.3.x"},{"location":"ToDo.html#v2x","text":"Provide PyInstaller forward/backward compatibility across OS versions. Currently, (depending upon the platform) building with PyInstaller (and/or QtIFW?) on an older or newer version of an OS can result in the product NOT being forwards or backwards compatible! Notably, there are known complications e.g. GCC .so dynamic linkage: Refer to: https://pythonhosted.org/PyInstaller/usage.html#making-linux-apps-forward-compatible Automate builds for multiple environments / platforms: Pyinstaller reference: https://pythonhosted.org/PyInstaller/usage.html#supporting-multiple-python-environments https://pythonhosted.org/PyInstaller/usage.html#supporting-multiple-operating-systems QtIFW cross platform single run master script (several binaries produced of course)","title":"v.2.x"},{"location":"ToDo.html#spit-balls","text":"Add a Py2Exe wrapper as alternative to PyInstaller. Add Py2Exe driven functions for Windows specific features which PyInstaller simply lacks (e.g. COM server dll creation). Add an NSIS wrapper as alternative to Qt IFW. Add setuptools / distutil wrappers an as alternative to pip. Add the option to build projects outside of the build script directory e.g. in temp. Add PyPi integration to publish open source releases. Add (configurable) interactive ui feature, to select various operations at runtime (cli or gui). Use the selected options to define the attributes of a process class, which is subsequently executed. The purpose of such is to allow the developer to select the options needed at the moment e.g. build exe, run exe, build installer, include obfuscation\u2026","title":"Spit balls..."},{"location":"Utility%20Classes.html","text":"ConfigParser class \u00b6 ConfigParser implementing interpolation. Base Classes: Container, Iterable, Sized, Collection, Mapping, MutableMapping, RawConfigParser Instance Methods: add_section clear defaults get getboolean getfloat getint has_option has_section items keys options optionxform pop popitem read read_dict read_file read_string readfp remove_option remove_section sections set setdefault values write Class/Static Methods: update Class/Static Attributes: BOOLEAN_STATES NONSPACECRE OPTCRE OPTCRE_NV SECTCRE converters obj . add_section ( self , section ) \u00b6 Create a new section in the configuration. Extends RawConfigParser.add_section by validating if the section name is a string. obj . clear ( self ) \u00b6 D.clear() - None. Remove all items from D. obj . defaults ( self ) \u00b6 obj . get ( self , section , option , * , raw = False , vars = None , fallback =< object object at 0x01434920 > ) \u00b6 Get an option value for a given section. If vars' is provided, it must be a dictionary. The option is looked up in vars\u2019 (if provided), section', and in DEFAULTSECT\u2019 in that order. If the key is not found and fallback' is provided, it is used as a fallback value. None\u2019 can be provided as a `fallback\u2019 value. If interpolation is enabled and the optional argument `raw\u2019 is False, all interpolations are expanded in the return values. Arguments raw', vars\u2019, and `fallback\u2019 are keyword only. The section DEFAULT is special. obj . getboolean ( self , section , option , * , raw = False , vars = None , fallback =< object object at 0x01434920 > , ** kwargs ) \u00b6 obj . getfloat ( self , section , option , * , raw = False , vars = None , fallback =< object object at 0x01434920 > , ** kwargs ) \u00b6 obj . getint ( self , section , option , * , raw = False , vars = None , fallback =< object object at 0x01434920 > , ** kwargs ) \u00b6 obj . has_option ( self , section , option ) \u00b6 Check for the existence of a given option in a given section. If the specified section' is None or an empty string, DEFAULT is assumed. If the specified section\u2019 does not exist, returns False. obj . has_section ( self , section ) \u00b6 Indicate whether the named section is present in the configuration. The DEFAULT section is not acknowledged. obj . items ( self , section =< object object at 0x01434920 > , raw = False , vars = None ) \u00b6 Return a list of (name, value) tuples for each option in a section. All % interpolations are expanded in the return values, based on the defaults passed into the constructor, unless the optional argument raw' is true. Additional substitutions may be provided using the vars\u2019 argument, which must be a dictionary whose contents overrides any pre-existing defaults. The section DEFAULT is special. obj . keys ( self ) \u00b6 D.keys() - a set-like object providing a view on D\u2019s keys obj . options ( self , section ) \u00b6 Return a list of option names for the given section name. obj . optionxform ( self , optionstr ) \u00b6 obj . pop ( self , key , default =< object object at 0x01434098 > ) \u00b6 D.pop(k[,d]) - v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. obj . popitem ( self ) \u00b6 Remove a section from the parser and return it as a (section_name, section_proxy) tuple. If no section is present, raise KeyError. The section DEFAULT is never returned because it cannot be removed. obj . read ( self , filenames , encoding = None ) \u00b6 Read and parse a filename or an iterable of filenames. Files that cannot be opened are silently ignored; this is designed so that you can specify an iterable of potential configuration file locations (e.g. current directory, user\u2019s home directory, systemwide directory), and all existing configuration files in the iterable will be read. A single filename may also be given. Return list of successfully read files. obj . read_dict ( self , dictionary , source = '<dict>' ) \u00b6 Read configuration from a dictionary. Keys are section names, values are dictionaries with keys and values that should be present in the section. If the used dictionary type preserves order, sections and their keys will be added in order. All types held in the dictionary are converted to strings during reading, including section names, option names and keys. Optional second argument is the `source\u2019 specifying the name of the dictionary being read. obj . read_file ( self , f , source = None ) \u00b6 Like read() but the argument must be a file-like object. The f' argument must be iterable, returning one line at a time. Optional second argument is the source\u2019 specifying the name of the file being read. If not given, it is taken from f.name. If f' has no name\u2019 attribute, `???\u2019 is used. obj . read_string ( self , string , source = '<string>' ) \u00b6 Read configuration from a given string. obj . readfp ( self , fp , filename = None ) \u00b6 Deprecated, use read_file instead. obj . remove_option ( self , section , option ) \u00b6 Remove an option. obj . remove_section ( self , section ) \u00b6 Remove a file section. obj . sections ( self ) \u00b6 Return a list of section names, excluding [DEFAULT] obj . set ( self , section , option , value = None ) \u00b6 Set an option. Extends RawConfigParser.set by validating type and interpolation syntax on the value. obj . setdefault ( self , key , default = None ) \u00b6 D.setdefault(k[,d]) - D.get(k,d), also set D[k]=d if k not in D obj . values ( self ) \u00b6 D.values() - an object providing a view on D\u2019s values obj . write ( self , fp , space_around_delimiters = True ) \u00b6 Write an .ini-format representation of the configuration state. If `space_around_delimiters\u2019 is True (the default), delimiters between keys and values are surrounded by spaces. ConfigParser . update ( * args , ** kwds ) \u00b6 D.update([E, ]**F) - None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v ConfigParser . BOOLEAN_STATES class \u2018dict\u2019 default: None \u00b6 ConfigParser . NONSPACECRE class \u2018re.Pattern\u2019 default: None \u00b6 ConfigParser . OPTCRE class \u2018re.Pattern\u2019 default: None \u00b6 ConfigParser . OPTCRE_NV class \u2018re.Pattern\u2019 default: None \u00b6 ConfigParser . SECTCRE class \u2018re.Pattern\u2019 default: None \u00b6 ConfigParser . converters class \u2018property\u2019 default: None \u00b6 ExecutableScript class \u00b6 Magic Methods: __init__ Instance Methods: asSnippet debug exists fileName filePath fromBase64 fromLines injectLine read remove toBase64 toLines write Instance Attributes: rootName scriptDirPath replacements isIfwVarEscapeBackslash isDebug Class/Static Methods: linesToStr strToLines typeOf Class/Static Attributes: APPLESCRIPT_EXT BATCH_EXT JSCRIPT_EXT POWERSHELL_EXT SHELL_EXT SUPPORTED_EXTS VBSCRIPT_EXT ExecutableScript ( rootName , extension = True , shebang = True , script = None , scriptPath = None , scriptDirPath = None , replacements = None , isDebug = True ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . asSnippet ( self ) \u00b6 obj . debug ( self ) \u00b6 obj . exists ( self , scriptDirPath = None ) \u00b6 obj . fileName ( self ) \u00b6 obj . filePath ( self ) \u00b6 obj . fromBase64 ( self , data ) \u00b6 obj . fromLines ( self , lines ) \u00b6 obj . injectLine ( self , injection , lineNo ) \u00b6 obj . read ( self , scriptDirPath = None ) \u00b6 obj . remove ( self , scriptDirPath = None ) \u00b6 obj . toBase64 ( self , toString = False ) \u00b6 obj . toLines ( self ) \u00b6 obj . write ( self , scriptDirPath = None ) \u00b6 obj . rootName class \u2018NoneType\u2019 default: None \u00b6 obj . scriptDirPath class \u2018NoneType\u2019 default: None \u00b6 obj . replacements class \u2018dict\u2019 default: {} \u00b6 obj . isIfwVarEscapeBackslash class \u2018bool\u2019 default: False \u00b6 obj . isDebug class \u2018NoneType\u2019 default: None \u00b6 ExecutableScript . linesToStr ( lines ) \u00b6 ExecutableScript . strToLines ( s ) \u00b6 ExecutableScript . typeOf ( path ) \u00b6 ExecutableScript . APPLESCRIPT_EXT class \u2018str\u2019 default: \u201cscpt\u201d \u00b6 ExecutableScript . BATCH_EXT class \u2018str\u2019 default: \u201cbat\u201d \u00b6 ExecutableScript . JSCRIPT_EXT class \u2018str\u2019 default: \u201cjs\u201d \u00b6 ExecutableScript . POWERSHELL_EXT class \u2018str\u2019 default: \u201cps1\u201d \u00b6 ExecutableScript . SHELL_EXT class \u2018str\u2019 default: \u201csh\u201d \u00b6 ExecutableScript . SUPPORTED_EXTS class \u2018list\u2019 default: [\u2018sh\u2019, \u2018bat\u2019, \u2018vbs\u2019, \u2018js\u2019, \u2018ps1\u2019, \u2018scpt\u2019] \u00b6 ExecutableScript . VBSCRIPT_EXT class \u2018str\u2019 default: \u201cvbs\u201d \u00b6 RawConfigParser class \u00b6 ConfigParser that does not do interpolation. Base Classes: Container, Iterable, Sized, Collection, Mapping, MutableMapping Magic Methods: __init__ Instance Methods: add_section clear defaults get getboolean getfloat getint has_option has_section items keys options optionxform pop popitem read read_dict read_file read_string readfp remove_option remove_section sections set setdefault values write Instance Attributes: default_section Class/Static Methods: update Class/Static Attributes: BOOLEAN_STATES NONSPACECRE OPTCRE OPTCRE_NV SECTCRE converters RawConfigParser ( defaults = None , dict_type =< class ' collections . OrderedDict '>, allow_no_value=False, *, delimiters=(' = ', ' : '), comment_prefixes=(' #', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x01434920>, converters=<object object at 0x01434920>) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . add_section ( self , section ) \u00b6 Create a new section in the configuration. Raise DuplicateSectionError if a section by the specified name already exists. Raise ValueError if name is DEFAULT. obj . clear ( self ) \u00b6 D.clear() - None. Remove all items from D. obj . defaults ( self ) \u00b6 obj . get ( self , section , option , * , raw = False , vars = None , fallback =< object object at 0x01434920 > ) \u00b6 Get an option value for a given section. If vars' is provided, it must be a dictionary. The option is looked up in vars\u2019 (if provided), section', and in DEFAULTSECT\u2019 in that order. If the key is not found and fallback' is provided, it is used as a fallback value. None\u2019 can be provided as a `fallback\u2019 value. If interpolation is enabled and the optional argument `raw\u2019 is False, all interpolations are expanded in the return values. Arguments raw', vars\u2019, and `fallback\u2019 are keyword only. The section DEFAULT is special. obj . getboolean ( self , section , option , * , raw = False , vars = None , fallback =< object object at 0x01434920 > , ** kwargs ) \u00b6 obj . getfloat ( self , section , option , * , raw = False , vars = None , fallback =< object object at 0x01434920 > , ** kwargs ) \u00b6 obj . getint ( self , section , option , * , raw = False , vars = None , fallback =< object object at 0x01434920 > , ** kwargs ) \u00b6 obj . has_option ( self , section , option ) \u00b6 Check for the existence of a given option in a given section. If the specified section' is None or an empty string, DEFAULT is assumed. If the specified section\u2019 does not exist, returns False. obj . has_section ( self , section ) \u00b6 Indicate whether the named section is present in the configuration. The DEFAULT section is not acknowledged. obj . items ( self , section =< object object at 0x01434920 > , raw = False , vars = None ) \u00b6 Return a list of (name, value) tuples for each option in a section. All % interpolations are expanded in the return values, based on the defaults passed into the constructor, unless the optional argument raw' is true. Additional substitutions may be provided using the vars\u2019 argument, which must be a dictionary whose contents overrides any pre-existing defaults. The section DEFAULT is special. obj . keys ( self ) \u00b6 D.keys() - a set-like object providing a view on D\u2019s keys obj . options ( self , section ) \u00b6 Return a list of option names for the given section name. obj . optionxform ( self , optionstr ) \u00b6 obj . pop ( self , key , default =< object object at 0x01434098 > ) \u00b6 D.pop(k[,d]) - v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. obj . popitem ( self ) \u00b6 Remove a section from the parser and return it as a (section_name, section_proxy) tuple. If no section is present, raise KeyError. The section DEFAULT is never returned because it cannot be removed. obj . read ( self , filenames , encoding = None ) \u00b6 Read and parse a filename or an iterable of filenames. Files that cannot be opened are silently ignored; this is designed so that you can specify an iterable of potential configuration file locations (e.g. current directory, user\u2019s home directory, systemwide directory), and all existing configuration files in the iterable will be read. A single filename may also be given. Return list of successfully read files. obj . read_dict ( self , dictionary , source = '<dict>' ) \u00b6 Read configuration from a dictionary. Keys are section names, values are dictionaries with keys and values that should be present in the section. If the used dictionary type preserves order, sections and their keys will be added in order. All types held in the dictionary are converted to strings during reading, including section names, option names and keys. Optional second argument is the `source\u2019 specifying the name of the dictionary being read. obj . read_file ( self , f , source = None ) \u00b6 Like read() but the argument must be a file-like object. The f' argument must be iterable, returning one line at a time. Optional second argument is the source\u2019 specifying the name of the file being read. If not given, it is taken from f.name. If f' has no name\u2019 attribute, `???\u2019 is used. obj . read_string ( self , string , source = '<string>' ) \u00b6 Read configuration from a given string. obj . readfp ( self , fp , filename = None ) \u00b6 Deprecated, use read_file instead. obj . remove_option ( self , section , option ) \u00b6 Remove an option. obj . remove_section ( self , section ) \u00b6 Remove a file section. obj . sections ( self ) \u00b6 Return a list of section names, excluding [DEFAULT] obj . set ( self , section , option , value = None ) \u00b6 Set an option. obj . setdefault ( self , key , default = None ) \u00b6 D.setdefault(k[,d]) - D.get(k,d), also set D[k]=d if k not in D obj . values ( self ) \u00b6 D.values() - an object providing a view on D\u2019s values obj . write ( self , fp , space_around_delimiters = True ) \u00b6 Write an .ini-format representation of the configuration state. If `space_around_delimiters\u2019 is True (the default), delimiters between keys and values are surrounded by spaces. obj . default_section class \u2018NoneType\u2019 default: None \u00b6 RawConfigParser . update ( * args , ** kwds ) \u00b6 D.update([E, ]**F) - None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v RawConfigParser . BOOLEAN_STATES class \u2018dict\u2019 default: None \u00b6 RawConfigParser . NONSPACECRE class \u2018re.Pattern\u2019 default: None \u00b6 RawConfigParser . OPTCRE class \u2018re.Pattern\u2019 default: None \u00b6 RawConfigParser . OPTCRE_NV class \u2018re.Pattern\u2019 default: None \u00b6 RawConfigParser . SECTCRE class \u2018re.Pattern\u2019 default: None \u00b6 RawConfigParser . converters class \u2018property\u2019 default: None \u00b6 SafeConfigParser class \u00b6 ConfigParser alias for backwards compatibility purposes. Base Classes: Container, Iterable, Sized, Collection, Mapping, MutableMapping, RawConfigParser, ConfigParser Magic Methods: __init__ Instance Methods: add_section clear defaults get getboolean getfloat getint has_option has_section items keys options optionxform pop popitem read read_dict read_file read_string readfp remove_option remove_section sections set setdefault values write Class/Static Methods: update Class/Static Attributes: BOOLEAN_STATES NONSPACECRE OPTCRE OPTCRE_NV SECTCRE converters SafeConfigParser ( * args , ** kwargs ) \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . add_section ( self , section ) \u00b6 Create a new section in the configuration. Extends RawConfigParser.add_section by validating if the section name is a string. obj . clear ( self ) \u00b6 D.clear() - None. Remove all items from D. obj . defaults ( self ) \u00b6 obj . get ( self , section , option , * , raw = False , vars = None , fallback =< object object at 0x01434920 > ) \u00b6 Get an option value for a given section. If vars' is provided, it must be a dictionary. The option is looked up in vars\u2019 (if provided), section', and in DEFAULTSECT\u2019 in that order. If the key is not found and fallback' is provided, it is used as a fallback value. None\u2019 can be provided as a `fallback\u2019 value. If interpolation is enabled and the optional argument `raw\u2019 is False, all interpolations are expanded in the return values. Arguments raw', vars\u2019, and `fallback\u2019 are keyword only. The section DEFAULT is special. obj . getboolean ( self , section , option , * , raw = False , vars = None , fallback =< object object at 0x01434920 > , ** kwargs ) \u00b6 obj . getfloat ( self , section , option , * , raw = False , vars = None , fallback =< object object at 0x01434920 > , ** kwargs ) \u00b6 obj . getint ( self , section , option , * , raw = False , vars = None , fallback =< object object at 0x01434920 > , ** kwargs ) \u00b6 obj . has_option ( self , section , option ) \u00b6 Check for the existence of a given option in a given section. If the specified section' is None or an empty string, DEFAULT is assumed. If the specified section\u2019 does not exist, returns False. obj . has_section ( self , section ) \u00b6 Indicate whether the named section is present in the configuration. The DEFAULT section is not acknowledged. obj . items ( self , section =< object object at 0x01434920 > , raw = False , vars = None ) \u00b6 Return a list of (name, value) tuples for each option in a section. All % interpolations are expanded in the return values, based on the defaults passed into the constructor, unless the optional argument raw' is true. Additional substitutions may be provided using the vars\u2019 argument, which must be a dictionary whose contents overrides any pre-existing defaults. The section DEFAULT is special. obj . keys ( self ) \u00b6 D.keys() - a set-like object providing a view on D\u2019s keys obj . options ( self , section ) \u00b6 Return a list of option names for the given section name. obj . optionxform ( self , optionstr ) \u00b6 obj . pop ( self , key , default =< object object at 0x01434098 > ) \u00b6 D.pop(k[,d]) - v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. obj . popitem ( self ) \u00b6 Remove a section from the parser and return it as a (section_name, section_proxy) tuple. If no section is present, raise KeyError. The section DEFAULT is never returned because it cannot be removed. obj . read ( self , filenames , encoding = None ) \u00b6 Read and parse a filename or an iterable of filenames. Files that cannot be opened are silently ignored; this is designed so that you can specify an iterable of potential configuration file locations (e.g. current directory, user\u2019s home directory, systemwide directory), and all existing configuration files in the iterable will be read. A single filename may also be given. Return list of successfully read files. obj . read_dict ( self , dictionary , source = '<dict>' ) \u00b6 Read configuration from a dictionary. Keys are section names, values are dictionaries with keys and values that should be present in the section. If the used dictionary type preserves order, sections and their keys will be added in order. All types held in the dictionary are converted to strings during reading, including section names, option names and keys. Optional second argument is the `source\u2019 specifying the name of the dictionary being read. obj . read_file ( self , f , source = None ) \u00b6 Like read() but the argument must be a file-like object. The f' argument must be iterable, returning one line at a time. Optional second argument is the source\u2019 specifying the name of the file being read. If not given, it is taken from f.name. If f' has no name\u2019 attribute, `???\u2019 is used. obj . read_string ( self , string , source = '<string>' ) \u00b6 Read configuration from a given string. obj . readfp ( self , fp , filename = None ) \u00b6 Deprecated, use read_file instead. obj . remove_option ( self , section , option ) \u00b6 Remove an option. obj . remove_section ( self , section ) \u00b6 Remove a file section. obj . sections ( self ) \u00b6 Return a list of section names, excluding [DEFAULT] obj . set ( self , section , option , value = None ) \u00b6 Set an option. Extends RawConfigParser.set by validating type and interpolation syntax on the value. obj . setdefault ( self , key , default = None ) \u00b6 D.setdefault(k[,d]) - D.get(k,d), also set D[k]=d if k not in D obj . values ( self ) \u00b6 D.values() - an object providing a view on D\u2019s values obj . write ( self , fp , space_around_delimiters = True ) \u00b6 Write an .ini-format representation of the configuration state. If `space_around_delimiters\u2019 is True (the default), delimiters between keys and values are surrounded by spaces. SafeConfigParser . update ( * args , ** kwds ) \u00b6 D.update([E, ]**F) - None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v SafeConfigParser . BOOLEAN_STATES class \u2018dict\u2019 default: {\u20181\u2019: True, \u2018yes\u2019: True, \u2018true\u2019: True, \u2018on\u2019: True, \u20180\u2019: False, \u2018no\u2019: False, \u2018false\u2019: False, \u2018off\u2019: False} \u00b6 SafeConfigParser . NONSPACECRE class \u2018re.Pattern\u2019 default: re.compile(\u2018\\S\u2019) \u00b6 SafeConfigParser . OPTCRE class \u2018re.Pattern\u2019 default: re.compile(\u2018\\n (?Poption. ?) # very permissive!\\n \\s (?Pvi=|:)\\s # any number of space/tab,\\n # followed by any of t, re.VERBOSE)* \u00b6 SafeConfigParser . OPTCRE_NV class \u2018re.Pattern\u2019 default: re.compile(\u2018\\n (?Poption. ?) # very permissive!\\n \\s (?: # any number of space/tab,\\n (?Pvi=|:)\\s # optionally followed , re.VERBOSE)* \u00b6 SafeConfigParser . SECTCRE class \u2018re.Pattern\u2019 default: re.compile(\u2018\\n \\[ # [\\n (?Pheader[^]]+) # very permissive!\\n \\] # ]\\n \u2018, re.VERBOSE) \u00b6 SafeConfigParser . converters class \u2018property\u2019 default: configparser.ConverterMapping object at 0x048A8650 \u00b6 WindowsExeVersionInfo class \u00b6 Base Classes: PlasticFile Magic Methods: __init__ Instance Methods: copyright debug fromLines injectLine internalName path read remove toLines version write Instance Attributes: major minor micro build companyName productName description exeName Class/Static Methods: defaultPath WindowsExeVersionInfo () \u00b6 Initialize self. See help(type(self)) for accurate signature. obj . copyright ( self ) \u00b6 obj . debug ( self ) \u00b6 obj . fromLines ( self , lines ) \u00b6 obj . injectLine ( self , injection , lineNo ) \u00b6 obj . internalName ( self ) \u00b6 obj . path ( self ) \u00b6 obj . read ( self ) \u00b6 obj . remove ( self ) \u00b6 obj . toLines ( self ) \u00b6 obj . version ( self , isCommaDelim = False ) \u00b6 obj . write ( self ) \u00b6 obj . major class \u2018int\u2019 default: 0 \u00b6 obj . minor class \u2018int\u2019 default: 0 \u00b6 obj . micro class \u2018int\u2019 default: 0 \u00b6 obj . build class \u2018int\u2019 default: 0 \u00b6 obj . companyName class \u2018str\u2019 default: \u201c<empty string>\u201c \u00b6 obj . productName class \u2018str\u2019 default: \u201c<empty string>\u201c \u00b6 obj . description class \u2018str\u2019 default: \u201c<empty string>\u201c \u00b6 obj . exeName class \u2018str\u2019 default: \u201c<empty string>\u201c \u00b6 WindowsExeVersionInfo . defaultPath () \u00b6","title":"Utility Classes"},{"location":"Utility%20Classes.html#ConfigParser","text":"ConfigParser implementing interpolation. Base Classes: Container, Iterable, Sized, Collection, Mapping, MutableMapping, RawConfigParser Instance Methods: add_section clear defaults get getboolean getfloat getint has_option has_section items keys options optionxform pop popitem read read_dict read_file read_string readfp remove_option remove_section sections set setdefault values write Class/Static Methods: update Class/Static Attributes: BOOLEAN_STATES NONSPACECRE OPTCRE OPTCRE_NV SECTCRE converters","title":"ConfigParser"},{"location":"Utility%20Classes.html#ExecutableScript","text":"Magic Methods: __init__ Instance Methods: asSnippet debug exists fileName filePath fromBase64 fromLines injectLine read remove toBase64 toLines write Instance Attributes: rootName scriptDirPath replacements isIfwVarEscapeBackslash isDebug Class/Static Methods: linesToStr strToLines typeOf Class/Static Attributes: APPLESCRIPT_EXT BATCH_EXT JSCRIPT_EXT POWERSHELL_EXT SHELL_EXT SUPPORTED_EXTS VBSCRIPT_EXT","title":"ExecutableScript"},{"location":"Utility%20Classes.html#RawConfigParser","text":"ConfigParser that does not do interpolation. Base Classes: Container, Iterable, Sized, Collection, Mapping, MutableMapping Magic Methods: __init__ Instance Methods: add_section clear defaults get getboolean getfloat getint has_option has_section items keys options optionxform pop popitem read read_dict read_file read_string readfp remove_option remove_section sections set setdefault values write Instance Attributes: default_section Class/Static Methods: update Class/Static Attributes: BOOLEAN_STATES NONSPACECRE OPTCRE OPTCRE_NV SECTCRE converters","title":"RawConfigParser"},{"location":"Utility%20Classes.html#SafeConfigParser","text":"ConfigParser alias for backwards compatibility purposes. Base Classes: Container, Iterable, Sized, Collection, Mapping, MutableMapping, RawConfigParser, ConfigParser Magic Methods: __init__ Instance Methods: add_section clear defaults get getboolean getfloat getint has_option has_section items keys options optionxform pop popitem read read_dict read_file read_string readfp remove_option remove_section sections set setdefault values write Class/Static Methods: update Class/Static Attributes: BOOLEAN_STATES NONSPACECRE OPTCRE OPTCRE_NV SECTCRE converters","title":"SafeConfigParser"},{"location":"Utility%20Classes.html#WindowsExeVersionInfo","text":"Base Classes: PlasticFile Magic Methods: __init__ Instance Methods: copyright debug fromLines injectLine internalName path read remove toLines version write Instance Attributes: major minor micro build companyName productName description exeName Class/Static Methods: defaultPath","title":"WindowsExeVersionInfo"},{"location":"Utility%20Constants.html","text":"ALL class \u2018str\u2019 default: \u201c \u201d* \u00b6 ALL_USERS class \u2018int\u2019 default: 1 \u00b6 BIT_CONTEXT class \u2018int\u2019 default: 32 \u00b6 CURRENT_USER class \u2018int\u2019 default: 2 \u00b6 DEBUG_ENV_VAR_NAME class \u2018str\u2019 default: \u201cDEBUG_MODE\u201d \u00b6 DEBUG_ENV_VAR_VALUE class \u2018str\u2019 default: \u201c1\u201d \u00b6 IS_32_BIT_CONTEXT class \u2018bool\u2019 default: True \u00b6 IS_64_BIT_CONTEXT class \u2018bool\u2019 default: False \u00b6 IS_ARM_CPU class \u2018bool\u2019 default: False \u00b6 IS_INTEL_CPU class \u2018bool\u2019 default: True \u00b6 IS_LINUX class \u2018bool\u2019 default: <Platform dependent> \u00b6 Determine if build process is being run on Linux. IS_MACOS class \u2018bool\u2019 default: <Platform dependent> \u00b6 Determine if build process is being run on macOS. IS_WINDOWS class \u2018bool\u2019 default: <Platform dependent> \u00b6 Determine if build process is being run on Windows. PY2 class \u2018bool\u2019 default: False \u00b6 PY3 class \u2018bool\u2019 default: True \u00b6 THIS_DIR class \u2018str\u2019 default: \u201cC:\\Python37\\Scripts\u201d \u00b6","title":"Utility Constants"},{"location":"Utility%20Functions.html","text":"absPath ( relativePath , basePath = None ) \u00b6 allPathPattern ( basePath ) \u00b6 assertMinVer ( ver , minVer , parts = 4 , partLen = 3 , descr = None ) \u00b6 collectDirs ( srcDirPaths , destDirPath ) \u00b6 Move a list of directories into a common parent directory containsPathPattern ( match , basePath = None ) \u00b6 copyExeIcon ( srcExePath , destExePath , iconName = None ) \u00b6 copyExeVerInfo ( srcExePath , destExePath ) \u00b6 copyToDesktop ( path ) \u00b6 copyToDir ( srcPaths , destDirPath = None ) \u00b6 Copy files OR directories to a given destination. The argument srcPaths may be a singular path (i.e. a string) or an iterable (i.e. a list or tuple). copyToHomeDir ( path ) \u00b6 delEnv ( varName ) \u00b6 desktopPath ( relPath = None ) \u00b6 download ( url , saveToPath = None , preserveName = True ) \u00b6 embedAutoElevation ( exePath ) \u00b6 embedExeIcon ( exePath , iconPath ) \u00b6 embedExeVerInfo ( exePath , exeVerInfo ) \u00b6 embedManifest ( exePath , manifestPath ) \u00b6 endsWithPathPattern ( match , basePath = None ) \u00b6 exists ( path ) \u00b6 Test whether a path exists. Returns False for broken symbolic links extPathPattern ( ext , basePath = None ) \u00b6 extractExeIcons ( srcExePath , destDirPath ) \u00b6 getEnv ( varName , default = None ) \u00b6 getPassword ( isGuiPrompt = False ) \u00b6 halt () \u00b6 homePath ( relPath = None ) \u00b6 importFromPath ( path , memberName = None ) \u00b6 isDebug () \u00b6 isDir ( path ) \u00b6 isFile ( path ) \u00b6 isImportableFromModule ( moduleName , memberName ) \u00b6 isImportableModule ( moduleName ) \u00b6 isParentDir ( parent , child , basePath = None ) \u00b6 joinExt ( rootName , extension = None ) \u00b6 mergeDirs ( srcDirPaths , destDirPath , isRecursive = True ) \u00b6 modulePackagePath ( moduleName ) \u00b6 modulePath ( moduleName ) \u00b6 move ( src , dst , copy_function =< function copy2 at 0x022FE858 > ) \u00b6 Recursively move a file or directory to another location. This is similar to the Unix \u201cmv\u201d command. Return the file or directory\u2019s destination. If the destination is a directory or a symlink to a directory, the source is moved inside the directory. The destination path must not already exist. If the destination already exists but is not a directory, it may be overwritten depending on os.rename() semantics. If the destination is on our current filesystem, then rename() is used. Otherwise, src is copied to the destination and then removed. Symlinks are recreated under the new name if os.rename() fails because of cross filesystem renames. The optional copy_function argument is a callable that will be used to copy the source or it will be delegated to copytree . By default, copy2() is used, but any function that supports the same signature (like copy()) can be used. A lot more could be done here\u2026 A look at a mv.c shows a lot of the issues this implementation glosses over. moveToDesktop ( path ) \u00b6 moveToDir ( srcPaths , destDirPath = None ) \u00b6 Move files OR directories to a given destination. The argument srcPaths may be a singular path (i.e. a string) or an iterable (i.e. a list or tuple). moveToHomeDir ( path ) \u00b6 normBinaryName ( path , isPathPreserved = False , isGui = False ) \u00b6 normConfigName ( path , isPathPreserved = False ) \u00b6 normIconName ( path , isPathPreserved = False ) \u00b6 normLibName ( path , isPathPreserved = False ) \u00b6 printErr ( msg , isFatal = False ) \u00b6 printExc ( e , isDetailed = False , isFatal = False ) \u00b6 removeFromDir ( subPaths , parentDirPath = None ) \u00b6 Removes files OR directories from a given directory. The argument subPaths may be a singular path (i.e. a string) or an iterable collection (i.e. a list or tuple). renameInDir ( namePairs , parentDirPath = None ) \u00b6 Renames files OR directories in a given destination. The argument namePairs may be a singular tuple (oldName, newName) or an iterable (i.e. a list or tuple) of such tuple pairs. reserveTempFilePath ( suffix = '' , isSplitRet = False ) \u00b6 rootFileName ( path ) \u00b6 run ( binPath , args = None , wrkDir = None , isElevated = False , isDebug = False , askpassPath = None ) \u00b6 runPy ( pyPath , args = None , isElevated = False , askpassPath = None ) \u00b6 setEnv ( varName , value ) \u00b6 sitePackagePath ( packageName ) \u00b6 startsWithPathPattern ( match , basePath = None ) \u00b6 tempDirPath () \u00b6 toCabFile ( sourceDir , cabDest = None , removeScr = True , isWrapperDirIncluded = False ) \u00b6 toNativePath ( path ) \u00b6 toZipFile ( sourceDir , zipDest = None , removeScr = True , isWrapperDirIncluded = False ) \u00b6 versionNo ( ver , parts = 4 , partLen = 3 ) \u00b6 versionStr ( ver , parts = 4 ) \u00b6 versionTuple ( ver , parts = 4 ) \u00b6","title":"Utility Functions"}]}