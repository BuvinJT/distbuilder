from distbuilder import util    # @UnusedImport
from distbuilder.util import * # @UnusedWildImport

from distbuilder.py_installer import (
      pyScriptToExe 
    , makePyInstSpec 
    , PyInstallerConfig 
    , PyInstSpec 
)

from distbuilder.iexpress import (
      IExpressConfig 
    , _scriptToExe 
)

from distbuilder.opy_library import (
      obfuscatePy 
    , OpyConfigExt as OpyConfig
)    
    
from distbuilder.qt_installer import(
      _stageInstallerPackages 
    , _buildInstaller 
    , joinPathQtIfw 
    , QtIfwConfig 
    , QtIfwConfigXml 
    , QtIfwControlScript 
    , QtIfwPackage 
    , QtIfwPackageXml 
    , QtIfwPackageScript 
    , QtIfwShortcut 
    , QtIfwExeWrapper 
    , QtIfwExternalOp 
    , _QtIfwScript 
    , DEFAULT_SETUP_NAME 
    , DEFAULT_QT_IFW_SCRIPT_NAME 
    , QT_IFW_VERBOSE_SWITCH 
    , QT_IFW_SILENT_DEBUG_SWITCH 
    , _DEBUG_SCRIPTS_ARGS 
    , QT_IFW_TARGET_DIR 
    , _SILENT_FORCED_ARGS 
    , _LOUD_FORCED_ARGS 
)

# -----------------------------------------------------------------------------       
class ConfigFactory:
    """It is typical for a build script to start by creating a high-level 
    [ConfigFactory](Config-Factory.md) object and set its attributes.

    The primary functions within this library rely upon a collection of 
    "configuration" objects which act as "smart  parameter sets".  
    Those parameters are used to drive various processes.  
    Many of these config classes have overlapping attributes. 
    Scripts which employ a collection of those low levels objects in the 
    raw tend to include a lot of tedious and redundant assignment operations.  
    With this in mind, the ConfigFactory class was created, to radically 
    simplify many scripts.

    See [Configuration Classes](ConfigClasses.md#configuration-classes) for more 
    information on the types of objects generated by this factory class.  
    
    Note that this class is NOT intended to have a one-to-one correspondence 
    for **every** attribute within all of the configuration objects it can generate.
    If that were provided, this class would become an overwhelmingly bloated monster! 
    Only the more commonly needed (and/or shared) attributes are provided on this level.  You 
    must manipulate those config objects generated by the factory *directly* if you need to 
    access their more extended features.  Typically, you will want to access those
    objects from a "callback" function within a derived "Process" class implementation.        
    """   
    
    @staticmethod
    def copy( instance ): return deepcopy( instance )

    def __init__( self, cfgId=None ) :
        self.cfgId = cfgId
        """Useful to distinguish between multiple ConfigFactory objects, as
        are often employed by a [RobustInstallerProcess](#robustinstallerprocess)."""
        
        self.productName = None
        """The name for the product on the whole, or a sub component
        within it (based upon the context of how the factory object is used).  Such
        will appear as "brandings" upon a [Stand Alone Executable](LowLevel.md#stand-alone-executables) 
        and/or as labels/details within [Installer](LowLevel.md#installers) menus."""        
        self.description = None
        """The description for the product on the whole, or a sub component
        within it (based upon the context of how the factory object is used). Such
        will appear as "brandings" upon a [Stand Alone Executable](LowLevel.md#stand-alone-executables) 
        and/or as labels/details within [Installer](LowLevel.md#installers) menus."""
        
        self.companyTradeName = None
        """Akin to `productName` and `description` attributes.  
        
        Note the `companyTradeName` will be used in standard labels, directory names, shortcuts, etc.
        produced by the process employing the ConfigFactory.  In contrast, `companyLegalName`
        will appear within copyrights, EULAs, and the like where an "official" / legal name is 
        called for."""
        self.companyLegalName = None      
        """Akin to `productName` and `description` attributes.  
        
        Note the `companyTradeName` will be used in standard labels, directory names, shortcuts, etc.
        produced by the process employing the ConfigFactory.  In contrast, `companyLegalName`
        will appear within copyrights, EULAs, and the like where an "official" / legal name is 
        called for."""

        self.version       = (0,0,0,0)
        """Akin to `productName` and `description` attributes, this can be applied to
        either a [Stand Alone Executable](LowLevel.md#stand-alone-executables) 
        or an [Installer](LowLevel.md#installers) based on the context of what uses
        the config factory.
        
        A version should be defined as a 4 part tuple of unsigned integers, in the form:

        <tab>( MAJOR, MINOR, PATCH, BUILD )
        
        Alternatively, a string representation may be supplied.
        See [versionTuple, versionStr](LowLevel.md#versiontuple,-versionstr).
        
        Note that each part maybe any number of digits long.  i.e. this is a perfectly 
        valid version stamp: `2.11.6.139`.  That example would be denoted in tuple form 
        as: `(2,11,6,139)`"""

        self.isGui         = False
        """This is attribute used for a variety of purposes, which would be difficult to 
        list here. Perhaps most notably, it is applied directly to the production of  
        [Stand Alone Executables](LowLevel.md#stand-alone-executables)."""             
        self.binaryName    = None     
        """This is attribute used for a variety of purposes, which would be difficult to 
        list here. Perhaps most notably, it is applied directly to the production of  
        [Stand Alone Executables](LowLevel.md#stand-alone-executables)."""             
        
        self.sourceDir     = None   
        """This attribute is used to resolve relative paths to absolute paths in various 
        contexts. When omitted, such paths are normally resolved relative to the directory 
        containing the build script (NOT the current working directory!)."""           
        
        self.iconFilePath  = None
        """Based upon context, this attribute is used to embedded (or bundle) an icon for
        a [Stand Alone Executable](LowLevel.md#stand-alone-executables) or an
        [Installer](LowLevel.md#installers). 
        
        As demoed in the [Hello World Example](Examples.md#hello-world-example),
        on Windows you must use a ".ico" file, on macOS a ".icns", or on Linux a ".png".
        You do NOT have to specify the extension, however, when setting this attribute.
        Such will be automatically determined per the platform at runtime. 
        """
        
        # PyInstaller
        self.entryPointPy  = None           
        """This attribute is most notably used when producing a 
        [Stand Alone Executable](LowLevel.md#stand-alone-executables).
        In that context, it points PyInstaller to the starting point for the source 
        from which to build a binary.
        
        This is also used during an [Executable Obfuscation](LowLevel.md#executable-obfuscation)
        process.  The entry point module **name** is **not** obfuscated (though its contents are). 
        """    
        self.specFilePath  = None
        """This attribute is a relatively sophisticated component used for   
        producing a given [Stand Alone Executable](LowLevel.md#stand-alone-executables).
        Most users of this library will never need to use this, though some may
        wish to if they are migrating from a legacy build script which employed
        a PyInstaller "spec file" they maintained.
        
        This attribute is a means to specify a relative file path to an existing 
        "spec" file. 
        
        Note that distbuilder provides a [PyInstSpec](ConfigClasses.md#pyinstspec)
        class which allows for programmatic generation and manipulation of such
        files and configurations.  Also, many of the process classes which employ a 
        config factory provide an `onMakeSpec( spec )` function.  And, if writing your 
        own low level equivalents of the process class operations, the library provides
        an [makePyInstSpec](LowLevel.md#makePyInstSpec) function.
        """        
        self.isOneFile     = True # this differs from the PyInstaller default
        """This switch controls a notable PyInstaller feature, i.e. bundling dependencies
        into a single (compressed) exe when creating a 
        [Stand Alone Executable](LowLevel.md#stand-alone-executables) vs leaving the 
        dependencies outside of the exe.  Unlike PyInstaller, this library wrapper 
        defaults to employing the single file feature. That produces a more "clean", streamlined, product which appears (on the surface) nearly identical across 
        build environments - including cross platform.  But, this comes at the expense
        of slowing down the launching of an executable.  
        
        We recommend using the one file option for "small" programs, or ones which will
        not likely be opened very often.  Set this to `False`, however, to boost 
        a program's performance as far as load time is concerned. 
        """

        # Other Script to Binary sources 
        self.entryPointScript = None
        """This attribute is used when producing a 
        [Stand Alone Executable](LowLevel.md#stand-alone-executables) 
        via an implementation of *IExpress*. Using this mechanism, you may convert a program written in a native Windows 
        script (currently supporting Batch, PowerShell, VBScript, and JScript), into a
        binary executable. 
        
        For more information on *IExpress*, see:
        
        https://en.wikipedia.org/wiki/IExpress
        https://docs.microsoft.com/en-us/internet-explorer/ie11-ieak/iexpress-wizard-for-win-server
        https://ss64.com/nt/iexpress.html
        http://www.mdgx.com/INF_web/
        
        
        Note this argument may be simple file path, pointing to source script, 
        or an object of type [ExecutableScript](LowLevel.md#executablescript).
        
        When using an `ExecutableScript`, a "script header" will automatically be 
        injected.  This header modifies the context so that the implied working
        directory will be where the exe's is launched from.  Without this code, 
        the script will run from a (pseudo random) temporary location.  
        This is a critical detail when resources are bundled with the program. 
        Additionally the header provides the following global variables 
        (which are named identically across the supported scripting languages):
        `PID`, `PPID`, `EXE_PATH`, `THIS_DIR`, `LIB_DIR`, `RES_DIR`        
       """
       
        # Basic resource bundling
        self.distResources = []
        """The `distResources` attribute is an optional list of external resources to bundle 
        into the distribution package.  You may use a simple list of strings containing 
        file/directory names or paths *relative* to the build script directory. Else, you 
        may provide a list of two element tuples, with a specific source and destination. 
        In addition, source paths may be specified with globing *wildcards* if desired.  
        They may even include environmental variables or path symbols.
        See **distResources** within [pyScriptToExe](LowLevel.md#pyscripttoexe) for
        more details on this.
            
        Notably, this attribute is used when generating a 
        [PyInstallerConfig](ConfigClasses.md#pyinstconfig)
        object when invoking the `pyInstallerConfig()` function for this class, 
        and then ultimately invoking the low level 
        [pyScriptToExe](LowLevel.md#pyscripttoexe) operation with that.
        Note this may be done for you via various high level process classes.
        
        This attribute is also used for producing a
        [QtIfwPackage](ConfigClasses.md#qtifwpackage) object when invoking the
        `qtIfwPackage()` function for this class.
        This too may be done for you via various high level process classes.
        """
        # Python Obfuscation
        self.isObfuscating = False        
        """The `isObfuscating` switch toggles whether code obfuscation is employed by a process
        using the config factory (based upon context)."""        
        self.opyBundleLibs = None
        """The `opyBundleLibs` and `opyPatches` are details used for generating an 
        [OpyConfig](ConfigClasses.md#opyconfig) object when invoking the `opyConfig()`
        function for this class.
        For more information, refer to the following:        
        - [Executable Obfuscation](LowLevel.md#executable-obfuscation)  
        - [Obfuscation Features](LowLevel.md#obfuscation-features)  
        - [Hello World Tk Example](Examples.md#hello-world-tk-example)    
        - [Opy for Distribution Builder](https://pypi.org/project/opy-distbuilder/)
        """
        self.opyPatches    = None
        """The `opyBundleLibs` and `opyPatches` are details used for generating an 
        [OpyConfig](ConfigClasses.md#opyconfig) object when invoking the `opyConfig()`
        function for this class."""
        
        # For Installers: applied via "master" factories        
        self.isSilentSetup = False
        """When `isSilentSetup` is enabled, the QtIFW installer produced will not display a GUI or 
        provide any interactive prompts for the user.  All options are dictated by command line 
        arguments. While this may certainly be desirable on any platform, it is  
        *necessary* to create an installer for a target OS with no GUI (e.g. many Linux distros).
        
        For more information refer to: 
        
        - [buildInstaller](LowLevel.md#buildInstaller)
        - [Silent Installers](LowLevel.md#silent-installers)
        - [Hello Silent Example](Examples.md#hello-silent-example)        
        """
        self.setupName     = DEFAULT_SETUP_NAME
        """This is the file name given to a QtIFW installer when the config factory is used in a 
        context to produce one. This attribute is specifically applied when generating a 
        [QtIfwConfig](ConfigClasses.md#qtifwconfig) object upon invoking the `qtIfwConfig()`
        function for this class.
        """
        
        self.ifwDefDirPath = None    
        """When producing a QtIFW installer this attribute may *optionally* be used to specify 
        an external, hard coded definition for the installer.  This is useful when either 
        integrating the distbuilder library with an existing QtIFW installer, or when a 
        developer would prefer to use the traditional QtIFW approach (perhaps due to extensive 
        customizations).    
        
        Note: This hard coded definition may include target installation content, and it 
        may be used as a **partial** definition or **hybrid** with distbuilder manipulations 
        and additions applied to it.    
        
        This attribute is specifically applied when generating a 
        [QtIfwConfig](ConfigClasses.md#qtifwconfig) object upon invoking the `qtIfwConfig()`
        function for this class.
        """    
        self.ifwPackages   = None
        """When producing a QtIFW installer, this attribute maybe used to list of "Qt IFW Packages".
        Items in this list may be dynamic [QtIfwPackage](ConfigClasses.md#qtifwpackage) objects,
        or be simple strings defining relative paths to QtIFW packages which are defined
        as external resources, in the traditional (hard coded, content containing) IFW manner.
        
        When building Python only derived installers, this attribute will be set automatically 
        by a process class, and *NOT* have to be manually defined or manipulated unless 
        there is a need to merge or modify packages pro grammatically.      
        
        This attribute is specifically applied when upon invoking the `qtIfwPackage()`
        function for this class.
        
        For more information refer to: 
        
        - [RobustInstallerProcess](#robustinstallerprocess)
        - [QtIfwPackage list manipulation](LowLevel.md#qtifwpackage-list-manipulation) 
        """
         
        self.isLimitedMaintenance = True
        """When producing a QtIFW installer, when this attribute is set to `True` (the 
        default) the "maintenance tool" included with the distribution will not display
        an introduction page with the options to add, remove, or update components.
        It will only allow for uninstallation.  The extended options are only naturally
        functional within QtIFW in the context of an **online** installer, which is 
        not the default product of this library, and thus the selection of these radio 
        buttons only produce errors.  Further, having this limitation imposed 
        simplifies both the end user workflow and the developer's coding / testing tasks.  
        
        When building an online installer, you may wish to enable the extended 
        features, by disabling this switch.    
        """
        self.replaceTarget = False # TODO: Fix this, or drop it!
        """When producing a QtIFW installer, switch this attribute to `True` if you wish for the
        installer to automatically replace a prior installation.  On Windows, this will reference
        the applications registered in the OS, and run the uninstallation for the prior install
        via that mechanism.  On other platforms, this uses the QtIFW Maintenance Tool directly to 
        "silently" uninstall a prior install found at the target location.
        """
        
        self.ifwWizardStyle    = None
        """QtIFW installer predefined visual style.
          
        - QtIfwConfigXml.DEFAULT_WIZARD_STYLE <per platform>        
        - QtIfwConfigXml.WizardStyle.AERO     <Windows Default>    
        - QtIfwConfigXml.WizardStyle.MAC      <MacOS Default>
        - QtIfwConfigXml.WizardStyle.MODERN   <Linux Default>
        - QtIfwConfigXml.WizardStyle.CLASSIC  <Simliar to MODERN>  
        """
        self.ifwLogoFilePath   = None
        """Relative or absolute path to QtIFW installer image resources.  These should .png 
        files (on any platform).  Transparency is supported.
                
        > Note: this is only applied in MODERN or CLASSIC style installers.   
        """
        self.ifwBannerFilePath = None
        """Relative or absolute path to QtIFW installer image resources.  These should .png 
        files (on any platform).  Transparency is supported.
                
        > Note: this is only applied in MODERN style installers.   
        """
                
        self.licensePath = None   
        """Relative or absolute path to a license file to be included in an installer, which the 
        end user will be required to agree to.        
        """     
        self.ifwUiPages  = None
        """Use this to specify a list of [QtIfwUiPage](ConfigClasses.md#qtifwuipage) 
        objects.  With that, you may fully customize the installer's UI using the
        [Qt Designer WYSIWYG](https://doc.qt.io/qt-5/designer-quick-start.html) tool!
        
        [Installer Scripting](LowLevel.md#installer-scripting), or the higher level
        script abstraction classes [QtIfwControlScript](ConfigClasses.md#qtifwcontrolscript) and
        [QtIfwPackageScript](ConfigClasses.md#qtifwpackagescript) can be used to provide
        dynamic features for the page. 
        """
        self.ifwWidgets  = None                    
        
        self.ifwCntrlScript     = None # None=Default False=Exclude        
        """QtIFW installers may have a "Control Script" and/or a collection of "Package Scripts".
        The "Control Script" is intended to dictate how the installer *interface*  behaves, and
        other high level logic pertaining to the installer itself. In contrast, "Package Scripts"
        are intended for applying custom logic to manipulate a target environment when installing 
        a given package.
        
        These "Control Script" attributes are specifically applied when invoking the 
        `qtIfwControlScript()` function for this class.
        
        The attributes `ifwCntrlScript`, `ifwCntrlScriptText`, `ifwCntrlScriptPath` are mutually
        exclusive.  Only one will be applied (the others such be set to `None`), with the 
        priority being in that order. 
        
        The `ifwCntrlScript` attribute is a [QtIfwControlScript](ConfigClasses.md#qtifwcontrolscript)     
        object.
        
        The `ifwCntrlScriptText` attribute is a means to supply the script as a raw string.
        
        The `ifwCntrlScriptPath` is a file path (relative to the build script) to an externally 
        defined script.
        
        `ifwCntrlScriptName` provides a means to define the name of the file generated, in case 
        there is need or desire to override the default.         
        """        
        self.ifwCntrlScriptText = None
        self.ifwCntrlScriptPath = None
        self.ifwCntrlScriptName = DEFAULT_QT_IFW_SCRIPT_NAME

        # These are used for direct package generation via the factory,
        # to then be added to a process.  Most typically, this is for non
        # Python packages.
        self.ifwPkgId         = None
        """`ifwPkgId` is employed for distbuilder operations where multiple packages are
        involved. For more information refer to: 
        
        [QtIfwPackage list manipulation](LowLevel.md#qtifwpackage-list-manipulation)             
        """
        self.ifwPkgName       = None
        """This attribute is utilized to differentiate [QtIfwPackage](ConfigClasses.md#qtifwpackage) 
        objects, and the packages which are produced for an installer.
        
        [RobustInstallerProcess](#robustinstallerprocess). 
                
        `ifwPkgName` and `ifwPkgNamePrefix` are provided to override the name used by the
        QtInstaller for deployment on a target environment.  Normally, you may allow
        distbuilder to set the name for you automatically.
        """        
        self.ifwPkgNamePrefix = "com"        
        """This attribute is utilized to differentiate [QtIfwPackage](ConfigClasses.md#qtifwpackage) 
        objects, and the packages which are produced for an installer.
        
        [RobustInstallerProcess](#robustinstallerprocess). 
                
        `ifwPkgName` and `ifwPkgNamePrefix` are provided to override the name used by the
        QtInstaller for deployment on a target environment.  Normally, you may allow
        distbuilder to set the name for you automatically.
        """        

        self.ifwPkgIsDefault  = True
        """Simple option for controlling how the package 
        (i.e. component) will be selected by the end user of the installer.
        `ifwPkgIsDefault` will automatically select (or not select) the component by
        default.   
        """
        self.ifwPkgIsRequired = False 
        """Simple option for controlling how the package 
        (i.e. component) will be selected by the end user of the installer.
        `ifwPkgIsRequired` dictates if the user can opt out of the component.
        """
        self.ifwPkgIsHidden   = False
        """Simple option for controlling how the package 
        (i.e. component) will be selected by the end user of the installer.
        `ifwPkgIsHidden` is similar to `ifwPkgIsDefault` and `ifwPkgIsRequired`, 
        but insulates the user from even seeing the component as separate entity 
        when enabled.  
        """
                                     
        self.ifwPkgScript     = None           
        """QtIFW installers may have a "Control Script" and/or a collection of "Package Scripts".
        The "Control Script" is intended to dictate how the installer *interface*  behaves, and
        other high level logic pertaining to the installer itself. In contrast, "Package Scripts"
        are intended for applying custom logic to manipulate a target environment when installing 
        a given package.
        
        These "Package Script" attributes are specifically applied when invoking the 
        `qtIfwPackageScript()` function for this class.
        
        The attributes `ifwPkgScript`, `ifwPkgScriptText`, `ifwPkgScriptPath` are mutually
        exclusive.  Only one will be applied (the others such be set to `None`), with the 
        priority being in that order. 
        
        The `ifwPkgScript` attribute is a [QtIfwPackageScript](ConfigClasses.md#qtifwpackagescript)     
        object.
        
        The `ifwPkgScriptText` attribute is a means to supply the script as a raw string.
        
        The `ifwPkgScriptPath` is a file path (relative to the build script) to an externally 
        defined script.
        
        `ifwPkgScriptName` provides a means to define the name of the file generated, in case 
        there is need or desire to override the default.         
        """        
        self.ifwPkgScriptText = None
        self.ifwPkgScriptPath = None        
        self.ifwPkgScriptName = DEFAULT_QT_IFW_SCRIPT_NAME
        
        self.pkgType                 = None
        """This specifies the type (`QtIfwPackage.Type`) of package being built.  
        The options for this include:  
        
        - QtIfwPackage.Type.RAW
        - QtIfwPackage.Type.DATA
        - QtIfwPackage.Type.RESOURCE
        - QtIfwPackage.Type.PY_INSTALLER
        - QtIfwPackage.Type.IEXPRESS
        - QtIfwPackage.Type.QT_CPP         
    
        If this is omitted, and a `binaryName` attribute is specified, type `PY_INSTALLER` is assumed.  If this is omitted, but no `binaryName` is specified, the `DATA` type is assumed.  
        
        The `RESOURCE` type indicates that the package does not contain any "directly installed 
        content" (in the traditional sense at least).  This is to be used in situations where you 
        want to simply bundle custom installation operations / scripts as a "component".  Note, 
        however, that installer **resources** may be attached to such operations, and which are *not* 
        "directly installed content".  A notable use case where you would include a resource, 
        but no content files in a package, would be to "nest" another installer inside of the outer one.  The nested installer would be a resource, invoked by a custom operation.  
        See: 
        [QtIfwExternalResource](ConfigClasses.md#qtifwexternalresource)
        [QtIfwExternalOp](ConfigClasses.md#qtifwexternalop)   
        """
        self.pkgSubDirName           = None
        """If a `pkgSubDirName` is specified, this places the package inside of sub directory, 
        rather than having the contents there of installed directly to the top level directory
        of the target.
        
        By default, this attribute is `None`, which is ideal for single package products. 
        When multiple packages are present, however, the content of each will be merged into 
        one directory during installation (if the end user selects more than one package).  
        In the event "collisions" could occur (at installation or run time) due to this, 
        the suggested resolution is to employ this option, thereby encapsulating the package(s). 
        """
        self.pkgSrcDirPath           = None
        """When building installers that have external resources which are not part of
        automatically generated products/packages, these attributes may be used to define the paths
        to that package's content.  
        
        When the `pkgSrcDirPath` is not supplied, this is path defined 
        by either a [PyInstallerConfig](ConfigClasses.md#pyinstallerconfig) object definition,
        or assumed to simply be a sub directory adjacent to the build script
        *with the same name* as the `binaryName` attribute.
        
        The attribute `pkgSrcExePath` must only be supplied when the package contains a
        "primary" executable which was not produced by a process with the library (i.e. 
        it was complied previously by some other build system).  Note, that if `binaryName`
        is also defined, the `pkgSrcExePath` file will be renamed to that name upon building
        the package. 
        
        See: [RobustInstallerProcess](#robustinstallerprocess).         
        """
        self.pkgSrcExePath           = None
        """When building installers that have external resources which are not part of
        automatically generated products/packages, these attributes may be used to define the paths
        to that package's content.  
        
        When the `pkgSrcDirPath` is not supplied, this is path defined 
        by either a [PyInstallerConfig](ConfigClasses.md#pyinstallerconfig) object definition,
        or assumed to simply be a sub directory adjacent to the build script
        *with the same name* as the `binaryName` attribute.
        
        The attribute `pkgSrcExePath` must only be supplied when the package contains a
        "primary" executable which was not produced by a process with the library (i.e. 
        it was complied previously by some other build system).  Note, that if `binaryName`
        is also defined, the `pkgSrcExePath` file will be renamed to that name upon building
        the package. 
        
        See: [RobustInstallerProcess](#robustinstallerprocess).         
        """
        self.pkgCodeSignTargets      = None        
        
        self.pkgExeWrapper           = None 
        """A [QtIfwExeWrapper](ConfigClasses.md#qtifwexewrapper) object used to "wrap"
        the primary executable in a [QtIfwPackage](ConfigClasses.md#qtifwpackage) 
        being built using the factory provided configurations.
        
        Such a wrapper can super impose environmental conditions on the context
        within which the binary is run.  Notably, this may include an 
        [ExecutableScript](LowLevel.md#executablescript) for maximum flexibility.
        Follow the links to learn to more.        
        """
        self.pkgExternalDependencies = None # LINUX / MAC only
        """
        **MAC / LINUX Only**
        
        External packages to be installed.  This takes place prior to any 
        other installer operations, in case those operations (rather the 
        program being installed) are dependent upon such.
        
        Provide a list of either simple strings and/or nested lists of strings.
        When nesting lists, such represents alternate names to try based upon
        what is available within a given package manager on the target.  
        For example, the package "xvfb" maybe specified as `["xvfb","Xvfb"]`.  That handles the fact the "X" is capitalized 
        within some contexts (e.g. within YUM on RHEL...) but is lower case in others.
        """
        self.pkgConfigs              = None
    
        self.startOnBoot   = False
        """Enable `startOnBoot` to have the installer register the "primary" exe 
        within a package as a program to launch upon booting the system. By default,
        this is set to `False`, setting it to either `True` or to `CURRENT_USER` will have the same 
        effect.  Assign it to `ALL_USERS` to have this applied for all system users. 
        
        In Windows, this will lead to an auto implementation of a [QtIfwExeWrapper](ConfigClasses.md#qtifwexewrapper), which employs the special `isExe` feature,
        producing a "wrapper/proxy/launcher" exe adjacent to the actual one.  That 
        launcher is what will actually be registered in the OS.          
        """
       
        # code signing
        self.codeSignConfig = None

        # Configurations for specific package types               
        self.__pkgPyInstConfig = None
        self.__pkgIExpressConfig = None
        self.qtCppConfig = None
        """A [QtCppConfig](ConfigClasses.md#qtcppconfig) object.  Used to define how to
        package programs developed within the Qt C++ libraries / framework. 
        
        See the [Qt C++ Integration](QtCpp.md) document for more information.  
        """
                            
    def pyInstallerConfig( self ): 
        cfg = PyInstallerConfig()        
        cfg.name          = self.binaryName
        cfg.sourceDir     = self.sourceDir
        cfg.entryPointPy  = self.entryPointPy
        cfg.isOneFile     = self.isOneFile 
        cfg.isGui         = self.isGui
        cfg.iconFilePath  = self.iconFilePath        
        cfg.distResources = self.distResources 
        cfg.codeSignConfig   = self.codeSignConfig
        cfg.codeSignTargets  = self.pkgCodeSignTargets         
        if self.specFilePath :
            cfg.pyInstSpec = PyInstSpec( self.specFilePath )
        if IS_WINDOWS: cfg.versionInfo = self .exeVersionInfo()
        return cfg

    if IS_WINDOWS :

        def iExpressConfig( self ):        
            cfg = IExpressConfig()            
            cfg.name             = self.binaryName
            cfg.sourceDir        = self.sourceDir
            cfg.entryPointScript = self.entryPointScript
            cfg.versionInfo      = self.exeVersionInfo()
            cfg.iconFilePath     = self.iconFilePath
            cfg.distResources    = self.distResources
            cfg.codeSignConfig   = self.codeSignConfig
            cfg.codeSignTargets  = self.pkgCodeSignTargets 
            return cfg
        
        def exeVersionInfo( self, ifwConfig=None ):
            verInfo = WindowsExeVersionInfo()
            if ifwConfig:
                xml = ifwConfig.configXml
                verInfo.description = xml._titleDisplayed()        
                ( verInfo.major,
                  verInfo.minor,
                  verInfo.micro,
                  verInfo.build
                ) = versionTuple( xml.Version )
                verInfo.productName = xml.Name
                verInfo.companyName = xml.Publisher                
                verInfo.exeName     = ifwConfig.setupExeName                                            
            else:
                verInfo.description = self.description
                ( verInfo.major,
                  verInfo.minor,
                  verInfo.micro,
                  verInfo.build
                ) = self.__versionTuple()
                verInfo.productName = self.productName
                verInfo.companyName = self.companyLegalName                                
                verInfo.exeName     = self.binaryName
            return verInfo 
    
    def opyConfig( self ):
        return OpyConfig( self.binaryName, self.entryPointPy,
                          sourceDir=self.sourceDir,
                          bundleLibs=self.opyBundleLibs,
                          patches=self.opyPatches )                 
    
    def qtIfwConfig( self, packages=None ):
        if packages is not None: self.ifwPackages = packages
        configXml     = self.qtIfwConfigXml()  
        controlScript = self.qtIfwControlScript( configXml )              
        cfg = QtIfwConfig( installerDefDirPath=self.ifwDefDirPath,
                           packages=self.ifwPackages,
                           configXml=configXml, 
                           controlScript=controlScript,
                           setupExeName=self.setupName ) 
        cfg.addLicense( self.licensePath )
        cfg.addUiElements( self.ifwUiPages )
        cfg.addUiElements( self.ifwWidgets )
        cfg._scrubEmbeddedResources()        
        self.ifwPackages = cfg.packages
        return cfg 

    def qtIfwConfigXml( self ) :
        xml = QtIfwConfigXml( self.productName,  
                              self.__versionStr(), self.companyLegalName,                              
                              iconFilePath=self.iconFilePath, 
                              primaryContentExe=self.binaryName,
                              isPrimaryExeGui=self.isGui,
                              primaryExeWrapper=self.pkgExeWrapper,                               
                              companyTradeName=self.companyTradeName,
                              wizardStyle=self.ifwWizardStyle,
                              logoFilePath=self.ifwLogoFilePath,
                              bannerFilePath=self.ifwBannerFilePath
                            )
        if xml.RunProgram is None and self.ifwPackages is not None:
            xml.setPrimaryContentExe( self.ifwPackages[0] )
        return xml

    def qtIfwControlScript( self, configXml ) :
        if self.ifwCntrlScript : return self.ifwCntrlScript 
        if( self.ifwCntrlScript == False and
            self.ifwCntrlScriptText is None and 
            self.ifwCntrlScriptPath is None ):
            return None     
        script = QtIfwControlScript(
                fileName=self.ifwCntrlScriptName,
                script=self.ifwCntrlScriptText, 
                scriptPath=self.ifwCntrlScriptPath )
        
        script._wizardStyle = configXml.WizardStyle
        script.isLimitedMaintenance = self.isLimitedMaintenance 
                
        # TODO: Fix this, as it is no longer respected!
        if self.replaceTarget:
            script.virtualArgs={ _QtIfwScript.TARGET_EXISTS_OPT_CMD_ARG:
                                 _QtIfwScript.TARGET_EXISTS_OPT_REMOVE } 
        return script
    
    def qtIfwPackage( self, pyInstConfig=None, iExpressConfig=None, isTempSrc=False ):
        self.__pkgPyInstConfig = pyInstConfig        
        self.__pkgIExpressConfig = iExpressConfig
        pkgType=self.__ifwPkgType()

        if self.startOnBoot in [True, CURRENT_USER, ALL_USERS]:
            if IS_WINDOWS: 
                if self.pkgExeWrapper and not self.pkgExeWrapper.isExe:
                    self.pkgExeWrapper.isExe = True
                    self.pkgExeWrapper.refresh()
                else: self.pkgExeWrapper = self.qtIfwExeWrapper( isExe=True )        
            else: # TODO: ADD SUPPORT FOR OTHER PLATFORMS!
                util._onPlatformErr()
                    
        pkg = QtIfwPackage(
                pkgId=self.__ifwPkgId(),
                pkgType=pkgType, 
                name=self.__ifwPkgName(), 
                subDirName=self.pkgSubDirName,
                srcDirPath=self.__pkgSrcDirPath(),
                srcExePath=self.pkgSrcExePath,            
                resBasePath=self.sourceDir,      
                isTempSrc = isTempSrc,
                pkgXml=self.qtIfwPackageXml(), 
                pkgScript=self.qtIfwPackageScript( self.__pkgPyInstConfig ) )
                
        pkg.exeName    = self.__pkgExeName()
        pkg.isGui      = self.isGui
            
        pkg.exeWrapper = self.pkgExeWrapper        
        if( IS_WINDOWS and # On the fly, installer generated exe is only currently supported on Windows! 
            isinstance( pkg.exeWrapper, QtIfwExeWrapper ) and 
            pkg.exeWrapper.isExe ):
            w = pkg.exeWrapper
            pkg.pkgScript.externalOps += [
                QtIfwExternalOp.WrapperScript2Exe(
                    scriptPath = joinPath( w.exeDir, 
                        w.wrapperScript.fileName() ), 
                    exePath = joinPath( w.exeDir, normBinaryName( w.exeName ) ),
                    targetPath = joinPath( w.exeDir, normBinaryName( w.wrapperExeName ) ), 
                    iconName=normIconName( w.wrapperIconName ) ) ]       
            if self.startOnBoot in [True, CURRENT_USER, ALL_USERS]:
                pkg.pkgScript.externalOps += [
                    QtIfwExternalOp.CreateStartupEntry( pkg, 
                        isAllUsers=self.startOnBoot==ALL_USERS ) ]
         
        # Add additional distribution resources 
        # (note PyInst process adds these resource itself)
        if pkgType != QtIfwPackage.Type.PY_INSTALLER:            
            # Add the external icon resource as needed for Linux 
            if IS_LINUX and self.iconFilePath :  
                pngPath = normIconName( self.iconFilePath, isPathPreserved=True )
                if isFile( pngPath ):
                    if pkg.distResources is None: pkg.distResources=[] 
                    pkg.distResources.append( pngPath )
            # Merge the factory resources into the existing list for the package 
            pkg.distResources = list( set().union(
                pkg.distResources if pkg.distResources else [], 
                self.distResources if self.distResources else [] ) )
            if pkg.pkgType in [ QtIfwPackage.Type.RAW
                              , QtIfwPackage.Type.DATA  
                              #, QtIfwPackage.Type.RESOURCE #?
                              ]:                 
                pkg.distResources = util._expandSrcDestPairs( 
                    pkg.distResources, destDir=None, 
                    basePath=pkg.resBasePath ) 

        if self.codeSignConfig:
            # These package types already signed the primary exe
            if( pkgType != QtIfwPackage.Type.PY_INSTALLER and          
                pkgType != QtIfwPackage.Type.IEXPRESS ):
                try: self.pkgCodeSignTargets.append( pkg.exeName )
                except: self.pkgCodeSignTargets=[ pkg.exeName ]
            # EXE wrappers can't be signed (a design limitation)    
            if( isinstance( pkg.exeWrapper, QtIfwExeWrapper ) and 
                pkg.exeWrapper.isExe ):
                exeName = pkg.exeWrapper.wrapperExeName
                printErr( "WARNING: %s will be generated at install time and "
                          "therefore cannot be code signed (as your private "
                          "key would be be required in the distribution)!" % 
                          (exeName,), 
                          isFatal=False)
            pkg.codeSignTargets = self.pkgCodeSignTargets
                                                                                                              
        pkg.qtCppConfig = self.qtCppConfig        
        return pkg

    def qtIfwPackageXml( self ) :
        return QtIfwPackageXml( self.__ifwPkgName(), 
                self.productName, self.description, self.__versionStr(), 
                scriptName=self.ifwPkgScriptName,
                isDefault=self.ifwPkgIsDefault, 
                isRequired=self.ifwPkgIsRequired,
                isHidden=self.ifwPkgIsHidden )
    
    def qtIfwPackageScript( self, pyInstConfig=None ) :
        if self.ifwPkgScript : return self.ifwPkgScript
        self.__pkgPyInstConfig = pyInstConfig

        # Build the shortcut object 
        # (shortcuts are script generated on the target, not bundled resources) 
        shortcutCmd = ( self.pkgExeWrapper._shortcutCmd
                        if self.pkgExeWrapper else None )
        shortcutArgs = ( self.pkgExeWrapper._shortcutArgs
                         if self.pkgExeWrapper else [] )
        shortcutWinStyle = ( self.pkgExeWrapper._shortcutWinStyle
                             if self.pkgExeWrapper else None )                        
        shortcutExeDir = ( 
            joinPathQtIfw( QT_IFW_TARGET_DIR, self.pkgSubDirName )
            if self.pkgSubDirName else QT_IFW_TARGET_DIR )
                
        if IS_LINUX:
            # TODO: fix this to handle relative source paths
            #       and nested destination paths
            #       (use util._toSrcDestPair)
            # Currently just cheating by assuming png icon is going on app dir root...  
            if self.__pkgPyInstConfig:
                cfg=self.__pkgPyInstConfig                 
                pngIconPath = cfg._pngIconResPath
            #    relSrcDir = dirPath( 
            #        cfg.sourceDir if cfg.sourceDir else THIS_DIR )                
            elif self.iconFilePath:    
                pngIconPath = self.iconFilePath
                #pngIconPath = normIconName( self.iconFilePath, 
                #                            isPathPreserved=True )
                #relSrcDir = dirPath( self.iconFilePath )
            #if pngIconPath:
            #    srcDir, srcFile = splitPath( pngIconPath )
            #    if srcDir=="" or not isParentDir( relSrcDir, srcDir ):
            #        pngIconPath = joinPath( 
            #            relpath( srcDir, relSrcDir ), srcFile )            
            pngIconPath = normIconName( self.iconFilePath, 
                                        isPathPreserved=False )                   
        else : pngIconPath = None                         
        
        defShortcut = QtIfwShortcut(                    
                        productName=self.productName,
                        command=shortcutCmd,
                        args=shortcutArgs,
                        exeDir=shortcutExeDir,
                        exeName=self.__pkgExeName(),                            
                        exeVersion=self.__versionStr(),
                        isGui=self.isGui,                                  
                        pngIconResPath=pngIconPath )  
        defShortcut.windowStyle = shortcutWinStyle
        
        bundledScripts=[]
        if self.pkgExeWrapper and self.pkgExeWrapper.wrapperScript:
            bundledScripts.append( self.pkgExeWrapper.wrapperScript )

        dynamicTexts={}
        if self.pkgConfigs:
            for pathPair, content in iteritems( self.pkgConfigs ):
                if isinstance( content, RawConfigParser ):                     
                    with StringIO() as buffer:
                        content.write( buffer )
                        buffer.seek( 0 ) 
                        dynamicTexts[ pathPair ] = buffer.read()
                else:
                    srcPath, _ = util._toSrcDestPair( pathPair )                                                                              
                    dynamicTexts[ pathPair ] =( content if content else                                                 
                        PlasticFile( filePath=srcPath ).read() )
                       
        script = QtIfwPackageScript( 
                    self.__ifwPkgName(), self.__versionStr(),
                    pkgSubDirName=self.pkgSubDirName,
                    shortcuts=[ defShortcut ],
                    bundledScripts=bundledScripts,
                    dynamicTexts=dynamicTexts,
                    fileName=self.ifwPkgScriptName,
                    script=self.ifwPkgScriptText, 
                    scriptPath=self.ifwPkgScriptPath )
        
        if IS_LINUX and self.pkgExeWrapper:
            script.isAskPassProgRequired = self.pkgExeWrapper.isElevated

        if IS_LINUX or IS_MACOS:
            script.externalDependencies = self.pkgExternalDependencies
            
        return script

    def qtIfwExeWrapper( self, wrapperScript=None,
                         workingDir=None, isElevated=False, 
                         envVars=None, args=None, 
                         isExe=False ) : # Windows only option!
        return QtIfwExeWrapper( self.__pkgExeName(), isGui=self.isGui, 
                wrapperScript=wrapperScript,
                exeDir=( joinPathQtIfw( QT_IFW_TARGET_DIR, self.pkgSubDirName )
                         if self.pkgSubDirName else QT_IFW_TARGET_DIR ),                 
                workingDir=workingDir, isElevated=isElevated, 
                envVars=envVars, args=args, isExe=isExe )        

    def __versionTuple( self ): return versionTuple( self.version )
                    
    def __versionStr( self ): return versionStr( self.version )
        
    def __ifwPkgId( self ):
        if self.ifwPkgId : return self.ifwPkgId
        if self.cfgId : return self.cfgId
        prod =( self.__pkgPyInstConfig.name if self.__pkgPyInstConfig 
                else self.__pkgIExpressConfig.name if self.__pkgIExpressConfig
                else self.productName )        
        prod = prod.replace(" ", "").replace(".", "").lower()            
        return prod

    def __ifwPkgType( self ):
        if self.pkgType is not None: return self.pkgType
        if self.__pkgPyInstConfig : return QtIfwPackage.Type.PY_INSTALLER
        if self.__pkgIExpressConfig: return QtIfwPackage.Type.IEXPRESS
        if self.pkgSrcExePath is None:
            return ( QtIfwPackage.Type.DATA if self.binaryName is None else
                     QtIfwPackage.Type.RAW )
        return None
    
    def __ifwPkgName( self ):
        if self.ifwPkgName : return self.ifwPkgName
        comp = ( self.companyTradeName if self.companyTradeName
                 else self.companyLegalName )
        comp = comp.replace(" ", "").replace(".", "").lower()
        prod =( self.__pkgPyInstConfig.name if self.__pkgPyInstConfig 
                else self.__pkgIExpressConfig.name if self.__pkgIExpressConfig
                else self.productName )        
        prod = prod.replace(" ", "").replace(".", "").lower()            
        return "%s.%s.%s" % (self.ifwPkgNamePrefix, comp, prod)

    def __pkgSrcDirPath( self ):
        if self.__pkgPyInstConfig : return absPath( self.__pkgPyInstConfig.name )
        if self.__pkgIExpressConfig : return absPath( self.__pkgIExpressConfig.name )
        if self.pkgSrcDirPath : return self.pkgSrcDirPath
        if( self.__ifwPkgType() in [QtIfwPackage.Type.RAW
                                   ,QtIfwPackage.Type.PY_INSTALLER
                                   ,QtIfwPackage.Type.IEXPRESS
                                   #,QtIfwPackage.Type.QT_CPP # ?
                                   ] and             
            self.binaryName ): 
            return absPath( self.binaryName )               
        return None                 

    def __pkgExeName( self ):
        if self.binaryName : return self.binaryName
        if self.pkgSrcExePath: 
            return normBinaryName( self.pkgSrcExePath, isGui=self.isGui )  
        return None
        
# -----------------------------------------------------------------------------
@add_metaclass(ABCMeta)
class _DistBuildProcessBase:

    DIVIDER = "------------------------------------"

    def __init__( self, configFactory,
                  name="Distribution Builder Process" ) :
        self.configFactory = configFactory                              
        self.name          = name        
        self.__startTime   = None
        self.__endTime     = None
        self.__duration    = None
    
    def run( self ):        
        self.__startTime = curTime()
        self.__printHeader()        
        self.onInitialize()
        self._body()
        self.onFinalize()
        self.__endTime   = curTime()
        self.__durationSecs  = self.__endTime - self.__startTime 
        self.__printFooter()
    
    def __printHeader( self ):
        try: 
            from distbuilder import __version__ as ver
            libPath = modulePackagePath( "distbuilder" )
        except: 
            ver = "?"
            libPath = "?"        
        print( _DistBuildProcessBase.DIVIDER )    
        print( "STARTING: %s" % (self.name,) )
        print( "Date/Time: %s" % (str(datetime.now()),) )        
        print( "Distrbution Builder Version: %s" % (ver,) )
        print( "Library Path:\n    %s" % (libPath,) )
        print( "Python Translator:\n    %s" % (sysVersion,) )
        print( "System Info:\n    %s %s" % (platform.system(), platform.release()) )
        print( _DistBuildProcessBase.DIVIDER )
        print( "" )
    
    def __printFooter( self ):
        print( "" )        
        print( _DistBuildProcessBase.DIVIDER )
        print( "COMPLETED: %s" % (self.name,) )
        print( "Date/Time: %s" % (str(datetime.now()),) )
        print( "Total Seconds: %f" % (self.__durationSecs,) )
        print( _DistBuildProcessBase.DIVIDER )
        
    @abstractmethod
    def _body( self ): """PURE VIRTUAL"""           
   
    def onInitialize( self ): """VIRTUAL"""
    def onFinalize( self ):   """VIRTUAL"""

# -----------------------------------------------------------------------------
@add_metaclass(ABCMeta)
class _BuildPackageProcess( _DistBuildProcessBase ):
    def __init__( self, configFactory,                  
                  name="Binary Package Process",
                  isZipped=False, isDesktopTarget=False, isHomeDirTarget=False ) :
        _DistBuildProcessBase.__init__( self, configFactory, name )                
        
        self.isZipped        = isZipped        
        self.isDesktopTarget = isDesktopTarget
        self.isHomeDirTarget = isHomeDirTarget
        
        self.isExeTest       = False
        self.isElevatedTest  = False
        self.exeTestArgs     = []          
                      
        # Results
        self.binDir = None
        self.binPath = None
                    
    def _moveToDestAndTest( self ):        
          
        destDirPath =( util._userDesktopDirPath() if self.isDesktopTarget else 
                       util._userHomeDirPath()    if self.isHomeDirTarget else 
                       None )          
        if self.isZipped :
            # test exe first!
            if self.isExeTest : self.__testExe() 
            # bin path is actually the zip now...
            self.binPath = toZipFile( self.binDir, zipDest=None, removeScr=True )
            if destDirPath and self.binDir != destDirPath: 
                self.binPath = moveToDir( self.binPath, destDirPath ) 
                self.binDir  = destDirPath
        else:         
            if destDirPath and self.binDir != destDirPath:
                binName = baseFileName( self.binPath )
                isOtherContent = len( [item for item in listdir( self.binDir ) 
                                      if item != binName] ) > 0                                      
                if isOtherContent:
                    self.binDir  = moveToDir( self.binDir, destDirPath )
                    self.binPath = joinPath( self.binDir, binName )
                else:
                    originDirPath = self.binDir 
                    self.binPath = moveToDir( self.binPath, destDirPath )
                    self.binDir  = destDirPath 
                    removeDir( originDirPath )
            if self.isExeTest : self.__testExe()
            
    def __testExe( self ):
        run( self.binPath, self.exeTestArgs,
             isElevated=self.isElevatedTest, isDebug=True )
                    
# -----------------------------------------------------------------------------
class PyToBinPackageProcess( _BuildPackageProcess ):

    def __init__( self, configFactory,                  
                  name="Python to Binary Package Process",
                  isZipped=False, isDesktopTarget=False, isHomeDirTarget=False ) :
        _BuildPackageProcess.__init__( self, configFactory, name,
            isZipped, isDesktopTarget, isHomeDirTarget )        

        self.isObfuscationTest      = False

        self.isWarningSuppression   = True
        self.isUnBufferedStdIo      = False                
        self.isPyInstDupDataPatched = None
                        
        self._pyInstConfig = None
                
    def _body( self ):        
        
        if self.configFactory.isObfuscating :
            opyConfig = self.configFactory.opyConfig() 
            self.onOpyConfig( opyConfig )
            if self.isObfuscationTest:
                _, obPath = obfuscatePy( opyConfig )
                runPy( obPath, self.exeTestArgs, self.isElevatedTest )
                exit()
        else: opyConfig = None
        
        self._pyInstConfig = self.configFactory.pyInstallerConfig()        
        self.onPyInstConfig( self._pyInstConfig )                
        
        if self._pyInstConfig.pyInstSpec is None:
            self._pyInstConfig.isSpecFileRemoved = True
            makePyInstSpec( self._pyInstConfig, opyConfig=opyConfig )
            if self.isPyInstDupDataPatched is None: 
                self.isPyInstDupDataPatched = True                
            spec = self._pyInstConfig.pyInstSpec
            spec.isUnBufferedStdIo = self.isUnBufferedStdIo        
            if self.isWarningSuppression:
                spec.warningBehavior = PyInstSpec.WARN_IGNORE                  
        spec = self._pyInstConfig.pyInstSpec            
        if self.isWarningSuppression or self.isUnBufferedStdIo:                
            spec.injectInterpreterOptions()
        if self.isPyInstDupDataPatched and self._pyInstConfig.isOneFile:                    
            spec.injectDuplicateDataPatch()
        if spec.isInjected: spec.write()            
        self.onMakeSpec( spec )
        spec.debug()
            
        self.binDir, self.binPath = (
            pyScriptToExe( pyInstConfig=self._pyInstConfig, 
                           opyConfig=opyConfig ) )
        
        self._moveToDestAndTest()
                    
    # Override these to further customize the build process once the 
    # ConfigFactory has produced each initial config object
    def onInitialize( self ):        """VIRTUAL"""    
    def onOpyConfig( self, cfg ):    """VIRTUAL"""                    
    def onPyInstConfig( self, cfg ): """VIRTUAL"""
    def onMakeSpec( self, spec ):    """VIRTUAL"""
    def onFinalize( self ):          """VIRTUAL"""

# -----------------------------------------------------------------------------
class IExpressPackageProcess( _BuildPackageProcess ):
    def __init__( self, configFactory,                  
                  name="Windows Script to Binary Package Process",
                  isZipped=False, isDesktopTarget=False, isHomeDirTarget=False ) :
        
        # NOT APPLICABLE OUTSIDE OF _WINDOWS!   
        if not IS_WINDOWS: util._onPlatformErr()
        
        _BuildPackageProcess.__init__( self, configFactory, name,
            isZipped, isDesktopTarget, isHomeDirTarget )        

        self._iExpressConfig = None
                    
    def _body( self ):        
        self._iExpressConfig = self.configFactory.iExpressConfig()       
        self.onIExpressConfig( self._iExpressConfig )                      
        self.binDir, self.binPath = _scriptToExe( iExpressConfig=
                                                  self._iExpressConfig )        
        self._moveToDestAndTest()
                    
    # Override these to further customize the build process once the 
    # ConfigFactory has produced each initial config object
    def onInitialize( self ):          """VIRTUAL"""    
    def onIExpressConfig( self, cfg ): """VIRTUAL"""
    def onFinalize( self ):            """VIRTUAL"""
                            
# -----------------------------------------------------------------------------                        
class _BuildInstallerProcess( _DistBuildProcessBase ):

    def __init__( self, configFactory,
                  name="Build Installer Process",  
                  pyToBinPkgProcesses=None, 
                  iexpressPkgProcesses=None,
                  ifwPackages=None,                                                                                   
                  isDesktopTarget=False, isHomeDirTarget=False ) :
        _DistBuildProcessBase.__init__( self, configFactory, name )
        
        self.pyToBinPkgProcesses =( pyToBinPkgProcesses 
                                    if pyToBinPkgProcesses else [] )
        self.iexpressPkgProcesses=( iexpressPkgProcesses
                                        if iexpressPkgProcesses else [] )        
        self.ifwPackages         = ifwPackages if ifwPackages else [] 
        self.isDesktopTarget     = isDesktopTarget
        self.isHomeDirTarget     = isHomeDirTarget
        
        self.isInstallTest            = False        
        self.isAutoInstallTest        = False
        self.isVerboseInstallTest     = True
        self.isScriptDebugInstallTest = False
        
        # Results
        self.setupPath = None
        
    def _body( self ):        
        for p in self.pyToBinPkgProcesses :
            p.run()
            self.ifwPackages.append(                
                p.configFactory.qtIfwPackage(
                    pyInstConfig=p._pyInstConfig, isTempSrc=True )
            )
        self.onPyPackagesBuilt( self.ifwPackages )
        
        if IS_WINDOWS:
            for p in self.iexpressPkgProcesses:
                p.run()
                self.ifwPackages.append(                
                    p.configFactory.qtIfwPackage( 
                        iExpressConfig=p._iExpressConfig, isTempSrc=True )
                )
            self.onIExpressPackagesBuilt( self.ifwPackages )
            
        ifwConfig = self.configFactory.qtIfwConfig( packages=self.ifwPackages )
        self.onQtIfwConfig( ifwConfig )     
        
        _stageInstallerPackages( ifwConfig, self.configFactory.isSilentSetup )
        self.onPackagesStaged( ifwConfig, ifwConfig.packages )

        if self.configFactory.codeSignConfig:
            for pkg in self.ifwPackages:
                if pkg.codeSignTargets:
                    for relPath in pkg.codeSignTargets: 
                        exePath = absPath( relPath, pkg.contentDirPath() )
                        signExe( exePath, self.configFactory.codeSignConfig ) 
                   
        self.setupPath = _buildInstaller( 
            ifwConfig, self.configFactory.isSilentSetup, 
            self.configFactory.codeSignConfig )
        
        if IS_WINDOWS:
            embedExeVerInfo( self.setupPath, 
                             self.configFactory.exeVersionInfo( ifwConfig ) )
        
        if self.configFactory.codeSignConfig :
            signExe( self.setupPath, self.configFactory.codeSignConfig ) 
        
        if self.isDesktopTarget :
            self.setupPath = moveToDesktop( self.setupPath )
        elif self.isHomeDirTarget :
            self.setupPath = moveToHomeDir( self.setupPath )    
        if self.isInstallTest or self.isAutoInstallTest:            
            if self.isVerboseInstallTest:
                verboseArgs = ( [QT_IFW_SILENT_DEBUG_SWITCH] 
                                if self.configFactory.isSilentSetup else
                                [QT_IFW_VERBOSE_SWITCH] )  
            else: verboseArgs = []                             
            debugArgs = _DEBUG_SCRIPTS_ARGS if self.isScriptDebugInstallTest else [] 
            autoArgs = ( 
                ( _SILENT_FORCED_ARGS if self.configFactory.isSilentSetup else
                  _LOUD_FORCED_ARGS ) 
                if self.isAutoInstallTest else [] )
            
            if( self.configFactory.isSilentSetup and  
                IS_WINDOWS and not util._isPrivateRedirectAvailable() ):
                printErr( "WARNING: Silent installer debugging messages "
                          "may not appear in the build log on this LEGACY "
                          "version of Windows! Manual testing of the installer "
                          "should still work in this environment though..." )
            
            run( self.setupPath, verboseArgs + debugArgs + autoArgs,
                 isDebug=True, isElevated=self.isAutoInstallTest )
        
    # Override these to further customize the build process once the 
    # ConfigFactory has produced the initial config object
    def onInitialize( self ):                   """VIRTUAL"""
    def onPyPackagesBuilt( self, pkgs ):        """VIRTUAL"""
    def onIExpressPackagesBuilt( self, pkgs ):  """VIRTUAL"""
    def onQtIfwConfig( self, cfg ):             """VIRTUAL"""
    def onPackagesStaged( self, cfg, pkgs ):    """VIRTUAL"""     
    def onFinalize( self ):                     """VIRTUAL"""
    
# -----------------------------------------------------------------------------                        
class PyToBinInstallerProcess( _BuildInstallerProcess ):
    
    def __init__( self, configFactory,                  
                  name="Python to Binary Installer Process",
                  isDesktopTarget=False, isHomeDirTarget=False ) :
        
        class CallbackPyToBinPackageProcess( PyToBinPackageProcess ):
            def __init__( self, parent, configFactory ):
                PyToBinPackageProcess.__init__( self, configFactory )
                self.__parent = parent
            def onOpyConfig( self, cfg ):    self.__parent.onOpyConfig( cfg )                    
            def onPyInstConfig( self, cfg ): self.__parent.onPyInstConfig( cfg )
            def onMakeSpec( self, spec ):    self.__parent.onMakeSpec( spec )                   
                                   
        prc = CallbackPyToBinPackageProcess( self, configFactory )
        self.onPyPackageProcess( prc )
            
        _BuildInstallerProcess.__init__( self, 
            configFactory, name,
            pyToBinPkgProcesses=[ prc ],                                         
            isDesktopTarget=isDesktopTarget, 
            isHomeDirTarget=isHomeDirTarget )

    # Override these to further customize the build process once the 
    # ConfigFactory has produced each initial config object
    def onInitialize( self ):             """VIRTUAL"""    
    def onPyPackageProcess( self, prc ):  """VIRTUAL"""
    def onOpyConfig( self, cfg ):         """VIRTUAL"""                    
    def onPyInstConfig( self, cfg ):      """VIRTUAL"""
    def onMakeSpec( self, spec ):         """VIRTUAL"""
    def onQtIfwConfig( self, cfg ):       """VIRTUAL"""                                                                
    def onFinalize( self ):               """VIRTUAL"""

# -----------------------------------------------------------------------------                        
class IExpressInstallerProcess( _BuildInstallerProcess ):
    
    def __init__( self, configFactory,                  
                  name="Windows Script to Binary Installer Process",
                  isDesktopTarget=False, isHomeDirTarget=False ) :
        
        class CallbackIExpressToBinPackageProcess( IExpressPackageProcess ):
            def __init__( self, parent, configFactory ):
                IExpressPackageProcess.__init__( self, configFactory )
                self.__parent = parent
            def onIExpressConfig( self, cfg ): self.__parent.onIExpressConfig( cfg )
                                       
        prc = CallbackIExpressToBinPackageProcess( self, configFactory )
        self.onIExpressPackageProcess( prc )
            
        _BuildInstallerProcess.__init__( self, 
            configFactory, name,
            iexpressPkgProcesses=[ prc ],                                         
            isDesktopTarget=isDesktopTarget, 
            isHomeDirTarget=isHomeDirTarget )

    # Override these to further customize the build process once the 
    # ConfigFactory has produced each initial config object
    def onInitialize( self ):                    """VIRTUAL"""    
    def onIExpressPackageProcess( self, prc ):   """VIRTUAL"""
    def onIExpressConfig( self, cfg ):           """VIRTUAL"""
    def onQtIfwConfig( self, cfg ):              """VIRTUAL"""                                                                
    def onFinalize( self ):                      """VIRTUAL"""
                                                                                                
# -----------------------------------------------------------------------------                        
class RobustInstallerProcess( _BuildInstallerProcess ):
    
    def __init__( self, masterConfigFactory, 
                  name="Robust Installer Process",
                  pyPkgConfigFactoryDict=None,
                  iExpressPkgConfigFactoryDict=None, 
                  ifwPackages=None,                                     
                  isDesktopTarget=False, isHomeDirTarget=False ) :
                
        class CallbackPyToBinPackageProcess( PyToBinPackageProcess ):
            def __init__( self, parent, key, configFactory ):
                PyToBinPackageProcess.__init__( self, configFactory )
                self.__parent = parent
                self.__key    = key                 
            def onInitialize( self ):
                self.__parent.onPyPackageInitialize( self.__key )           
            def onOpyConfig( self, cfg ):    
                self.__parent.onOpyConfig( self.__key, cfg )                    
            def onPyInstConfig( self, cfg ): 
                self.__parent.onPyInstConfig( self.__key, cfg )
            def onMakeSpec( self, spec ):    
                self.__parent.onMakeSpec( self.__key, spec )       
            def onFinalize( self ):          
                self.__parent.onPyPackageFinalize( self.__key )           

        class CallbackIExpressToBinPackageProcess( IExpressPackageProcess ):
            def __init__( self, parent, key, configFactory ):
                IExpressPackageProcess.__init__( self, configFactory )
                self.__parent = parent
                self.__key    = key                 
            def onInitialize( self ):
                self.__parent.onIExpressPackageInitialize( self.__key )         
            def onIExpressConfig( self, cfg ): 
                self.__parent.onIExpressConfig( self.__key, cfg )                  
            def onFinalize( self ):          
                self.__parent.onIExpressPackageFinalize( self.__key )           
    
        if pyPkgConfigFactoryDict is None: pyPkgConfigFactoryDict={}
        if iExpressPkgConfigFactoryDict is None: 
            iExpressPkgConfigFactoryDict={}
        if ifwPackages is None: ifwPackages=[]

        pyBinPrcs = []
        for key, factory in iteritems( pyPkgConfigFactoryDict ) :        
            if factory is None :
                factory = ConfigFactory.copy( masterConfigFactory )
                factory.cfgId = key
                self.onConfigFactory( key, factory )
            prc = CallbackPyToBinPackageProcess( self, key, factory )
            self.onPyPackageProcess( key, prc )    
            pyBinPrcs.append( prc )        

        iExpressBinPrcs = []
        if IS_WINDOWS:
            for key, factory in iteritems( iExpressPkgConfigFactoryDict ) :        
                if factory is None :
                    factory = ConfigFactory.copy( masterConfigFactory )
                    factory.cfgId = key
                    self.onConfigFactory( key, factory )
                prc = CallbackIExpressToBinPackageProcess( self, key, factory )
                self.onIExpressPackageProcess( key, prc )    
                iExpressBinPrcs.append( prc )        
        elif( iExpressPkgConfigFactoryDict and 
             len(iExpressPkgConfigFactoryDict) > 0 ) :
            printErr( "WARNING: IEXPRESS PACKAGES CANNOT BE BUILT OUTSIDE OF "
                      "WINDOWS! DROPPING ALL SUCH PACKAGE CONFIGURATIONS..." )
            
        _BuildInstallerProcess.__init__( self, 
            masterConfigFactory, name,
            ifwPackages=ifwPackages,
            pyToBinPkgProcesses=pyBinPrcs,          
            iexpressPkgProcesses=iExpressBinPrcs,                               
            isDesktopTarget=isDesktopTarget, 
            isHomeDirTarget=isHomeDirTarget )

    # Override these to further customize the build process  
    def onInitialize( self ):                        """VIRTUAL"""        
    def onConfigFactory( self, key, factory ):       """VIRTUAL"""
    
    def onPyPackageProcess( self, key, prc ):        """VIRTUAL"""
    def onPyPackageInitialize( self, key ):          """VIRTUAL"""
    def onOpyConfig( self, key, cfg ):               """VIRTUAL"""                    
    def onPyInstConfig( self, key, cfg ):            """VIRTUAL"""
    def onMakeSpec( self, key, spec ):               """VIRTUAL"""
    def onPyPackageFinalize( self, key ):            """VIRTUAL"""           
    def onPyPackagesBuilt( self, pkgs ):             """VIRTUAL"""
    
    def onIExpressPackageProcess( self, key, prc ): """VIRTUAL"""
    def onIExpressPackageInitialize( self, key ):   """VIRTUAL"""
    def onIExpressConfig( self, key, cfg ):         """VIRTUAL"""
    def onIExpressPackageFinalize( self, key ):     """VIRTUAL"""
    def onIExpressPackagesBuilt( self, pkgs ):      """VIRTUAL"""
        
    def onQtIfwConfig( self, cfg ):                  """VIRTUAL"""     
    def onPackagesStaged( self, cfg, pkgs ):         """VIRTUAL"""                                                     
    def onFinalize( self ):                          """VIRTUAL"""
