## **ConfigFactory**`#!py3 class` { #ConfigFactory data-toc-label=ConfigFactory }

It is typical for a build script to start by creating a high-level 
[ConfigFactory](Config-Factory.md) object and set its attributes.

The primary functions within this library rely upon a collection of 
"configuration" objects which act as "smart  parameter sets".
Those parameters are used to drive various processes. 
Many of these config classes have overlapping attributes.
Scripts which employ a collection of those low levels objects in the
raw tend to include a lot of tedious and redundant assignment operations.
With this in mind, the ConfigFactory class was created, to radically
simplify many scripts.

See [Configuration Classes](ConfigClasses.md#configuration-classes) for more
information on the types of objects generated by this factory class.  

Note that this class is NOT intended to have a one-to-one correspondence
for **every** attribute within all of the configuration objects it can generate.
If that were provided, this class would become an overwhelmingly bloated monster!
Only the more commonly needed (and/or shared) attributes are provided on this level.  You
must manipulate those config objects generated by the factory *directly* if you need to
access their more extended features.  Typically, you will want to access those
objects from a "callback" function within a derived "Process" class implementation.      

**Magic Methods:**

 - [`__init__`](#ConfigFactory-init)

**Instance Methods:** 

 - [`exeVersionInfo`](#exeVersionInfo)
 - [`iExpressConfig`](#iExpressConfig)
 - [`opyConfig`](#opyConfig)
 - [`pyInstallerConfig`](#pyInstallerConfig)
 - [`qtIfwConfig`](#qtIfwConfig)
 - [`qtIfwConfigXml`](#qtIfwConfigXml)
 - [`qtIfwControlScript`](#qtIfwControlScript)
 - [`qtIfwExeWrapper`](#qtIfwExeWrapper)
 - [`qtIfwPackage`](#qtIfwPackage)
 - [`qtIfwPackageScript`](#qtIfwPackageScript)
 - [`qtIfwPackageXml`](#qtIfwPackageXml)

**Instance Attributes:** 

 - [`cfgId`](#cfgId)
 - [`productName`](#productName)
 - [`description`](#description)
 - [`companyTradeName`](#companyTradeName)
 - [`companyLegalName`](#companyLegalName)
 - [`version`](#version)
 - [`isGui`](#isGui)
 - [`binaryName`](#binaryName)
 - [`sourceDir`](#sourceDir)
 - [`iconFilePath`](#iconFilePath)
 - [`entryPointPy`](#entryPointPy)
 - [`specFilePath`](#specFilePath)
 - [`isOneFile`](#isOneFile)
 - [`entryPointScript`](#entryPointScript)
 - [`distResources`](#distResources)
 - [`isObfuscating`](#isObfuscating)
 - [`opyBundleLibs`](#opyBundleLibs)
 - [`opyPatches`](#opyPatches)
 - [`isSilentSetup`](#isSilentSetup)
 - [`setupName`](#setupName)
 - [`ifwDefDirPath`](#ifwDefDirPath)
 - [`ifwPackages`](#ifwPackages)
 - [`isLimitedMaintenance`](#isLimitedMaintenance)
 - [`replaceTarget`](#replaceTarget)
 - [`ifwWizardStyle`](#ifwWizardStyle)
 - [`ifwLogoFilePath`](#ifwLogoFilePath)
 - [`ifwBannerFilePath`](#ifwBannerFilePath)
 - [`licensePath`](#licensePath)
 - [`ifwUiPages`](#ifwUiPages)
 - [`ifwWidgets`](#ifwWidgets)
 - [`ifwCntrlScript`](#ifwCntrlScript)
 - [`ifwCntrlScriptText`](#ifwCntrlScriptText)
 - [`ifwCntrlScriptPath`](#ifwCntrlScriptPath)
 - [`ifwCntrlScriptName`](#ifwCntrlScriptName)
 - [`ifwPkgId`](#ifwPkgId)
 - [`ifwPkgName`](#ifwPkgName)
 - [`ifwPkgNamePrefix`](#ifwPkgNamePrefix)
 - [`ifwPkgIsDefault`](#ifwPkgIsDefault)
 - [`ifwPkgIsRequired`](#ifwPkgIsRequired)
 - [`ifwPkgIsHidden`](#ifwPkgIsHidden)
 - [`ifwPkgScript`](#ifwPkgScript)
 - [`ifwPkgScriptText`](#ifwPkgScriptText)
 - [`ifwPkgScriptPath`](#ifwPkgScriptPath)
 - [`ifwPkgScriptName`](#ifwPkgScriptName)
 - [`pkgType`](#pkgType)
 - [`pkgSubDirName`](#pkgSubDirName)
 - [`pkgSrcDirPath`](#pkgSrcDirPath)
 - [`pkgSrcExePath`](#pkgSrcExePath)
 - [`pkgCodeSignTargets`](#pkgCodeSignTargets)
 - [`pkgExeWrapper`](#pkgExeWrapper)
 - [`pkgExternalDependencies`](#pkgExternalDependencies)
 - [`pkgConfigs`](#pkgConfigs)
 - [`startOnBoot`](#startOnBoot)
 - [`codeSignConfig`](#codeSignConfig)
 - [`qtCppConfig`](#qtCppConfig)

**Class/Static Methods:** 

 - [`copy`](#copy)

### **ConfigFactory**`#!py3 (cfgId=None)` { #ConfigFactory-init data-toc-label="&lowbar;&lowbar;init&lowbar;&lowbar;" }

**Parameters**
                
> **cfgId:** `int` -- (Optional) Object identifier.        
### *obj*.**exeVersionInfo**`#!py3 (self, ifwConfig=None)` { #exeVersionInfo data-toc-label=exeVersionInfo }

Produce a version info object.

**Parameters**

 **ifwConfig:** `QtIfwConfig` -- Installer config object containing 
branding info.

**Returns**

 `WindowsExeVersionInfo` -- version info object for Windows `.exe`.
### *obj*.**iExpressConfig**`#!py3 (self)` { #iExpressConfig data-toc-label=iExpressConfig }

Produce an IExpress configuration Object.

**Returns**

 `IExpressConfig` -- Configuration object for running IExpress.
### *obj*.**opyConfig**`#!py3 (self)` { #opyConfig data-toc-label=opyConfig }

Produce an Opy configuration Object.

**Returns**

 `OpyConfig` -- Configuration object for running Opy.
### *obj*.**pyInstallerConfig**`#!py3 (self)` { #pyInstallerConfig data-toc-label=pyInstallerConfig }

Produce a PyInstaller configuration Object.

**Returns**

 `PyInstallerConfig` -- Configuration object for running PyInstaller.
### *obj*.**qtIfwConfig**`#!py3 (self, packages=None)` { #qtIfwConfig data-toc-label=qtIfwConfig }

Produce a QtIFW configuration Object.

**Parameters**

 **packages:** `list` of `QtIfwPackage` -- (Optional) Installer package objects.

**Returns**

 `QtIfwConfig` -- Configuration object for running the Qt Installer Framework.
### *obj*.**qtIfwConfigXml**`#!py3 (self)` { #qtIfwConfigXml data-toc-label=qtIfwConfigXml }

Produce a QtIFW config.xml Object.

**Returns**

 `QtIfwConfigXml` -- Abstraction layer over QtIFW config.xml file.
### *obj*.**qtIfwControlScript**`#!py3 (self, configXml)` { #qtIfwControlScript data-toc-label=qtIfwControlScript }

Produce a QtIFW Control Script Object.

**Parameters**

 **configXml:** `QtIfwConfigXml` --  QtIFW ConfigXml Object

**Returns**

 `QtIfwControlScript` -- Abstraction layer over QtIFW Control Script.
### *obj*.**qtIfwExeWrapper**`#!py3 (self, wrapperScript=None, workingDir=None, isElevated=False, envVars=None, args=None, isExe=False)` { #qtIfwExeWrapper data-toc-label=qtIfwExeWrapper }

Produce a QtIfw Exe Wrapper Object.

**Parameters**

 **wrapperScript:** `str` / `ExecutableScript` -- (Optional) **runtime** script executed over the top of the primary payload / target. 

 **workingDir:** `str` --  (Optional) **runtime** working directory

 **isElevated:** `bool` -- (Optional) **runtime** privilege elevation

 **envVars:** `dict` -- (Optional) **runtime** environmental variable values

 **args:** `dict` --  (Optional) **runtime** arguments to the program

 **isExe:** `bool` --  (Windows only) Produce a container `exe`.

**Returns**

 `QtIfwExeWrapper` -- QtIFW Exe Wrapper object.
### *obj*.**qtIfwPackage**`#!py3 (self, pyInstConfig=None, iExpressConfig=None, isTempSrc=False)` { #qtIfwPackage data-toc-label=qtIfwPackage }

Produce a package for QtIFW installer. 

**Parameters**

 **pyInstConfig:** `PyInstallerConfig` -- (Optional) Config object for running PyInstaller

 **iExpressConfig:** `IExpressConfig` -- (Optional) Config object for running IExpress

 **isTempSrc:** `bool` -- Is using ephemeral source code (e.g. obfuscated)

**Returns**

 `QtIfwPackage` -- Abstraction layer over a QtIFW Package.

### *obj*.**qtIfwPackageScript**`#!py3 (self, pyInstConfig=None)` { #qtIfwPackageScript data-toc-label=qtIfwPackageScript }

Produce a QtIFW Package Script Object.

**Parameters**

 **pyInstConfig:** `PyInstallerConfig` -- (Optional) Config object for running QtIFW

**Returns**

 `QtIfwPackageScript` -- Abstraction layer over QtIFW Package Script.
### *obj*.**qtIfwPackageXml**`#!py3 (self)` { #qtIfwPackageXml data-toc-label=qtIfwPackageXml }

Produce a QtIFW package .xml Object.

**Returns**

 `QtIfwPackageXml` -- Abstraction layer over QtIFW package .xml files.
### *obj*.**cfgId** *class 'NoneType'* default: *None* { #cfgId data-toc-label=cfgId }

Useful to distinguish between multiple ConfigFactory objects, as
are often employed by a [RobustInstallerProcess](#robustinstallerprocess).
### *obj*.**productName** *class 'NoneType'* default: *None* { #productName data-toc-label=productName }

The name for the product on the whole, or a sub component
within it (based upon the context of how the factory object is used).  Such
will appear as "brandings" upon a [Stand Alone Executable](LowLevel.md#stand-alone-executables) 
and/or as labels/details within [Installer](LowLevel.md#installers) menus.
### *obj*.**description** *class 'NoneType'* default: *None* { #description data-toc-label=description }

The description for the product on the whole, or a sub component
within it (based upon the context of how the factory object is used). Such
will appear as "brandings" upon a [Stand Alone Executable](LowLevel.md#stand-alone-executables) 
and/or as labels/details within [Installer](LowLevel.md#installers) menus.
### *obj*.**companyTradeName** *class 'NoneType'* default: *None* { #companyTradeName data-toc-label=companyTradeName }

Akin to `productName` and `description` attributes.  

Note the `companyTradeName` will be used in standard labels, directory names, shortcuts, etc.
produced by the process employing the ConfigFactory.  In contrast, `companyLegalName`
will appear within copyrights, EULAs, and the like where an "official" / legal name is 
called for.
### *obj*.**companyLegalName** *class 'NoneType'* default: *None* { #companyLegalName data-toc-label=companyLegalName }

Akin to `productName` and `description` attributes.  

Note the `companyTradeName` will be used in standard labels, directory names, shortcuts, etc.
produced by the process employing the ConfigFactory.  In contrast, `companyLegalName`
will appear within copyrights, EULAs, and the like where an "official" / legal name is 
called for.
### *obj*.**version** *class 'tuple'* default: *(0, 0, 0, 0)* { #version data-toc-label=version }

Akin to `productName` and `description` attributes, this can be applied to
either a [Stand Alone Executable](LowLevel.md#stand-alone-executables) 
or an [Installer](LowLevel.md#installers) based on the context of what uses
the config factory.

A version should be defined as a 4 part tuple of unsigned integers, in the form:

	( MAJOR, MINOR, PATCH, BUILD )

Alternatively, a string representation may be supplied.
See [versionTuple, versionStr](LowLevel.md#versiontuple,-versionstr).

Note that each part maybe any number of digits long.  i.e. this is a perfectly 
valid version stamp: `2.11.6.139`.  That example would be denoted in tuple form 
as: `(2,11,6,139)`
### *obj*.**isGui** *class 'bool'* default: *False* { #isGui data-toc-label=isGui }

This is attribute used for a variety of purposes, which would be difficult to 
list here. Perhaps most notably, it is applied directly to the production of  
[Stand Alone Executables](LowLevel.md#stand-alone-executables).
### *obj*.**binaryName** *class 'NoneType'* default: *None* { #binaryName data-toc-label=binaryName }

This is attribute used for a variety of purposes, which would be difficult to 
list here. Perhaps most notably, it is applied directly to the production of  
[Stand Alone Executables](LowLevel.md#stand-alone-executables).
### *obj*.**sourceDir** *class 'NoneType'* default: *None* { #sourceDir data-toc-label=sourceDir }

This attribute is used to resolve relative paths to absolute paths in various 
contexts. When omitted, such paths are normally resolved relative to the directory 
containing the build script (NOT the current working directory!).
### *obj*.**iconFilePath** *class 'NoneType'* default: *None* { #iconFilePath data-toc-label=iconFilePath }

Based upon context, this attribute is used to embedded (or bundle) an icon for
a [Stand Alone Executable](LowLevel.md#stand-alone-executables) or an
[Installer](LowLevel.md#installers). 

As demoed in the [Hello World Example](Examples.md#hello-world-example),
on Windows you must use a ".ico" file, on macOS a ".icns", or on Linux a ".png".
You do NOT have to specify the extension, however, when setting this attribute.
Such will be automatically determined per the platform at runtime. 

### *obj*.**entryPointPy** *class 'NoneType'* default: *None* { #entryPointPy data-toc-label=entryPointPy }

This attribute is most notably used when producing a 
[Stand Alone Executable](LowLevel.md#stand-alone-executables).
In that context, it points PyInstaller to the starting point for the source 
from which to build a binary.

This is also used during an [Executable Obfuscation](LowLevel.md#executable-obfuscation)
process.  The entry point module **name** is **not** obfuscated (though its contents are). 

### *obj*.**specFilePath** *class 'NoneType'* default: *None* { #specFilePath data-toc-label=specFilePath }

This attribute is a relatively sophisticated component used for   
producing a given [Stand Alone Executable](LowLevel.md#stand-alone-executables).
Most users of this library will never need to use this, though some may
wish to if they are migrating from a legacy build script which employed
a PyInstaller "spec file" they maintained.

This attribute is a means to specify a relative file path to an existing 
"spec" file. 

Note that distbuilder provides a [PyInstSpec](ConfigClasses.md#pyinstspec)
class which allows for programmatic generation and manipulation of such
files and configurations.  Also, many of the process classes which employ a 
config factory provide an `onMakeSpec( spec )` function.  And, if writing your 
own low level equivalents of the process class operations, the library provides
an [makePyInstSpec](LowLevel.md#makePyInstSpec) function.

### *obj*.**isOneFile** *class 'bool'* default: *True* { #isOneFile data-toc-label=isOneFile }

This switch controls a notable PyInstaller feature, i.e. bundling dependencies
into a single (compressed) exe when creating a 
[Stand Alone Executable](LowLevel.md#stand-alone-executables) vs leaving the 
dependencies outside of the exe.  Unlike PyInstaller, this library wrapper 
defaults to employing the single file feature. That produces a more "clean", streamlined, product which appears (on the surface) nearly identical across 
build environments - including cross platform.  But, this comes at the expense
of slowing down the launching of an executable.  

We recommend using the one file option for "small" programs, or ones which will
not likely be opened very often.  Set this to `False`, however, to boost 
a program's performance as far as load time is concerned. 

### *obj*.**entryPointScript** *class 'NoneType'* default: *None* { #entryPointScript data-toc-label=entryPointScript }

This attribute is used when producing a 
[Stand Alone Executable](LowLevel.md#stand-alone-executables) 
via an implementation of *IExpress*. Using this mechanism, you may convert a program written in a native Windows 
script (currently supporting Batch, PowerShell, VBScript, and JScript), into a
binary executable. 

For more information on *IExpress*, see:

https://en.wikipedia.org/wiki/IExpress
https://docs.microsoft.com/en-us/internet-explorer/ie11-ieak/iexpress-wizard-for-win-server
https://ss64.com/nt/iexpress.html
http://www.mdgx.com/INF_web/


Note this argument may be simple file path, pointing to source script, 
or an object of type [ExecutableScript](LowLevel.md#executablescript).

When using an `ExecutableScript`, a "script header" will automatically be 
injected.  This header modifies the context so that the implied working
directory will be where the exe's is launched from.  Without this code, 
the script will run from a (pseudo random) temporary location.  
This is a critical detail when resources are bundled with the program. 
Additionally the header provides the following global variables 
(which are named identically across the supported scripting languages):
`PID`, `PPID`, `EXE_PATH`, `THIS_DIR`, `LIB_DIR`, `RES_DIR`        

### *obj*.**distResources** *class 'list'* default: *[]* { #distResources data-toc-label=distResources }

The `distResources` attribute is an optional list of external resources to bundle 
into the distribution package.  You may use a simple list of strings containing 
file/directory names or paths *relative* to the build script directory. Else, you 
may provide a list of two element tuples, with a specific source and destination. 
In addition, source paths may be specified with globing *wildcards* if desired.  
They may even include environmental variables or path symbols.
See **distResources** within [pyScriptToExe](LowLevel.md#pyscripttoexe) for
more details on this.

Notably, this attribute is used when generating a 
[PyInstallerConfig](ConfigClasses.md#pyinstconfig)
object when invoking the `pyInstallerConfig()` function for this class, 
and then ultimately invoking the low level 
[pyScriptToExe](LowLevel.md#pyscripttoexe) operation with that.
Note this may be done for you via various high level process classes.

This attribute is also used for producing a
[QtIfwPackage](ConfigClasses.md#qtifwpackage) object when invoking the
`qtIfwPackage()` function for this class.
This too may be done for you via various high level process classes.

### *obj*.**isObfuscating** *class 'bool'* default: *False* { #isObfuscating data-toc-label=isObfuscating }

The `isObfuscating` switch toggles whether code obfuscation is employed by a process
using the config factory (based upon context).
### *obj*.**opyBundleLibs** *class 'NoneType'* default: *None* { #opyBundleLibs data-toc-label=opyBundleLibs }

The `opyBundleLibs` and `opyPatches` are details used for generating an 
[OpyConfig](ConfigClasses.md#opyconfig) object when invoking the `opyConfig()`
function for this class.
For more information, refer to the following:        
- [Executable Obfuscation](LowLevel.md#executable-obfuscation)  
- [Obfuscation Features](LowLevel.md#obfuscation-features)  
- [Hello World Tk Example](Examples.md#hello-world-tk-example)    
- [Opy for Distribution Builder](https://pypi.org/project/opy-distbuilder/)

### *obj*.**opyPatches** *class 'NoneType'* default: *None* { #opyPatches data-toc-label=opyPatches }

The `opyBundleLibs` and `opyPatches` are details used for generating an 
[OpyConfig](ConfigClasses.md#opyconfig) object when invoking the `opyConfig()`
function for this class.
### *obj*.**isSilentSetup** *class 'bool'* default: *False* { #isSilentSetup data-toc-label=isSilentSetup }

When `isSilentSetup` is enabled, the QtIFW installer produced will not display a GUI or 
provide any interactive prompts for the user.  All options are dictated by command line 
arguments. While this may certainly be desirable on any platform, it is  
*necessary* to create an installer for a target OS with no GUI (e.g. many Linux distros).

For more information refer to: 

- [buildInstaller](LowLevel.md#buildInstaller)
- [Silent Installers](LowLevel.md#silent-installers)
- [Hello Silent Example](Examples.md#hello-silent-example)        

### *obj*.**setupName** *class 'str'* default: *"setup.exe"* { #setupName data-toc-label=setupName }

This is the file name given to a QtIFW installer when the config factory is used in a 
context to produce one. This attribute is specifically applied when generating a 
[QtIfwConfig](ConfigClasses.md#qtifwconfig) object upon invoking the `qtIfwConfig()`
function for this class.

### *obj*.**ifwDefDirPath** *class 'NoneType'* default: *None* { #ifwDefDirPath data-toc-label=ifwDefDirPath }

When producing a QtIFW installer this attribute may *optionally* be used to specify 
an external, hard coded definition for the installer.  This is useful when either 
integrating the distbuilder library with an existing QtIFW installer, or when a 
developer would prefer to use the traditional QtIFW approach (perhaps due to extensive 
customizations).    

Note: This hard coded definition may include target installation content, and it 
may be used as a **partial** definition or **hybrid** with distbuilder manipulations 
and additions applied to it.    

This attribute is specifically applied when generating a 
[QtIfwConfig](ConfigClasses.md#qtifwconfig) object upon invoking the `qtIfwConfig()`
function for this class.

### *obj*.**ifwPackages** *class 'NoneType'* default: *None* { #ifwPackages data-toc-label=ifwPackages }

When producing a QtIFW installer, this attribute maybe used to list of "Qt IFW Packages".
Items in this list may be dynamic [QtIfwPackage](ConfigClasses.md#qtifwpackage) objects,
or be simple strings defining relative paths to QtIFW packages which are defined
as external resources, in the traditional (hard coded, content containing) IFW manner.

When building Python only derived installers, this attribute will be set automatically 
by a process class, and *NOT* have to be manually defined or manipulated unless 
there is a need to merge or modify packages pro grammatically.      

This attribute is specifically applied when upon invoking the `qtIfwPackage()`
function for this class.

For more information refer to: 

- [RobustInstallerProcess](#robustinstallerprocess)
- [QtIfwPackage list manipulation](LowLevel.md#qtifwpackage-list-manipulation) 

### *obj*.**isLimitedMaintenance** *class 'bool'* default: *True* { #isLimitedMaintenance data-toc-label=isLimitedMaintenance }

When producing a QtIFW installer, when this attribute is set to `True` (the 
default) the "maintenance tool" included with the distribution will not display
an introduction page with the options to add, remove, or update components.
It will only allow for uninstallation.  The extended options are only naturally
functional within QtIFW in the context of an **online** installer, which is 
not the default product of this library, and thus the selection of these radio 
buttons only produce errors.  Further, having this limitation imposed 
simplifies both the end user workflow and the developer's coding / testing tasks.  

When building an online installer, you may wish to enable the extended 
features, by disabling this switch.    

### *obj*.**replaceTarget** *class 'bool'* default: *False* { #replaceTarget data-toc-label=replaceTarget }

When producing a QtIFW installer, switch this attribute to `True` if you wish for the
installer to automatically replace a prior installation.  On Windows, this will reference
the applications registered in the OS, and run the uninstallation for the prior install
via that mechanism.  On other platforms, this uses the QtIFW Maintenance Tool directly to 
"silently" uninstall a prior install found at the target location.

### *obj*.**ifwWizardStyle** *class 'NoneType'* default: *None* { #ifwWizardStyle data-toc-label=ifwWizardStyle }

QtIFW installer predefined visual style.

- QtIfwConfigXml.DEFAULT_WIZARD_STYLE per platform        
- QtIfwConfigXml.WizardStyle.AERO     Windows Default    
- QtIfwConfigXml.WizardStyle.MAC      MacOS Default
- QtIfwConfigXml.WizardStyle.MODERN   Linux Default
- QtIfwConfigXml.WizardStyle.CLASSIC  Simliar to MODERN  

### *obj*.**ifwLogoFilePath** *class 'NoneType'* default: *None* { #ifwLogoFilePath data-toc-label=ifwLogoFilePath }

Relative or absolute path to QtIFW installer image resources.  These should .png 
files (on any platform).  Transparency is supported.

 Note: this is only applied in MODERN or CLASSIC style installers.   

### *obj*.**ifwBannerFilePath** *class 'NoneType'* default: *None* { #ifwBannerFilePath data-toc-label=ifwBannerFilePath }

Relative or absolute path to QtIFW installer image resources.  These should .png 
files (on any platform).  Transparency is supported.

 Note: this is only applied in MODERN style installers.   

### *obj*.**licensePath** *class 'NoneType'* default: *None* { #licensePath data-toc-label=licensePath }

Relative or absolute path to a license file to be included in an installer, which the 
end user will be required to agree to.        

### *obj*.**ifwUiPages** *class 'NoneType'* default: *None* { #ifwUiPages data-toc-label=ifwUiPages }

Use this to specify a list of [QtIfwUiPage](ConfigClasses.md#qtifwuipage) 
objects.  With that, you may fully customize the installer's UI using the
[Qt Designer WYSIWYG](https://doc.qt.io/qt-5/designer-quick-start.html) tool!

[Installer Scripting](LowLevel.md#installer-scripting), or the higher level
script abstraction classes [QtIfwControlScript](ConfigClasses.md#qtifwcontrolscript) and
[QtIfwPackageScript](ConfigClasses.md#qtifwpackagescript) can be used to provide
dynamic features for the page. 

### *obj*.**ifwWidgets** *class 'NoneType'* default: *None* { #ifwWidgets data-toc-label=ifwWidgets }


### *obj*.**ifwCntrlScript** *class 'NoneType'* default: *None* { #ifwCntrlScript data-toc-label=ifwCntrlScript }

QtIFW installers may have a "Control Script" and/or a collection of "Package Scripts".
The "Control Script" is intended to dictate how the installer *interface*  behaves, and
other high level logic pertaining to the installer itself. In contrast, "Package Scripts"
are intended for applying custom logic to manipulate a target environment when installing 
a given package.

These "Control Script" attributes are specifically applied when invoking the 
`qtIfwControlScript()` function for this class.

The attributes `ifwCntrlScript`, `ifwCntrlScriptText`, `ifwCntrlScriptPath` are mutually
exclusive.  Only one will be applied (the others such be set to `None`), with the 
priority being in that order. 

The `ifwCntrlScript` attribute is a [QtIfwControlScript](ConfigClasses.md#qtifwcontrolscript)     
object.

The `ifwCntrlScriptText` attribute is a means to supply the script as a raw string.

The `ifwCntrlScriptPath` is a file path (relative to the build script) to an externally 
defined script.

`ifwCntrlScriptName` provides a means to define the name of the file generated, in case 
there is need or desire to override the default.         

### *obj*.**ifwCntrlScriptText** *class 'NoneType'* default: *None* { #ifwCntrlScriptText data-toc-label=ifwCntrlScriptText }


### *obj*.**ifwCntrlScriptPath** *class 'NoneType'* default: *None* { #ifwCntrlScriptPath data-toc-label=ifwCntrlScriptPath }


### *obj*.**ifwCntrlScriptName** *class 'str'* default: *"installscript.qs"* { #ifwCntrlScriptName data-toc-label=ifwCntrlScriptName }


### *obj*.**ifwPkgId** *class 'NoneType'* default: *None* { #ifwPkgId data-toc-label=ifwPkgId }

`ifwPkgId` is employed for distbuilder operations where multiple packages are
involved. For more information refer to: 

[QtIfwPackage list manipulation](LowLevel.md#qtifwpackage-list-manipulation)             

### *obj*.**ifwPkgName** *class 'NoneType'* default: *None* { #ifwPkgName data-toc-label=ifwPkgName }

This attribute is utilized to differentiate [QtIfwPackage](ConfigClasses.md#qtifwpackage) 
objects, and the packages which are produced for an installer.

[RobustInstallerProcess](#robustinstallerprocess). 

`ifwPkgName` and `ifwPkgNamePrefix` are provided to override the name used by the
QtInstaller for deployment on a target environment.  Normally, you may allow
distbuilder to set the name for you automatically.

### *obj*.**ifwPkgNamePrefix** *class 'str'* default: *"com"* { #ifwPkgNamePrefix data-toc-label=ifwPkgNamePrefix }

This attribute is utilized to differentiate [QtIfwPackage](ConfigClasses.md#qtifwpackage) 
objects, and the packages which are produced for an installer.

[RobustInstallerProcess](#robustinstallerprocess). 

`ifwPkgName` and `ifwPkgNamePrefix` are provided to override the name used by the
QtInstaller for deployment on a target environment.  Normally, you may allow
distbuilder to set the name for you automatically.

### *obj*.**ifwPkgIsDefault** *class 'bool'* default: *True* { #ifwPkgIsDefault data-toc-label=ifwPkgIsDefault }

Simple option for controlling how the package 
(i.e. component) will be selected by the end user of the installer.
`ifwPkgIsDefault` will automatically select (or not select) the component by
default.   

### *obj*.**ifwPkgIsRequired** *class 'bool'* default: *False* { #ifwPkgIsRequired data-toc-label=ifwPkgIsRequired }

Simple option for controlling how the package 
(i.e. component) will be selected by the end user of the installer.
`ifwPkgIsRequired` dictates if the user can opt out of the component.

### *obj*.**ifwPkgIsHidden** *class 'bool'* default: *False* { #ifwPkgIsHidden data-toc-label=ifwPkgIsHidden }

Simple option for controlling how the package 
(i.e. component) will be selected by the end user of the installer.
`ifwPkgIsHidden` is similar to `ifwPkgIsDefault` and `ifwPkgIsRequired`, 
but insulates the user from even seeing the component as separate entity 
when enabled.  

### *obj*.**ifwPkgScript** *class 'NoneType'* default: *None* { #ifwPkgScript data-toc-label=ifwPkgScript }

QtIFW installers may have a "Control Script" and/or a collection of "Package Scripts".
The "Control Script" is intended to dictate how the installer *interface*  behaves, and
other high level logic pertaining to the installer itself. In contrast, "Package Scripts"
are intended for applying custom logic to manipulate a target environment when installing 
a given package.

These "Package Script" attributes are specifically applied when invoking the 
`qtIfwPackageScript()` function for this class.

The attributes `ifwPkgScript`, `ifwPkgScriptText`, `ifwPkgScriptPath` are mutually
exclusive.  Only one will be applied (the others such be set to `None`), with the 
priority being in that order. 

The `ifwPkgScript` attribute is a [QtIfwPackageScript](ConfigClasses.md#qtifwpackagescript)     
object.

The `ifwPkgScriptText` attribute is a means to supply the script as a raw string.

The `ifwPkgScriptPath` is a file path (relative to the build script) to an externally 
defined script.

`ifwPkgScriptName` provides a means to define the name of the file generated, in case 
there is need or desire to override the default.         

### *obj*.**ifwPkgScriptText** *class 'NoneType'* default: *None* { #ifwPkgScriptText data-toc-label=ifwPkgScriptText }


### *obj*.**ifwPkgScriptPath** *class 'NoneType'* default: *None* { #ifwPkgScriptPath data-toc-label=ifwPkgScriptPath }


### *obj*.**ifwPkgScriptName** *class 'str'* default: *"installscript.qs"* { #ifwPkgScriptName data-toc-label=ifwPkgScriptName }


### *obj*.**pkgType** *class 'NoneType'* default: *None* { #pkgType data-toc-label=pkgType }

This specifies the type (`QtIfwPackage.Type`) of package being built.  
The options for this include:  

- QtIfwPackage.Type.RAW
- QtIfwPackage.Type.DATA
- QtIfwPackage.Type.RESOURCE
- QtIfwPackage.Type.PY_INSTALLER
- QtIfwPackage.Type.IEXPRESS
- QtIfwPackage.Type.QT_CPP         

If this is omitted, and a `binaryName` attribute is specified, type `PY_INSTALLER` is assumed.  If this is omitted, but no `binaryName` is specified, the `DATA` type is assumed.  

The `RESOURCE` type indicates that the package does not contain any "directly installed 
content" (in the traditional sense at least).  This is to be used in situations where you 
want to simply bundle custom installation operations / scripts as a "component".  Note, 
however, that installer **resources** may be attached to such operations, and which are *not* 
"directly installed content".  A notable use case where you would include a resource, 
but no content files in a package, would be to "nest" another installer inside of the outer one.  The nested installer would be a resource, invoked by a custom operation.  
See: 
[QtIfwExternalResource](ConfigClasses.md#qtifwexternalresource)
[QtIfwExternalOp](ConfigClasses.md#qtifwexternalop)   

### *obj*.**pkgSubDirName** *class 'NoneType'* default: *None* { #pkgSubDirName data-toc-label=pkgSubDirName }

If a `pkgSubDirName` is specified, this places the package inside of sub directory, 
rather than having the contents there of installed directly to the top level directory
of the target.

By default, this attribute is `None`, which is ideal for single package products. 
When multiple packages are present, however, the content of each will be merged into 
one directory during installation (if the end user selects more than one package).  
In the event "collisions" could occur (at installation or run time) due to this, 
the suggested resolution is to employ this option, thereby encapsulating the package(s). 

### *obj*.**pkgSrcDirPath** *class 'NoneType'* default: *None* { #pkgSrcDirPath data-toc-label=pkgSrcDirPath }

When building installers that have external resources which are not part of
automatically generated products/packages, these attributes may be used to define the paths
to that package's content.  

When the `pkgSrcDirPath` is not supplied, this is path defined 
by either a [PyInstallerConfig](ConfigClasses.md#pyinstallerconfig) object definition,
or assumed to simply be a sub directory adjacent to the build script
*with the same name* as the `binaryName` attribute.

The attribute `pkgSrcExePath` must only be supplied when the package contains a
"primary" executable which was not produced by a process with the library (i.e. 
it was complied previously by some other build system).  Note, that if `binaryName`
is also defined, the `pkgSrcExePath` file will be renamed to that name upon building
the package. 

See: [RobustInstallerProcess](#robustinstallerprocess).         

### *obj*.**pkgSrcExePath** *class 'NoneType'* default: *None* { #pkgSrcExePath data-toc-label=pkgSrcExePath }

When building installers that have external resources which are not part of
automatically generated products/packages, these attributes may be used to define the paths
to that package's content.  

When the `pkgSrcDirPath` is not supplied, this is path defined 
by either a [PyInstallerConfig](ConfigClasses.md#pyinstallerconfig) object definition,
or assumed to simply be a sub directory adjacent to the build script
*with the same name* as the `binaryName` attribute.

The attribute `pkgSrcExePath` must only be supplied when the package contains a
"primary" executable which was not produced by a process with the library (i.e. 
it was complied previously by some other build system).  Note, that if `binaryName`
is also defined, the `pkgSrcExePath` file will be renamed to that name upon building
the package. 

See: [RobustInstallerProcess](#robustinstallerprocess).         

### *obj*.**pkgCodeSignTargets** *class 'NoneType'* default: *None* { #pkgCodeSignTargets data-toc-label=pkgCodeSignTargets }


### *obj*.**pkgExeWrapper** *class 'NoneType'* default: *None* { #pkgExeWrapper data-toc-label=pkgExeWrapper }

A [QtIfwExeWrapper](ConfigClasses.md#qtifwexewrapper) object used to "wrap"
the primary executable in a [QtIfwPackage](ConfigClasses.md#qtifwpackage) 
being built using the factory provided configurations.

Such a wrapper can super impose environmental conditions on the context
within which the binary is run.  Notably, this may include an 
[ExecutableScript](LowLevel.md#executablescript) for maximum flexibility.
Follow the links to learn to more.        

### *obj*.**pkgExternalDependencies** *class 'NoneType'* default: *None* { #pkgExternalDependencies data-toc-label=pkgExternalDependencies }


**MAC / LINUX Only**

External packages to be installed.  This takes place prior to any 
other installer operations, in case those operations (rather the 
program being installed) are dependent upon such.

Provide a list of either simple strings and/or nested lists of strings.
When nesting lists, such represents alternate names to try based upon
what is available within a given package manager on the target.  
For example, the package "xvfb" maybe specified as `["xvfb","Xvfb"]`.  That handles the fact the "X" is capitalized 
within some contexts (e.g. within YUM on RHEL...) but is lower case in others.

### *obj*.**pkgConfigs** *class 'NoneType'* default: *None* { #pkgConfigs data-toc-label=pkgConfigs }


### *obj*.**startOnBoot** *class 'bool'* default: *False* { #startOnBoot data-toc-label=startOnBoot }

Enable `startOnBoot` to have the installer register the "primary" exe 
within a package as a program to launch upon booting the system. By default,
this is set to `False`, setting it to either `True` or to `CURRENT_USER` will have the same 
effect.  Assign it to `ALL_USERS` to have this applied for all system users. 

In Windows, this will lead to an auto implementation of a [QtIfwExeWrapper](ConfigClasses.md#qtifwexewrapper), which employs the special `isExe` feature,
producing a "wrapper/proxy/launcher" exe adjacent to the actual one.  That 
launcher is what will actually be registered in the OS.          

### *obj*.**codeSignConfig** *class 'NoneType'* default: *None* { #codeSignConfig data-toc-label=codeSignConfig }


### *obj*.**qtCppConfig** *class 'NoneType'* default: *None* { #qtCppConfig data-toc-label=qtCppConfig }

A [QtCppConfig](ConfigClasses.md#qtcppconfig) object.  Used to define how to
package programs developed within the Qt C++ libraries / framework. 

See the [Qt C++ Integration](QtCpp.md) document for more information.  

### *ConfigFactory*.**copy**`#!py3 (instance)` { #copy data-toc-label=copy }



______

